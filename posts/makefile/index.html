<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>makefile | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="makefile 核心 makefile的主要有三个核心：目标、依赖、命令
目标：一般指要编译的文件对象
依赖：一般指要生成的可执行文件
命令：指生成目标要执行的命令
规则 所有命令都必须用tab缩进，不能使用空格也不行 如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令 $^代表所有依赖 $<代表第一个依赖 $@代表目标 使用echo xxx命令会把该命令输出再输出xxx,可以使用@echo xxx来只输出xxx 如果使用空格缩进，那么会报错Makefile:2: *** missing separator. Stop. 一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则 使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示make: clean&rsquo; is up to date.` 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖 变量 ###自定义变量
makefile中可以将经常使用的命令、依赖定义成变量
makefile中变量区分大小写
makefile中对变量的引用使用$(xxx)
makefile中对变量的定义形式为A=xxx等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型
系统变量 CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc
RM：删除文件，相当于rm -f
可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：$(GOPATH) $(JAVA_HOME)
自动化变量 $^代表所有依赖文件
$<代表第一个依赖文件
$@代表目标文件
伪命令 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖
实践 GO= CGO_ENABLED=0 GO111MODULE=on go GOCGO = CGO_ENABLED=1 GO111MODULE=on go #在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字 GP = $(shell go env GOPATH) VERSION = v2.0.0 #commit id GIT_COMMIT=$(shell git rev-parse HEAD) #branch name GIT_BRANCH=$(shell git name-rev --name-only HEAD) #构建时间 BUILD_DATE=$(shell date '+%Y-%m-%d-%H:%M:%S') #使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息 #使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量 LDFLAGS = -ldflags &#34;-X makef/version."><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/makefile/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="makefile"><meta property="og:description" content="makefile 核心 makefile的主要有三个核心：目标、依赖、命令
目标：一般指要编译的文件对象
依赖：一般指要生成的可执行文件
命令：指生成目标要执行的命令
规则 所有命令都必须用tab缩进，不能使用空格也不行 如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令 $^代表所有依赖 $<代表第一个依赖 $@代表目标 使用echo xxx命令会把该命令输出再输出xxx,可以使用@echo xxx来只输出xxx 如果使用空格缩进，那么会报错Makefile:2: *** missing separator. Stop. 一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则 使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示make: clean&rsquo; is up to date.` 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖 变量 ###自定义变量
makefile中可以将经常使用的命令、依赖定义成变量
makefile中变量区分大小写
makefile中对变量的引用使用$(xxx)
makefile中对变量的定义形式为A=xxx等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型
系统变量 CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc
RM：删除文件，相当于rm -f
可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：$(GOPATH) $(JAVA_HOME)
自动化变量 $^代表所有依赖文件
$<代表第一个依赖文件
$@代表目标文件
伪命令 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖
实践 GO= CGO_ENABLED=0 GO111MODULE=on go GOCGO = CGO_ENABLED=1 GO111MODULE=on go #在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字 GP = $(shell go env GOPATH) VERSION = v2.0.0 #commit id GIT_COMMIT=$(shell git rev-parse HEAD) #branch name GIT_BRANCH=$(shell git name-rev --name-only HEAD) #构建时间 BUILD_DATE=$(shell date '+%Y-%m-%d-%H:%M:%S') #使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息 #使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量 LDFLAGS = -ldflags &#34;-X makef/version."><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/makefile/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="makefile"><meta name=twitter:description content="makefile 核心 makefile的主要有三个核心：目标、依赖、命令
目标：一般指要编译的文件对象
依赖：一般指要生成的可执行文件
命令：指生成目标要执行的命令
规则 所有命令都必须用tab缩进，不能使用空格也不行 如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令 $^代表所有依赖 $<代表第一个依赖 $@代表目标 使用echo xxx命令会把该命令输出再输出xxx,可以使用@echo xxx来只输出xxx 如果使用空格缩进，那么会报错Makefile:2: *** missing separator. Stop. 一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则 使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示make: clean&rsquo; is up to date.` 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖 变量 ###自定义变量
makefile中可以将经常使用的命令、依赖定义成变量
makefile中变量区分大小写
makefile中对变量的引用使用$(xxx)
makefile中对变量的定义形式为A=xxx等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型
系统变量 CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc
RM：删除文件，相当于rm -f
可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：$(GOPATH) $(JAVA_HOME)
自动化变量 $^代表所有依赖文件
$<代表第一个依赖文件
$@代表目标文件
伪命令 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖
实践 GO= CGO_ENABLED=0 GO111MODULE=on go GOCGO = CGO_ENABLED=1 GO111MODULE=on go #在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字 GP = $(shell go env GOPATH) VERSION = v2.0.0 #commit id GIT_COMMIT=$(shell git rev-parse HEAD) #branch name GIT_BRANCH=$(shell git name-rev --name-only HEAD) #构建时间 BUILD_DATE=$(shell date '+%Y-%m-%d-%H:%M:%S') #使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息 #使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量 LDFLAGS = -ldflags &#34;-X makef/version."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"makefile","item":"https://moyuduo.github.io/posts/makefile/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"makefile","name":"makefile","description":"makefile 核心 makefile的主要有三个核心：目标、依赖、命令\n目标：一般指要编译的文件对象\n依赖：一般指要生成的可执行文件\n命令：指生成目标要执行的命令\n规则 所有命令都必须用tab缩进，不能使用空格也不行 如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令 $^代表所有依赖 $\u0026lt;代表第一个依赖 $@代表目标 使用echo xxx命令会把该命令输出再输出xxx,可以使用@echo xxx来只输出xxx 如果使用空格缩进，那么会报错Makefile:2: *** missing separator. Stop. 一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则 使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示make: clean\u0026rsquo; is up to date.` 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖 变量 ###自定义变量\nmakefile中可以将经常使用的命令、依赖定义成变量\nmakefile中变量区分大小写\nmakefile中对变量的引用使用$(xxx)\nmakefile中对变量的定义形式为A=xxx等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型\n系统变量 CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc\nRM：删除文件，相当于rm -f\n可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：$(GOPATH) $(JAVA_HOME)\n自动化变量 $^代表所有依赖文件\n$\u0026lt;代表第一个依赖文件\n$@代表目标文件\n伪命令 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖\n实践 GO= CGO_ENABLED=0 GO111MODULE=on go GOCGO = CGO_ENABLED=1 GO111MODULE=on go #在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字 GP = $(shell go env GOPATH) VERSION = v2.0.0 #commit id GIT_COMMIT=$(shell git rev-parse HEAD) #branch name GIT_BRANCH=$(shell git name-rev --name-only HEAD) #构建时间 BUILD_DATE=$(shell date \u0026#39;+%Y-%m-%d-%H:%M:%S\u0026#39;) #使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息 #使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量 LDFLAGS = -ldflags \u0026#34;-X makef/version.","keywords":[],"articleBody":"makefile 核心 makefile的主要有三个核心：目标、依赖、命令\n目标：一般指要编译的文件对象\n依赖：一般指要生成的可执行文件\n命令：指生成目标要执行的命令\n规则 所有命令都必须用tab缩进，不能使用空格也不行 如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令 $^代表所有依赖 $\u003c代表第一个依赖 $@代表目标 使用echo xxx命令会把该命令输出再输出xxx,可以使用@echo xxx来只输出xxx 如果使用空格缩进，那么会报错Makefile:2: *** missing separator. Stop. 一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则 使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示make: clean’ is up to date.` 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖 变量 ###自定义变量\nmakefile中可以将经常使用的命令、依赖定义成变量\nmakefile中变量区分大小写\nmakefile中对变量的引用使用$(xxx)\nmakefile中对变量的定义形式为A=xxx等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型\n系统变量 CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc\nRM：删除文件，相当于rm -f\n可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：$(GOPATH) $(JAVA_HOME)\n自动化变量 $^代表所有依赖文件\n$\u003c代表第一个依赖文件\n$@代表目标文件\n伪命令 如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用.PHONY:clean标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖\n实践 GO= CGO_ENABLED=0 GO111MODULE=on go GOCGO = CGO_ENABLED=1 GO111MODULE=on go #在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字 GP = $(shell go env GOPATH) VERSION = v2.0.0 #commit id GIT_COMMIT=$(shell git rev-parse HEAD) #branch name GIT_BRANCH=$(shell git name-rev --name-only HEAD) #构建时间 BUILD_DATE=$(shell date '+%Y-%m-%d-%H:%M:%S') #使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息 #使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量 LDFLAGS = -ldflags \"-X makef/version.Version=$(VERSION)\" add:cmd/add/main.go $(GO) build $(LDFLAGS) -o $@ $^ sub:cmd/sub/main.go $(GOCGO) build $(LDFLAGS) -o $@ $^ # -gcflags指定all=-N可以指定禁止优化， -l禁止内联, 禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试 GOBUILD = $(GOCMD) build -gcflags \"all=-N -l\" -ldflags \"$(LDFLAGS)\" #这种写法不行会报错： #CGO_ENABLED=0 GO111MODULE=on go build -ldflags \"-X makef/version.Version=v2.0.0\" -o add cmd/add #package cmd/add is not in GOROOT (/storehouse/go/src/cmd/add) #make: *** [add] Error 1 add:./cmd/add $(GO) build $(LDFLAGS) -o $@ $^ #这种写法没问题 add: $(GO) build $(LDFLAGS) -o $@ ./cmd/add 当执行make命令时会执行当前目录下的makefile/Makefile中的第一条命令\n","wordCount":"167","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/makefile/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://moyuduo.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://moyuduo.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>makefile</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#核心>核心</a></li><li><a href=#规则>规则</a></li><li><a href=#变量>变量</a><ul><li><a href=#系统变量>系统变量</a></li><li><a href=#自动化变量>自动化变量</a></li></ul></li><li><a href=#伪命令>伪命令</a></li><li><a href=#实践>实践</a></li></ul></nav></div></details></div><div class=post-content><h1 id=makefile>makefile<a hidden class=anchor aria-hidden=true href=#makefile>#</a></h1><h2 id=核心>核心<a hidden class=anchor aria-hidden=true href=#核心>#</a></h2><p>makefile的主要有三个核心：目标、依赖、命令</p><p>目标：一般指要编译的文件对象</p><p>依赖：一般指要生成的可执行文件</p><p>命令：指生成目标要执行的命令</p><h2 id=规则>规则<a hidden class=anchor aria-hidden=true href=#规则>#</a></h2><ol><li>所有命令都必须用tab缩进，不能使用空格也不行</li><li>如果有多个依赖可以用tab、空格分隔，如果一个目标有多个依赖，那么会依次执行依赖的命令，最后执行该目标本身的命令</li><li>$^代表所有依赖</li><li>$&lt;代表第一个依赖</li><li>$@代表目标</li><li>使用<code>echo xxx</code>命令会把该命令输出再输出xxx,可以使用<code>@echo xxx</code>来只输出xxx</li><li>如果使用空格缩进，那么会报错<code>Makefile:2: *** missing separator. Stop.</code></li><li>一条makefile规则的依赖可以是该makefile中其他规则的目标，那么再执行该规则时，会去执行依赖的规则</li><li>使用make命令生成目标时会检测依赖和目标的时间戳，如果目标已经存在且目标的时间戳大于所有依赖，那么意味着依赖并没有改动，那么无需重新生成目标，会提示<code>make: </code>clean&rsquo; is up to date.`</li><li>如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用<code>.PHONY:clean</code>标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖</li></ol><h2 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h2><p>###自定义变量</p><p>makefile中可以将经常使用的命令、依赖定义成变量</p><p>makefile中变量区分大小写</p><p>makefile中对变量的引用使用<code>$(xxx)</code></p><p>makefile中对变量的定义形式为<code>A=xxx</code>等号两边可以有空格，不需要加引号，因为makefile中变量中油字符串类型</p><h3 id=系统变量>系统变量<a hidden class=anchor aria-hidden=true href=#系统变量>#</a></h3><p>CC：编译器名字，默认CC等于gcc CC = arm-linux-gcc</p><p>RM：删除文件，相当于rm -f</p><p>可以使用$(ENV_NAME)来获取系统定义好的环境变量，如：<code>$(GOPATH) $(JAVA_HOME)</code></p><h3 id=自动化变量>自动化变量<a hidden class=anchor aria-hidden=true href=#自动化变量>#</a></h3><p>$^代表所有依赖文件</p><p>$&lt;代表第一个依赖文件</p><p>$@代表目标文件</p><h2 id=伪命令>伪命令<a hidden class=anchor aria-hidden=true href=#伪命令>#</a></h2><p>如果一条makefile规则没有依赖且该目标文件存在，那么始终不会执行该规则的命令，而有些时候我会想执行一些清除操作，如rm如果这条规则的目标叫clean，如果恰巧该文件夹下有一个文件叫clean，那么就不能执行清除，此时可以使用<code>.PHONY:clean</code>标记clean目标不需要检查目标文件是否存在，目标文件的时间戳是否大于所有依赖</p><h2 id=实践>实践<a hidden class=anchor aria-hidden=true href=#实践>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nv>GO</span><span class=o>=</span>   <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>0</span> <span class=nv>GO111MODULE</span><span class=o>=</span>on go
</span></span><span class=line><span class=cl><span class=nv>GOCGO</span> <span class=o>=</span> <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>1</span> <span class=nv>GO111MODULE</span><span class=o>=</span>on go
</span></span><span class=line><span class=cl><span class=c>#在申明变量时，如果要执行shell中的命令获取值需要使用$(shell xxx)，这是因为如果只使用$(xxx)的话回去取xxx变量的值，而xxx变量不存在，所以要在定义变量时使用shell命令必须使用shell关键字
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>GP</span> <span class=o>=</span> <span class=k>$(</span>shell go env GOPATH<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>VERSION</span> <span class=o>=</span> v2.0.0
</span></span><span class=line><span class=cl><span class=c>#commit id
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>GIT_COMMIT</span><span class=o>=</span><span class=k>$(</span>shell git rev-parse HEAD<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c>#branch name
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>GIT_BRANCH</span><span class=o>=</span><span class=k>$(</span>shell git name-rev --name-only HEAD<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c>#构建时间
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>BUILD_DATE</span><span class=o>=</span><span class=k>$(</span>shell date <span class=s1>&#39;+%Y-%m-%d-%H:%M:%S&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>#使用go build的-ldflags 参数可以在编译的时候对变量进行赋值，常用在编译时添加版本、架构、编译日期等信息
</span></span></span><span class=line><span class=cl><span class=c>#使用-X参数进行替换，makef为项目名称，为go mod init makef, version是该项目下的一个包， Version为包中的一个变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>LDFLAGS</span> <span class=o>=</span> -ldflags <span class=s2>&#34;-X makef/version.Version=</span><span class=k>$(</span>VERSION<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>add</span><span class=o>:</span><span class=n>cmd</span>/<span class=n>add</span>/<span class=n>main</span>.<span class=n>go</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>GO<span class=k>)</span> build <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o <span class=nv>$@</span> $^
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>sub</span><span class=o>:</span><span class=n>cmd</span>/<span class=n>sub</span>/<span class=n>main</span>.<span class=n>go</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>GOCGO<span class=k>)</span> build <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o <span class=nv>$@</span> $^
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=c># -gcflags指定all=-N可以指定禁止优化， -l禁止内联, 禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>GOBUILD</span> <span class=o>=</span> <span class=k>$(</span>GOCMD<span class=k>)</span> build -gcflags <span class=s2>&#34;all=-N -l&#34;</span> -ldflags <span class=s2>&#34;</span><span class=k>$(</span>LDFLAGS<span class=k>)</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>#这种写法不行会报错：
</span></span></span><span class=line><span class=cl><span class=c>#CGO_ENABLED=0 GO111MODULE=on go build -ldflags &#34;-X makef/version.Version=v2.0.0&#34; -o add cmd/add
</span></span></span><span class=line><span class=cl><span class=c>#package cmd/add is not in GOROOT (/storehouse/go/src/cmd/add)
</span></span></span><span class=line><span class=cl><span class=c>#make: *** [add] Error 1
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>add</span><span class=o>:</span>./<span class=n>cmd</span>/<span class=n>add</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>GO<span class=k>)</span> build <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o <span class=nv>$@</span> $^
</span></span><span class=line><span class=cl><span class=c>#这种写法没问题
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>add</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>GO<span class=k>)</span> build <span class=k>$(</span>LDFLAGS<span class=k>)</span> -o <span class=nv>$@</span> ./cmd/add
</span></span></code></pre></div><p>当执行<code>make</code>命令时会执行当前目录下的<code>makefile/Makefile</code>中的<strong>第一条命令</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>