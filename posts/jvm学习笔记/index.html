<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JVM学习笔记 | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="JVM学习笔记 JVM结构 Java虚拟机终止的情况 程序正常执行完成 程序显式调用System.exit()方法 程序中出现了异常或错误 操作系统底层出现了错误 Java类的加载、连接、初始化 加载：加载类的字节码文件到内存
连接
验证：验证字节码文件的正确性
主要验证 1类文件结构
​	2语义检查
​	3字节码验证
​	4二进制兼容性验证（老版本.class文件可以运行在新版本上）
准备：为类静态变量分配地址空间，并初始化为默认值
解析：把变量的字符引用替换为直接引用
初始化：为类的静态变量赋值
加载 JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误
加载器根据是否是用户自定义的可以分为
系统自带类加载器 启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类 扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类 应用类加载器（App）主要加载类路径下用户自定义的类 用户自定义加载器 用于加载指定路径的.class文件 类加载的双亲委托机制 加载器在逻辑上形成一种树形结构
加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系
双亲委托机制的优点 双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。
类加载器命名空间 同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。
当前类加载 每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY
线程的类加载器 每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器
线程上下文加载器 在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面
当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类
获取类加载器 //获取当前类的ClassLoader clazz.getClassLoader(); //获取当前线程的ClassLoader Thread.currentThread().getContextClassLoader(); //获取系统ClassLoader ClassLoader.getSystemClassLoader(); //获取调用者的ClassLoader DriverManager.getCallerClassLoader(); 初始化 Java虚拟机在类或接口“首次主动使用”的时候初始化
主动使用：1. 创建类的实例
​	2.访问类或接口的静态变量
​	3.调用类的静态方法
​	4.反射，Class.forName(&ldquo;xxx&rdquo;);
​	5.初始化一个类的子类
​	6.启动类(包含main方法的类)
​	7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化"><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="JVM学习笔记"><meta property="og:description" content="JVM学习笔记 JVM结构 Java虚拟机终止的情况 程序正常执行完成 程序显式调用System.exit()方法 程序中出现了异常或错误 操作系统底层出现了错误 Java类的加载、连接、初始化 加载：加载类的字节码文件到内存
连接
验证：验证字节码文件的正确性
主要验证 1类文件结构
​	2语义检查
​	3字节码验证
​	4二进制兼容性验证（老版本.class文件可以运行在新版本上）
准备：为类静态变量分配地址空间，并初始化为默认值
解析：把变量的字符引用替换为直接引用
初始化：为类的静态变量赋值
加载 JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误
加载器根据是否是用户自定义的可以分为
系统自带类加载器 启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类 扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类 应用类加载器（App）主要加载类路径下用户自定义的类 用户自定义加载器 用于加载指定路径的.class文件 类加载的双亲委托机制 加载器在逻辑上形成一种树形结构
加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系
双亲委托机制的优点 双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。
类加载器命名空间 同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。
当前类加载 每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY
线程的类加载器 每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器
线程上下文加载器 在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面
当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类
获取类加载器 //获取当前类的ClassLoader clazz.getClassLoader(); //获取当前线程的ClassLoader Thread.currentThread().getContextClassLoader(); //获取系统ClassLoader ClassLoader.getSystemClassLoader(); //获取调用者的ClassLoader DriverManager.getCallerClassLoader(); 初始化 Java虚拟机在类或接口“首次主动使用”的时候初始化
主动使用：1. 创建类的实例
​	2.访问类或接口的静态变量
​	3.调用类的静态方法
​	4.反射，Class.forName(&ldquo;xxx&rdquo;);
​	5.初始化一个类的子类
​	6.启动类(包含main方法的类)
​	7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化"><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="JVM学习笔记"><meta name=twitter:description content="JVM学习笔记 JVM结构 Java虚拟机终止的情况 程序正常执行完成 程序显式调用System.exit()方法 程序中出现了异常或错误 操作系统底层出现了错误 Java类的加载、连接、初始化 加载：加载类的字节码文件到内存
连接
验证：验证字节码文件的正确性
主要验证 1类文件结构
​	2语义检查
​	3字节码验证
​	4二进制兼容性验证（老版本.class文件可以运行在新版本上）
准备：为类静态变量分配地址空间，并初始化为默认值
解析：把变量的字符引用替换为直接引用
初始化：为类的静态变量赋值
加载 JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误
加载器根据是否是用户自定义的可以分为
系统自带类加载器 启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类 扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类 应用类加载器（App）主要加载类路径下用户自定义的类 用户自定义加载器 用于加载指定路径的.class文件 类加载的双亲委托机制 加载器在逻辑上形成一种树形结构
加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系
双亲委托机制的优点 双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。
类加载器命名空间 同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。
当前类加载 每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY
线程的类加载器 每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器
线程上下文加载器 在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面
当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类
获取类加载器 //获取当前类的ClassLoader clazz.getClassLoader(); //获取当前线程的ClassLoader Thread.currentThread().getContextClassLoader(); //获取系统ClassLoader ClassLoader.getSystemClassLoader(); //获取调用者的ClassLoader DriverManager.getCallerClassLoader(); 初始化 Java虚拟机在类或接口“首次主动使用”的时候初始化
主动使用：1. 创建类的实例
​	2.访问类或接口的静态变量
​	3.调用类的静态方法
​	4.反射，Class.forName(&ldquo;xxx&rdquo;);
​	5.初始化一个类的子类
​	6.启动类(包含main方法的类)
​	7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JVM学习笔记","item":"https://moyuduo.github.io/posts/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JVM学习笔记","name":"JVM学习笔记","description":"JVM学习笔记 JVM结构 Java虚拟机终止的情况 程序正常执行完成 程序显式调用System.exit()方法 程序中出现了异常或错误 操作系统底层出现了错误 Java类的加载、连接、初始化 加载：加载类的字节码文件到内存\n连接\n验证：验证字节码文件的正确性\n主要验证 1类文件结构\n​\t2语义检查\n​\t3字节码验证\n​\t4二进制兼容性验证（老版本.class文件可以运行在新版本上）\n准备：为类静态变量分配地址空间，并初始化为默认值\n解析：把变量的字符引用替换为直接引用\n初始化：为类的静态变量赋值\n加载 JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误\n加载器根据是否是用户自定义的可以分为\n系统自带类加载器 启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类 扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类 应用类加载器（App）主要加载类路径下用户自定义的类 用户自定义加载器 用于加载指定路径的.class文件 类加载的双亲委托机制 加载器在逻辑上形成一种树形结构\n加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系\n双亲委托机制的优点 双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。\n类加载器命名空间 同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。\n当前类加载 每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY\n线程的类加载器 每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器\n线程上下文加载器 在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面\n当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类\n获取类加载器 //获取当前类的ClassLoader clazz.getClassLoader(); //获取当前线程的ClassLoader Thread.currentThread().getContextClassLoader(); //获取系统ClassLoader ClassLoader.getSystemClassLoader(); //获取调用者的ClassLoader DriverManager.getCallerClassLoader(); 初始化 Java虚拟机在类或接口“首次主动使用”的时候初始化\n主动使用：1. 创建类的实例\n​\t2.访问类或接口的静态变量\n​\t3.调用类的静态方法\n​\t4.反射，Class.forName(\u0026ldquo;xxx\u0026rdquo;);\n​\t5.初始化一个类的子类\n​\t6.启动类(包含main方法的类)\n​\t7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化","keywords":[],"articleBody":"JVM学习笔记 JVM结构 Java虚拟机终止的情况 程序正常执行完成 程序显式调用System.exit()方法 程序中出现了异常或错误 操作系统底层出现了错误 Java类的加载、连接、初始化 加载：加载类的字节码文件到内存\n连接\n验证：验证字节码文件的正确性\n主要验证 1类文件结构\n​\t2语义检查\n​\t3字节码验证\n​\t4二进制兼容性验证（老版本.class文件可以运行在新版本上）\n准备：为类静态变量分配地址空间，并初始化为默认值\n解析：把变量的字符引用替换为直接引用\n初始化：为类的静态变量赋值\n加载 JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误\n加载器根据是否是用户自定义的可以分为\n系统自带类加载器 启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类 扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类 应用类加载器（App）主要加载类路径下用户自定义的类 用户自定义加载器 用于加载指定路径的.class文件 类加载的双亲委托机制 加载器在逻辑上形成一种树形结构\n加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系\n双亲委托机制的优点 双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。\n类加载器命名空间 同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。\n当前类加载 每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY\n线程的类加载器 每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器\n线程上下文加载器 在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面\n当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类\n获取类加载器 //获取当前类的ClassLoader clazz.getClassLoader(); //获取当前线程的ClassLoader Thread.currentThread().getContextClassLoader(); //获取系统ClassLoader ClassLoader.getSystemClassLoader(); //获取调用者的ClassLoader DriverManager.getCallerClassLoader(); 初始化 Java虚拟机在类或接口“首次主动使用”的时候初始化\n主动使用：1. 创建类的实例\n​\t2.访问类或接口的静态变量\n​\t3.调用类的静态方法\n​\t4.反射，Class.forName(“xxx”);\n​\t5.初始化一个类的子类\n​\t6.启动类(包含main方法的类)\n​\t7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化\npublic class Test1 { public static void main(String[] args) { System.out.println(Child.str1); } } class Parent{ public static String str1=\"hello\"; static { System.out.println(\"Parent Static Block\"); } } class Child extends Parent{ public static String str2=\"world\"; static { System.out.println(\"Child Static Block\"); } } 输出： Parent Static Block hello 调用Child.str1并没用输出Child的静态代码块，可以得出这样一个结论，对应静态变量，只会去初始化定义该变量的类，即只主动使用了Parent类\npublic class Test2 { public static void main(String[] args) { System.out.println(Parent2.str); } } class Parent2{ public static final String str=\"hello\"; static { System.out.println(\"parent2 static block\"); } } 输出： hello 在一个类中使用另一个类static final修饰的变量时，会把该变量推送至调用这个变量方法的类的常量池中，而不会去初始化这个类，并且是在编译期进行的\npublic class Test3 { public static void main(String[] args) { System.out.println(Parent3.str); } } class Parent3{ public static final String str=UUID.randomUUID().toString(); static { System.out.println(\"parent3 static block\"); } } 输出： parent3 static block f7e58be0-7e43-4a3a-870f-90e8fdbe8b48 对于static final修饰的变量在编译时不是常量的情况，会导致该类的初始化，所以static代码块会执行\n理解准备阶段和初始化阶段\npublic class Test4 { public static void main(String[] args) { Singleton instance = Singleton.getInstance(); System.out.println(\"a:\"+instance.a); System.out.println(\"b:\"+instance.b); } } class Singleton{ public static int a; private static Singleton instance=new Singleton(); public static int b=0; private Singleton() { a++; b++; System.out.println(a); System.out.println(b); } public static Singleton getInstance() { return instance; } } 输出： 1 1 a:1 b:0 Singleton.getInstance();会导致对Singleton类的首次主动使用，那么就会去初始化Singleton类，在初始化之前，已经完成了连接阶段中的准备阶段，所以此时a为默认值0，instance为默认值null，b为默认值0，进行初始化阶段时是顺序执行的，首先执行public static int a;语句，并没有赋值，接着执行private static Singleton instance=new Singleton();语句，此时调用构造方法对a++，b++，所以输出1和1，在执行public static int b=0;语句，此时有赋值，那么把b的值赋值为了0，所以拿到的instance的a为1，b为0\n类初始化步骤 如果这个类还没有被加载和连接，那么进行加载和连接 如果类存在直接父类，并且这个类还没有被初始化，那么先初始化父类，在初始化自己 依次顺序执行类中的初始化语句 类在进行初始化时，要求它的所有父类都已经初始化 类初始化时，并不要求它所实现的所有接口都初始化，只有当使用到接口才初始化 初始化接口时，并不要求初始化它的父接口 实例化 为对象分配空间 为成员变量赋默认值 为成员变量赋正确的初始值 如果没有构造方法，那么生成默认初始化方法 回收 卸载 当类被加载、连接、初始化之后它的生命周期就开始了。当类的Class对象不再被引用，即不可触及，那么Class对象就会结束生命周期，类在方法区的数据（类的静态变量）也会被卸载。\n由java虚拟机自带的类加载器加载的类，在虚拟机的生命周期中，始终不会被卸载。这是因为java虚拟机会引用这些类加载器，这些类加载器会始终引用他们所加载的类，因此这些Class对象始终不会被卸载。\n由用户自定义加载器加载的类是可以被卸载的。\n内存划分 程序计数器 程序计数器是线程私有的。\n存储指向下一条指令的地址。即要执行的代码。\n虚拟机栈（java栈） 虚拟机栈是线程私有空间。\n虚拟机栈中没有GC。因为方法执行就入栈，执行完了就出栈了。\n栈是运行的单位，而堆是存储的单位。\n栈内保存了一个个栈帧，一个栈帧对应一个java方法\n可以通过**-Xss**256k参数来设置栈的大小\n栈帧的内部结构：\n局部变量表\n被定义为一个数字数组，主要存储方法的参数和在方法体中定义的局部变量，这些参数的类型包括基本数据类型、对象引用、returnAddress类型。由于局部变量表示在线程私有的栈空间中，所以不存在数据安全问题。局部变量表的大小在编译器就被确定下来，在方法运行期不会改变。如果是非静态方法，那么局部变量表的0号位置放置的是this。相较于类变量，局部变量并不会赋默认值，所以在使用之间应该显式赋值。\n局部变量表中的变量是垃圾回收的根节点，只要被局部变量表中变量直接或间接引用的对象都不会被回收。\n操作数栈\n主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，操作数栈是JVM执行引擎的一个工作空间，当一个方法执行的时候，一个新的栈帧会被创建出来，这个方法的操作数栈是空的，没一个操作数栈的栈深度是确定的，在编译期就被确定下来。\n动态链接\n每一个栈帧内都包含一个指向该栈帧所属方法的引用，这个引用的目的是使当前方法的代码能够实现动态链接。动态链接就是指向方法区中对应方法的一个引用，有了这个引用就不需要再每个栈帧中存放方法的具体信息。\n方法返回地址\n方法返回地址记录的是调用者程序计数器的值，即调用方法的指令的下一条指令的地址\n一些附加信息\n可能存在一些附加信息，如程序调试附加信息\n本地方法栈 主要用于处理java中调用c或C++实现的本地方法。\n本地方法栈也没有GC。\nHotSpot虚拟机把本地方法栈和java虚拟机栈合二为一。\n堆 堆内存是所有线程共享的。\n堆空间在物理内存上可能是连续的也可能是不连续的。\n通过**-Xms**5m参数指定堆空间初始5m\n通过**-Xmx**5m参数指定堆空间最大5m\n通过-XX:+HeapDumpOnOutOfMemoryError参数指定堆上发生内存溢出输入日志\n通过-XX:+PrintGCDetails参数打印GC回收信息\njdk1.8之后堆内存在逻辑上分为三部分：新生代+老年代+元空间\n-XX:NewRatio=2参数用来设置老年代和新生代的空间比值，默认为2，即老年代空间/新生代空间=2\n在HotSpot中Eden区和Survivor0和Survivor1空间的比列是8:1:1\n-XX:SurvivorRatio=8参数可用于设置Eden区和Survivor区空间比值，Survivor0区和Survivor1区大小相等\n-Xmn100m参数可用用来设置新生空间大小\n对象分配的一般过程 对象最先被创建在Eden区，如果Eden区被放满，程序还需要创建对象时，JVM的垃圾回收器（Minor GC）会对Eden去进行垃圾回收，将Eden区不再被引用的对象销毁，再创建新的对象，此时Eden区中没有被垃圾回收器回收的幸存对象会被晋升到幸存者0区并且对象有一个年龄标识，当垃圾回收器再次被触发时，如果幸存者0区的对象还是没有被回收，那么会放到幸存者1区，并且年龄标志增加，如果下次垃圾回收器触发时，幸存者1区的对象还没有被回收，那么会放置在幸存者0区，年龄标志增加，依次循环往复，当达到一定的次数后，对象被放置在老年区（默认15可以设置）-XX:MaxTenuringThreshold=15\n如果对象在Eden区放不下，并且在Survivor去也放不下，是有可能在老年区先通过Major GC后如果放的下的话直接放入老年区。\n如果创建对象Eden区已满，Survivor区也满，有可能Survivor区对象没有达到晋升年龄就晋升到老年区。\nSurvivor区满并不会触发GC，只有Eden区满才会触发GC，如果Survivor区也满，会顺便回收。\n方法区 方法区主要存储已被加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。\n方法区是线程共享的。\n方法区的大小决定了系统可以存放多少类，如果系统定义了太多的类（加载大量的jar包、tomcat部署war包过多），会导致方法区溢出。\n在关闭JVM时会释放方法区的内存。\n在jdk1.7及以前，把方法区称为永久代（PermGen）。jdk1.8开始，使用元空间（MetaSpace）取代永久代。\n堆和方法区示意图：\n元空间和永久代的本质类似，都是对JVM规范中方法区的实现。不过元空间和永久代的区别在于：元空间不在虚拟机中设置内存，而是使用本地内存。\n对于永久代方式实现方法区的，可以通过-XX:PermSize=20.75m来设置初始的永久代大小，默认值为20.72M，对于最大永久代大小，可以通过-XX:MaxPermSize=82m来设置，32位机器默认64M，64位机器默认82M\n对于元空间方法实现方法区的，可以通过-XX:MetaspaceSize=21m设置初始大小，默认为21M，通过-XX:MaxMetaspaceSize=-1设置最大元空间大小，默认为-1，即没有限制\n通过-XX:MetaspaceSize=21m设置的值被称为高水平线，一旦触及了这个水平线，那么就会触发Full GC来回收没用的类，然后调整这个水平线，可能是增加也可能是减少，这取决于Full GC释放了多少空间，如果是提高，最大值也不能超过-XX:MaxMetaspace=-1设置的这个值，如果这个高水平线设置得过低，那么水平线就会调整多次，会频繁触发Full GC，为了避免频繁的GC，建议将这个高水平值设置为一个较大的值。\n方法区的演变 jdk1.6及以前 有永久代，类型信息、域信息、方法信息、运行时常量池、静态变量都存放在永久代上 jdk1.7 有永久代，但是运行时常量池中的字符串常量池、静态变量被移动到堆中 jdk1.8及以后 无永久代，类型信息、常量、域信息、方法信息存放在本地内存的元空间，字符串常量池和静态变量任然存放在堆上 直接内存 直接内存不是JVM虚拟机运行时数据区的一部分，它是在java堆外直接向系统申请的内存区间，通常它的读写性能会比java堆高。\n可以通过-XX:MaxDirectMemorySize=10m设置最大直接内存大小\n栈、堆、方法区之间的交互关系 Person p=new Person(); ↑ ↑ ↑ 方法区 栈 堆 方法区的垃圾回收 主要回收的内容：常量池中废弃的常量和不再使用的类\n对象实例化 步骤：\n判断类是否已经加载、连接、初始化，如果没有加载，那么先进行加载 为对象分配空间 处理并发安全问题（采用CAS或TLAB） 初始化分配空间，为对象的属性赋默认值 设置对象头 执行init方法进行初始化 对象在堆中的内存布局 推中对象主要包含三部分：\n对象头，有包含两部分，运行时元数据和类型指针，运行元时数据包括哈希值、GC分代年龄、锁标志，类型指针用于指向方法区中对象的类 实例数据，类的实例数据和父类的实例数据，先存放父类的属性然后存放当前类 对齐填充，不是必须的，起到填充的作用 对象访问方法 句柄访问 优点：由于实例数据是存储在实例池中，当在GC时需要移动对象位置时，不需要移动实例数据\n缺点：需要多使用空间来保存实例数据指针\n直接指针(HotSpot使用) 优点：实例数据直接和对象存储在一起，相较于句柄访问方式，节约空间\n缺点：当触发GC需要移动对象时，实例数据页需要一起移动，相较于句柄访问性能略差\n执行引擎 执行引擎的任务就是讲字节码指令解释/编译为对应平台的本地机器指令。\n执行引擎包括解释器和JIT编译器。\n解释器：将字节码文件解释为机器码并执行。采用解释器的执行硬引擎的优点是响应时间快，适合用于客户端。\nJIT编译器：将字节码文件生成机器码指令，并缓存，当下次再次执行代码时，直接指向字节码，不需要再将字节码解释为机器码的过程。JIT对于经常执行的代码效率很好，适合服务器端执行引擎，确定是首次启动是时间长。\nHotSpot的执行引擎采用解释器和JIT编译器并存的架构，原因在于解释器在执行字节码，由于不需要缓存机器码，所以响应快，它的缺点是每次执行时都需要将字节码解释为机器码，对于经常执行的代码，性能不好，所以引入了JIT编译器，这样用于经常执行代码的优化。\n垃圾回收算法 标记阶段 目的：判断对象是否存活\n一个对象不被任何一个对象引用时，会被标记死亡，只有被标记为已经死亡的对象，GC才会执行垃圾回收，释放其所占的内存空间\n引用计数算法 每个对象保存一个整型的引用计数器，用于记录对象被引用的情况。\n对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器-1.对象A的引用计数器为0，即表示A没有任何对象引用A，可以进行回收。\n优点：\n​\t简单\n​\t高效\n缺点：\n​\t需要使用单独的字段存储计数器，增加了存储空间的开销\n​\t每次赋值都要更新程序计数器，增加了时间开销\n​\t无法处理循环引用问题，由于这一条缺陷，导致java在垃圾回收器中没有使用这个算法（主要）\n可达性分析算法(根搜索算法) 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索根对象集合所连接的目标对象是否可达。\n使用可达性分析算法后 ，内存中的存活对象都会被根对象集合直接或间接连接着，搜索锁走过的路径称为引用链。\n如果目标对象没有任何的引用链，那么对象是不可达的，就意味着对象已经死亡，会被标记为垃圾对象。\n在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活的对象。\nGC Root包含的元素：\n虚拟机栈中引用的对象：方法的参数、局部变量 本地方法栈内引用的对象 方法区中类的静态数据：类的引用型静态变量 方法区中的常量引用对象：字符串常量池里的引用 所有被synchronize持有的对象 java虚拟机内部引用：基本数据类型对应的Class对象、异常对象、系统类加载器 清除阶段 目标：清除已经被标记为垃圾的对象\n标记-清除算法（Mark—Sweep） 执行过程：\n​\t当堆中有效空间要被耗尽时，会停止整个程序（STW）,然后进行两项工作，第一项是标记，第二项是清除。\n​\t标记：垃圾收集器（GC）从根节点（GC Roots）开始遍历，标记所有被引用的对象。\n​\t清除：垃圾收集器（GC）对堆内存从头到尾进行线性遍历，如果某个对象没有被标记，则将其回收。\n注意：标记阶段标记的是有被其他对象引用的对象\n优点：\n​ 缺点：\n效率不高 在进行垃圾清理（GC）的时候需要停止整个应用程序 这种方式清理出来的内存不是连续的，会产生碎片，需要维护一个空闲列表。 复制算法（Copying） 执行过程：\n​\t将内存块分成两块，每次只使用其中一块，在进行垃圾回收时，将正使用的内存块中活着的对象复制到未被使用的内存块中，之后清除正在使用内存块中的所有对象，交换两内存块的角色，完成垃圾回收。\n优点：\n没有标记和清除的过程，更加高效 复制过去以后保证了空间的连续性，不会出现碎片 缺点：\n需要两倍的内存空间 保证对象复制前后的对象引用关系，开销不小 注意：如果系统的垃圾很多，那么需要移动的对象相对较少，复制算法才更加高效\n标记-压缩算法（Mark-Compact） 背景：\n​\t标记-清除算法的确可以应用到老年代中，但是该算法不仅效率低下而且会产生碎片问题，设计者在标记-清除算法的基础上进行改进，产生了标记-压缩算法。\n执行过程：\n​\t1.标记所有被引用的对象\n​\t2.将所有存活的对象压缩存放在内存的一端，顺序排放\n​\t3.清除边界外所有对象\n优点：\n清除了标记-清除算法中内存分散的问题，当创建对象的时候JVM只需要修改一个指针 消除了复制算法中内存减半的高额代价 缺点：\n从效率上来说，标记整理算法效率要低于标记-清除算法和复制算法。 移动对象时，如果该对象被其他对象引用，要调整引用地址。 需要暂停程序的时间更长 三种清除算法比较 Mark-Sweep Mark-Compact Copying 速度 中等 最慢 最快 空间开销 少 少 2倍活对象空间 移动对象 否 是 是 为了兼顾所有指标，标记-压缩算法相对来说更加好一些，但是它的效率比较差，比复制算法多个一个标记阶段，比标记-清除算法多个一个内存整理阶段。\n增量收集算法 背景：\n​\t标记-清除算法、复制算法、标记-压缩算法在垃圾回收过程中，应用软甲将处于一种Stop the World的状态。在这种状态下所有的线程都会挂起，暂停一切正常工作，等待垃圾回收的完成。如果垃圾回收的时间过长，应用程序会被挂起很久，将严重影响用户体验和系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究导致了增量收集算法的诞生。\n基本思想：\n​\t如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一片小的内存空间，接着切换到用户线程。反复依次，直到垃圾收集完成。\n缺点：\n​\t使用这种方式，由于在垃圾回收过程中，间断性地执行应用程序线程，所以能减少系统的停顿时间。但是，因为线程切换和上下文切换的消耗，会使垃圾回收的总体成本上升，造成系统的吞吐量下降。\n并发和并行 并发：在一段时间里，多个程序在一个cpu上快速切换地运行，看似所有程序同时在执行。\n并行：当系统有一个以上cpu时，一个cpu（cpu具有多核，也可能是一个核心）执行一个进程，另一个cpu执行另外一个进程，两个进程不互相抢占资源，称为并行。\n安全点和安全区域 程序在执行的时候，并非在所有的位置都能停下来，只有在特定的位置才能停下来GC，这些位置就是“安全点”。\n安全点很重要，如果太少可能导致GC等待时间太长，如果太多会导致运行时性能，通常选择一些执行时间比较长的点设置安全点。\n安全点机制保证了程序执行时，在不太长的时间内就可能遇到可进入GC的安全点。但是程序如果不执行，如：线程的sleep和blocked，这是线程无法响应JVM的中断请求，运行到安全点，JVM也不可能把线程唤醒，对于这种情况就需要安全区域。\n安全区域是指一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置执行GC都是安全的。\n引用 在jdk1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用。虚引用四种，这四种引用的强度依次减弱。\n强引用：在程序代码中普遍存在的引用赋值，如：Object obj=new Object（）；这种引用关系。无论在什么情况下，垃圾回收器永远不会回收掉这种引用。 软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围进行二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出。 弱引用：被弱引用关联的对象只能生存到下一次垃圾回收之前，当进行垃圾回收时，不管内存空间是否足够，都会回收掉被弱引用关联的对象。 虚引用：为一个对象设置虚引用的唯一目的就是能在对象被回收时收到一个系统通知。 强引用 在java程序中，强引用时最常见的引用类型，也是默认的引用类型。\n强引用的对象是可触及的，垃圾回收器就永远不会回收掉被引用的对象。\n特点：\n​\t可以访问目标对象。\n​\t强引用指向的对象任何时候都不会被回收。\n​\t强引用可能导致内存泄漏。\n软引用 软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前把这些对象列入回收范围进行二次回收，如果这是内存还不够，才抛出内存溢出。\n在内存足够时，不会回收可触及的软引用对象，内存不够内，才回收软引用对象。\npublic static void main(String[] args) { User u=new User(\"zhangsan\", 20); SoftReference\u003cUser\u003e softReference=new SoftReference\u003cUser\u003e(u); //把强引用消除 u=null; System.out.println(softReference.get()); try { byte[] bytes=new byte[7*1024*1024]; }catch(Exception e) { e.printStackTrace(); }finally { System.out.println(softReference.get()); } } 在没有设置堆内存的情况下，输出： User [name=zhangsan, age=20] User [name=zhangsan, age=20] 由于堆内存足够，那么软引用对象不会被回收 设置参数：-Xms10m -Xmx10m 输出： User [name=zhangsan, age=20] null 说明在堆内存不够的情况下，软引用的对象是会被 弱引用 只被弱引用关联的对象只能存活到下一次垃圾收集为止。\npublic static void main(String[] args) throws InterruptedException { User u=new User(\"zhangsan\", 20); WeakReference\u003cUser\u003e weakReference=new WeakReference\u003cUser\u003e(u); //把强引用清除 u=null; System.out.println(weakReference.get()); //模拟一次GC System.gc(); Thread.sleep(3*1000); System.out.println(weakReference.get()); } 在堆内存足够的情况下，输出： User [name=zhangsan, age=20] null 说明弱引用关联的对象只能存活到下一次GC 虚引用 一个对象是否有虚引用完全不会决定对象的生命周期。如果一个对象只有虚引用，和没有引用一样。\n为一个对象设置虚引用的唯一作用是追踪对象的回收时间。\n虚引用创建是必须提供一个引用队列作为参数，当垃圾回收器准备回收对象时，如果发现是虚引用，就会在回收对象后把虚引用加入引用队列，以通知应用程序对象的回收情况。\npublic class Test4 { private static ReferenceQueue\u003cUser\u003e queue=null; private static class CheckReferenceQueue extends Thread{ public void run() { while(true) { if(queue!=null) { Reference\u003c? extends User\u003e remove=null; try { remove = queue.remove(); } catch (InterruptedException e) { e.printStackTrace(); } if(remove!=null) { System.out.println(\"接收到通知\"); } } } }; } public static void main(String[] args) throws InterruptedException { queue=new ReferenceQueue\u003c\u003e(); Thread t=new CheckReferenceQueue(); t.setDaemon(true); t.start(); User u=new User(\"zhangsan\",20); PhantomReference\u003cUser\u003e phantomReference=new PhantomReference\u003cUser\u003e(u, queue); //清除强引用 u=null; System.out.println(phantomReference.get()); System.gc(); Thread.sleep(3*1000); System.out.println(phantomReference.get()); } } 输出： null 接收到通知 null 垃圾回收器 垃圾回收器分类 串行回收器：Serial、Serial Old 并行回收器：ParNew、Parallel Scavenge、Parallel Old 并发回收器：CMS、G1 垃圾收集器与分代之间的关系 垃圾回收器组合关系 查看默认垃圾回收器 使用-XX:+PrintCommandLineFlags参数或jinfo -flag 参数 线程 可以查看JVM中使用的垃圾回收器情况\njdk1.8中使用的是Parallel GC和Parallel Old GC\njdk1.9中只使用了G1垃圾收集器\nSerial收集器 serial收集器采用复制算法、串行回收和“Stop The World”机制的方式执行内存回收。\nSerial Old收集器 serial old收集器同样采用串行回收和“Stop The World”机制，不过内存回收算法使用的是标记-压缩算法。\nSerial Old是运行在Client模式下默认的老年代垃圾收集器 Serial Old在Server模式下主要有两个用途：①与新生代Parallel Scavenge配合使用。②作为老年代CMS收集器的后备垃圾收集器 在HotSpot虚拟机中，可以使用-XX：+UseSerialGC指定新生代使用Serial GC、老年代使用Serial Old GC。\nParNew收集器 如果说serial gc是新生代的单线程垃圾收集器，那么parnew收集器就是serial gc的多线程版本。\nPar是Parallel的简写，New是说该收集器只能处理新生代\nParNew收集器除了采用并行回收方式外，与Serial GC之间几乎没有区别，ParNew G同样是使用复制算法和“Stop The World”机制。\n对于新生代，回收次数频繁，使用多线程并行方式更高效。 对于老年代，回收次数少，使用串行方式更加节省资源。 可以使用-XX:+UseParNewGC手动指定新生代使用ParNew收集器进行内存回收\n使用-XX:ParallelGCThreads参数限制线程数量，默认和CPU相同的线程数\nParallel Scavenge收集器 Parallel Scavenge收集器是新生代垃圾收集器\nParallel Scavenge收集器基于多线程，采用复制算法、并行回收和“Stop The World”机制。\n可以使用-XX：+UseParallelGC指定新生代使用Parallel GC，老年代使用Parallel old收集器\n使用-XX:ParallelGCThreads参数限制线程数量，默认和CPU相同的线程数\nParallel Old收集器 Parallel Old收集器是老年代垃圾收集器\nParallel Old收集器也是基于多线程的，配合Parallel收集器使用，它采用标记-压缩算法和“Stop The World”机制。\n使用参数-XX:+UseParallelOldGC指定老年代使用Parallel Old收集器,新生代使用Parallel收集器\nCMS收集器 CMS(Concurrent-Mark-Sweep)收集器是HotSpot虚拟机中第一款真正意义上 的并发收集器，它第一次实现垃圾收集线程与用户线程同时工作。\nCMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短，就越适合与用户交互的程序。\nCMS收集器采用标记-清除算法。\n初始标记阶段：在这个阶段，程序中所有的工作线程都会“Stop The World”，这个阶段的任务仅仅是标记处GC Roots能够直接关联的对象。 并发标记阶段：从GC Root的直接关联对象开始遍历整个对象图，这个过程用时较长，但是不需要停止用户线程。 重新标记阶段：在并发标记阶段中，程序的工作线程和垃圾收集线程同时运行，这个阶段时为了修正并发标记阶段，因为程序继续运行而导致的标记变动，这个阶段和初始标记一样也会“Stop The World”，这个阶段的停顿时间通常比初始标记阶段稍长，但是比并发标记阶段短。 并发清理阶段：此阶段的任务是清除掉标记阶段判断依据死亡的对象，释放内存空间。由于不需要移动对象，所以这个阶段是可以与程序工作线程同时进行的。 由于垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，应当确保应用程序线程有足够的内存可用。CMS收集器不能像其他收集器内存几乎填满才进行回收，它必须在内存达到一个阈值就开始执行垃圾收集。\n缺点：\nCMS收集器采用的标记-清除算法所以会产生内存碎片，可能在并发清除后，无法为大对象分配空间，从而触发Full GC\nCMS由于是并发的收集器，由于垃圾收集的时候垃圾收集线程和用户线程同时执行，减少了系统的并发吞吐量\nCMS收集器无法处理浮动垃圾。在并发标记阶段，用于垃圾收集线程和用户线程是同时执行的，那么在并发标记阶段产生的新垃圾对象，CMS无法对这些垃圾进行标记，最终会导致这些垃圾没有及时被回收。\n使用：\n可以使用-XX:+UseConcMarkSweepGC来开启老年代用时CMS垃圾收集器，如果设置这个参数，那么年轻代默认使用ParNew垃圾收集器\nG1收集器 G1收集器的目标是在可控的暂停时间内，尽可能的提高吞吐量。\nG1垃圾收集器针对新生代使用的是复制算法，老年代使用的是标记-压缩算法。\nG1收集器是一个并行回收器，它把堆内存划分为一个个region，这个region在物理上是不连续的，使用不同的region来表示Eden、Survivor 0、Survivor 1和 Tenured，G1收集器把堆内存划分为region避免了在堆中进行全区域垃圾收集，G1跟踪各个region里面垃圾堆积的大小，维护一个优先列表，每次根据允许的收集时间，优先收集回收价值最大的region。\nG1收集器是一款面向服务端的垃圾收集器，主要针对配备多核cpu及大容量内存的机器，在允许的延迟范围内，兼具高吞吐量的特性。\nG1收集器在jdk1.7正式启用，在jdk1.9成为默认垃圾收集器，取代了CMS收集器和Parallel+Parallel Old的组合。\n使用：\n可以使用-XX:+UseG1GC来开启使用G1收集器\nG1收集器回收过程：\n年轻代 老年代并发标记过程 混合回收 当年轻代的Eden区用尽时开始年轻代的回收：G1的年轻代收集阶段是一个并行的独占式收集器，在这个阶段会停止所有的引用程序线程，启动多线程进行回收，然后将存活对象移动到Survivor去或Tenured或Survivor、Tenured。\n当堆内存使用到了45%，就开始老年代的并发标记过程。标记完成马上开始混合回收，和其他收集器不同的是，G1收集器的老年代回收不需要回收所以老年代，而只需要回收一部分老年代region，然后把存活的对象移动到空闲区域，这个区域也就成为另一个老年代的region\nRemembered Set\n问题：\n一个region不可能是谷孤立的，一个region中的对象可能被其他任意的region中的对象引用，判断对象是否存活，是否要遍历整个堆呢？\n解决：\n无论是G1收集器还是其他收集器，JVM都使用Remembered Set来避免全表扫描。在G1收集器中，每一个region都有一个对应的Remembered Set，每次Reference类型数据写操作时，会产生一个Write Barrier暂时中断操作，检查将要写入的引用对象是否和该Reference类型数据在不同的region，如果不在，通过CardTable把相关的引用记录添加到引用对象所在region的Remembered Set中。当进行垃圾收集时，在GC根节点的枚举范围加入Remember Set，这样就可以保证不进行全局扫描，也不会有遗漏。\n几种收集器的比较 导出GC日志 使用-Xloggc:./logs/gc.log来把GC日志保存到外部文件\n","wordCount":"804","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://moyuduo.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://moyuduo.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JVM学习笔记</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#jvm结构>JVM结构</a></li><li><a href=#java虚拟机终止的情况>Java虚拟机终止的情况</a></li><li><a href=#java类的加载连接初始化>Java类的加载、连接、初始化</a><ul><li><a href=#加载>加载</a></li><li><a href=#双亲委托机制的优点>双亲委托机制的优点</a></li><li><a href=#类加载器命名空间>类加载器命名空间</a></li><li><a href=#获取类加载器>获取类加载器</a></li><li><a href=#初始化>初始化</a></li><li><a href=#类初始化步骤>类初始化步骤</a></li></ul></li><li><a href=#实例化>实例化</a></li><li><a href=#回收>回收</a></li><li><a href=#卸载>卸载</a></li><li><a href=#内存划分>内存划分</a><ul><li><a href=#程序计数器>程序计数器</a></li><li><a href=#虚拟机栈java栈>虚拟机栈（java栈）</a></li><li><a href=#本地方法栈>本地方法栈</a></li><li><a href=#堆>堆</a></li><li><a href=#方法区>方法区</a></li><li><a href=#直接内存>直接内存</a></li><li><a href=#栈堆方法区之间的交互关系>栈、堆、方法区之间的交互关系</a></li><li><a href=#方法区的垃圾回收>方法区的垃圾回收</a></li></ul></li><li><a href=#对象实例化>对象实例化</a><ul><li><a href=#对象在堆中的内存布局>对象在堆中的内存布局</a></li><li><a href=#对象访问方法>对象访问方法</a></li></ul></li><li><a href=#执行引擎>执行引擎</a></li><li><a href=#垃圾回收算法>垃圾回收算法</a><ul><li><a href=#标记阶段>标记阶段</a></li><li><a href=#清除阶段>清除阶段</a></li><li><a href=#增量收集算法>增量收集算法</a></li><li><a href=#并发和并行>并发和并行</a></li><li><a href=#安全点和安全区域>安全点和安全区域</a></li><li><a href=#引用>引用</a></li></ul></li><li><a href=#垃圾回收器>垃圾回收器</a><ul><li><a href=#垃圾回收器分类>垃圾回收器分类</a></li><li><a href=#垃圾收集器与分代之间的关系>垃圾收集器与分代之间的关系</a></li><li><a href=#垃圾回收器组合关系>垃圾回收器组合关系</a></li><li><a href=#查看默认垃圾回收器>查看默认垃圾回收器</a></li><li><a href=#serial收集器>Serial收集器</a></li><li><a href=#serial--old收集器>Serial Old收集器</a></li><li><a href=#parnew收集器>ParNew收集器</a></li><li><a href=#parallel-scavenge收集器>Parallel Scavenge收集器</a></li><li><a href=#parallel-old收集器>Parallel Old收集器</a></li><li><a href=#cms收集器>CMS收集器</a></li><li><a href=#g1收集器>G1收集器</a></li><li><a href=#几种收集器的比较>几种收集器的比较</a></li><li><a href=#导出gc日志>导出GC日志</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=jvm学习笔记>JVM学习笔记<a hidden class=anchor aria-hidden=true href=#jvm学习笔记>#</a></h1><h2 id=jvm结构>JVM结构<a hidden class=anchor aria-hidden=true href=#jvm结构>#</a></h2><p><img loading=lazy src=images/Snipaste_2020-05-18_17-45-37.jpg alt></p><h2 id=java虚拟机终止的情况>Java虚拟机终止的情况<a hidden class=anchor aria-hidden=true href=#java虚拟机终止的情况>#</a></h2><ol><li>程序正常执行完成</li><li>程序显式调用System.exit()方法</li><li>程序中出现了异常或错误</li><li>操作系统底层出现了错误</li></ol><h2 id=java类的加载连接初始化>Java类的加载、连接、初始化<a hidden class=anchor aria-hidden=true href=#java类的加载连接初始化>#</a></h2><ol><li><p>加载：加载类的字节码文件到内存</p></li><li><p>连接</p><ul><li><p>验证：验证字节码文件的正确性</p><p>主要验证 1类文件结构</p><p>​ 2语义检查</p><p>​ 3字节码验证</p><p>​ 4二进制兼容性验证（老版本.class文件可以运行在新版本上）</p></li><li><p>准备：为<strong>类静态变量</strong>分配地址空间，并<strong>初始化为默认值</strong></p></li><li><p>解析：把变量的字符引用替换为直接引用</p></li></ul></li><li><p>初始化：为类的静态变量赋值</p></li></ol><p><img loading=lazy src=images/Snipaste_2020-05-18_17-46-59.jpg alt></p><h3 id=加载>加载<a hidden class=anchor aria-hidden=true href=#加载>#</a></h3><p>JVM允许使用某个类之间提前加载他们，如果遇到.class文件缺失等错误，并不会立即报错，只有当类被第一次主动使用时才抛出错误</p><p>加载器根据是否是用户自定义的可以分为</p><ol><li>系统自带类加载器<ul><li>启动类加载器（BootStrap）没有父加载器，使用c++实现，主要是用来加载JRE/lib/rt.jar中类</li><li>扩展类记载器（Ext）主要加载JRE/lib/ext/*.jar中的类</li><li>应用类加载器（App）主要加载类路径下用户自定义的类</li></ul></li><li>用户自定义加载器<ul><li>用于加载指定路径的.class文件</li></ul></li></ol><h4 id=类加载的双亲委托机制>类加载的双亲委托机制<a hidden class=anchor aria-hidden=true href=#类加载的双亲委托机制>#</a></h4><p>加载器在逻辑上形成一种树形结构</p><p><img loading=lazy src=images/Snipaste_2020-05-08_16-09-51.jpg alt></p><p><strong>加载器之间的父子关系实际上是加载器之间的包含关系，并不是继承关系</strong></p><h3 id=双亲委托机制的优点>双亲委托机制的优点<a hidden class=anchor aria-hidden=true href=#双亲委托机制的优点>#</a></h3><p>双亲委托机制的优点是能提高软件的安全性。在这种机制下，用户自定义的加载器不能加载应该由父加载器加载的可靠的类，从而防止了恶意代码代替父加载器的可靠代码。如：用户自定义的类加载器要去加载rt.jar下的类，根据双新委托模型，rt.jar下的类总是由启动类加载器进行加载，所有保证了jdk核心类库的绝对安全。</p><h3 id=类加载器命名空间>类加载器命名空间<a hidden class=anchor aria-hidden=true href=#类加载器命名空间>#</a></h3><p>同一个命名空间中的类是相互可见的。子加载器的命名空间包含所有父加载器命名空间，因此子加载器可以看见父加载器加载的类，父加载器不能看见子加载器加载的类。如果两个加载器之间没有父子关系，那么他们各自加载的类也是不可见的。</p><h4 id=当前类加载>当前类加载<a hidden class=anchor aria-hidden=true href=#当前类加载>#</a></h4><p>每个类都有自己的类加载器（即加载自身的类加载器）,并且使用这个类加载器去加载依赖的其他类：如果ClassX类依赖ClassY，那么会使用ClassX的类加载器去加载ClassY</p><h4 id=线程的类加载器>线程的类加载器<a hidden class=anchor aria-hidden=true href=#线程的类加载器>#</a></h4><p>每个线程也具有类加载器，可以通过setContextClassLoader方法区设置线程的类加载器，如果没有进行设置，那么会默认是父线程的类加载器，java初始化线程的类加载器是系统类加载器</p><h4 id=线程上下文加载器>线程上下文加载器<a hidden class=anchor aria-hidden=true href=#线程上下文加载器>#</a></h4><p>在jdk中定义了很多服务提供接口，如jdbc的Statement接口，具体的实现是有数据库厂商完成的，根据双亲委托模型Statement接口是使用启动类加载器进行加载的，而第三方数据库driver是在类路径下的，启动类加载器无法进行加载，这种情况下双亲委托模型就出现了问题，通过设置线程的上下文加载器，父ClassLoader可以使用当前线程的ClassLoader去加载类，这就改变了双亲委托模型中父加载器不能加载子加载器加载的类的局面</p><p>当高层提供了统一的接口让底层去实现，同时又需要在高层加载（或实例化）底层类时，就需要通过线程上下文类加载器来帮助高层的类加载器加载该类</p><h3 id=获取类加载器>获取类加载器<a hidden class=anchor aria-hidden=true href=#获取类加载器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//获取当前类的ClassLoader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>clazz</span><span class=o>.</span><span class=na>getClassLoader</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//获取当前线程的ClassLoader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getContextClassLoader</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//获取系统ClassLoader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ClassLoader</span><span class=o>.</span><span class=na>getSystemClassLoader</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//获取调用者的ClassLoader
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DriverManager</span><span class=o>.</span><span class=na>getCallerClassLoader</span><span class=o>();</span>
</span></span></code></pre></div><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><p>Java虚拟机在类或接口“首次主动使用”的时候<strong>初始化</strong></p><p>主动使用：1. 创建类的实例</p><p>​ 2.访问类或接口的静态变量</p><p>​ 3.调用类的静态方法</p><p>​ 4.反射，Class.forName(&ldquo;xxx&rdquo;);</p><p>​ 5.初始化一个类的子类</p><p>​ 6.启动类(包含main方法的类)</p><p>​ 7.java.lang.invoke.MethodHandle实例解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test1</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Child</span><span class=o>.</span><span class=na>str1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Parent</span><span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=n>str1</span><span class=o>=</span><span class=s>&#34;hello&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Parent Static Block&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Child</span> <span class=kd>extends</span> <span class=n>Parent</span><span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>String</span> <span class=n>str2</span><span class=o>=</span><span class=s>&#34;world&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Child Static Block&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=n>Parent</span> <span class=n>Static</span> <span class=n>Block</span>
</span></span><span class=line><span class=cl><span class=n>hello</span>
</span></span></code></pre></div><p>调用Child.str1并没用输出Child的静态代码块，可以得出这样一个结论，<strong>对应静态变量，只会去初始化定义该变量的类</strong>，即只主动使用了Parent类</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test2</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Parent2</span><span class=o>.</span><span class=na>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Parent2</span><span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>str</span><span class=o>=</span><span class=s>&#34;hello&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;parent2 static block&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=n>hello</span>
</span></span></code></pre></div><p>在一个类中使用另一个类static final修饰的变量时，会把该变量推送至调用这个变量方法的类的常量池中，而不会去初始化这个类，并且是<strong>在编译期进行的</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test3</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Parent3</span><span class=o>.</span><span class=na>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Parent3</span><span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>str</span><span class=o>=</span><span class=n>UUID</span><span class=o>.</span><span class=na>randomUUID</span><span class=o>().</span><span class=na>toString</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;parent3 static block&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=n>parent3</span> <span class=kd>static</span> <span class=n>block</span>
</span></span><span class=line><span class=cl><span class=n>f7e58be0</span><span class=o>-</span><span class=mf>7e43</span><span class=o>-</span><span class=mi>4</span><span class=n>a3a</span><span class=o>-</span><span class=mi>870</span><span class=n>f</span><span class=o>-</span><span class=mi>90</span><span class=n>e8fdbe8b48</span>
</span></span></code></pre></div><p>对于static final修饰的变量在编译时不是常量的情况，会导致该类的初始化，所以static代码块会执行</p><p><strong>理解准备阶段和初始化阶段</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test4</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Singleton</span> <span class=n>instance</span> <span class=o>=</span> <span class=n>Singleton</span><span class=o>.</span><span class=na>getInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;a:&#34;</span><span class=o>+</span><span class=n>instance</span><span class=o>.</span><span class=na>a</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;b:&#34;</span><span class=o>+</span><span class=n>instance</span><span class=o>.</span><span class=na>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Singleton</span><span class=o>{</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>instance</span><span class=o>=</span><span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>a</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>		<span class=n>b</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>instance</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>a:</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>b:</span><span class=mi>0</span>
</span></span></code></pre></div><p>Singleton.getInstance();会导致对Singleton类的首次主动使用，那么就会去初始化Singleton类，在初始化之前，已经完成了<strong>连接阶段</strong>中的<strong>准备阶段</strong>，所以此时a为默认值0，instance为默认值null，b为默认值0，进行初始化阶段时是顺序执行的，首先执行<code>public static int a;</code>语句，并没有赋值，接着执行<code>private static Singleton instance=new Singleton();</code>语句，此时调用构造方法对a++，b++，所以输出1和1，在执行<code>public static int b=0;</code>语句，此时有赋值，那么把b的值赋值为了0，所以拿到的instance的a为1，b为0</p><h3 id=类初始化步骤>类初始化步骤<a hidden class=anchor aria-hidden=true href=#类初始化步骤>#</a></h3><ol><li>如果这个类还没有被加载和连接，那么进行加载和连接</li><li>如果类存在直接父类，并且这个类还没有被初始化，那么先初始化父类，在初始化自己</li><li><strong>依次顺序执行</strong>类中的初始化语句</li></ol><ul><li>类在进行初始化时，要求它的所有父类都已经初始化</li><li>类初始化时，并不要求它所实现的所有接口都初始化，只有当使用到接口才初始化</li><li>初始化接口时，并不要求初始化它的父接口</li></ul><h2 id=实例化>实例化<a hidden class=anchor aria-hidden=true href=#实例化>#</a></h2><ul><li>为对象分配空间</li><li>为成员变量赋默认值</li><li>为成员变量赋正确的初始值</li><li>如果没有构造方法，那么生成默认初始化方法</li></ul><h2 id=回收>回收<a hidden class=anchor aria-hidden=true href=#回收>#</a></h2><h2 id=卸载>卸载<a hidden class=anchor aria-hidden=true href=#卸载>#</a></h2><p>当类被加载、连接、初始化之后它的生命周期就开始了。当类的Class对象不再被引用，即不可触及，那么Class对象就会结束生命周期，类在方法区的数据（类的静态变量）也会被卸载。</p><p>由java虚拟机自带的类加载器加载的类，在虚拟机的生命周期中，始终不会被卸载。这是因为java虚拟机会引用这些类加载器，这些类加载器会始终引用他们所加载的类，因此这些Class对象始终不会被卸载。</p><p>由用户自定义加载器加载的类是可以被卸载的。</p><h2 id=内存划分>内存划分<a hidden class=anchor aria-hidden=true href=#内存划分>#</a></h2><p><img loading=lazy src=images/Snipaste_2020-05-19_16-20-17.jpg alt></p><h3 id=程序计数器>程序计数器<a hidden class=anchor aria-hidden=true href=#程序计数器>#</a></h3><p><strong>程序计数器是线程私有的</strong>。</p><p>存储指向下一条指令的地址。即要执行的代码。</p><p><img loading=lazy src=images/Snipaste_2020-05-27_17-35-32.jpg alt></p><h3 id=虚拟机栈java栈>虚拟机栈（java栈）<a hidden class=anchor aria-hidden=true href=#虚拟机栈java栈>#</a></h3><p><strong>虚拟机栈是线程私有空间</strong>。</p><p>虚拟机栈中没有GC。因为方法执行就入栈，执行完了就出栈了。</p><p>栈是运行的单位，而堆是存储的单位。</p><p>栈内保存了一个个栈帧，一个栈帧对应一个java方法</p><p>可以通过**-Xss**256k参数来设置栈的大小</p><p>栈帧的内部结构：</p><ul><li><p>局部变量表</p><p>被定义为一个数字数组，主要存储方法的参数和在方法体中定义的局部变量，这些参数的类型包括基本数据类型、对象引用、returnAddress类型。由于局部变量表示在线程私有的栈空间中，所以不存在数据安全问题。局部变量表的大小在编译器就被确定下来，在方法运行期不会改变。如果是非静态方法，那么局部变量表的0号位置放置的是this。相较于类变量，局部变量并不会赋默认值，所以在使用之间应该显式赋值。</p><p>局部变量表中的变量是垃圾回收的根节点，只要被局部变量表中变量直接或间接引用的对象都不会被回收。</p></li><li><p>操作数栈</p><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间，操作数栈是JVM执行引擎的一个工作空间，当一个方法执行的时候，一个新的栈帧会被创建出来，这个方法的操作数栈是空的，没一个操作数栈的栈深度是确定的，在编译期就被确定下来。</p></li><li><p>动态链接</p><p>每一个栈帧内都包含一个指向该栈帧所属方法的引用，这个引用的目的是使当前方法的代码能够实现动态链接。动态链接就是指向方法区中对应方法的一个引用，有了这个引用就不需要再每个栈帧中存放方法的具体信息。</p></li><li><p>方法返回地址</p><p>方法返回地址记录的是调用者程序计数器的值，即调用方法的指令的下一条指令的地址</p></li><li><p>一些附加信息</p><p>可能存在一些附加信息，如程序调试附加信息</p></li></ul><h3 id=本地方法栈>本地方法栈<a hidden class=anchor aria-hidden=true href=#本地方法栈>#</a></h3><p>主要用于处理java中调用c或C++实现的本地方法。</p><p>本地方法栈也没有GC。</p><p>HotSpot虚拟机把本地方法栈和java虚拟机栈合二为一。</p><h3 id=堆>堆<a hidden class=anchor aria-hidden=true href=#堆>#</a></h3><p><strong>堆内存是所有线程共享的</strong>。</p><p>堆空间在物理内存上可能是连续的也可能是不连续的。</p><p>通过**-Xms**5m参数指定堆空间初始5m</p><p>通过**-Xmx**5m参数指定堆空间最大5m</p><p>通过-XX:+HeapDumpOnOutOfMemoryError参数指定堆上发生内存溢出输入日志</p><p>通过-XX:+PrintGCDetails参数打印GC回收信息</p><p><strong>jdk1.8之后堆内存在逻辑上分为三部分：新生代+老年代+元空间</strong></p><p>-XX:NewRatio=2参数用来设置老年代和新生代的空间比值，默认为2，即老年代空间/新生代空间=2</p><p>在HotSpot中Eden区和Survivor0和Survivor1空间的比列是8:1:1</p><p>-XX:SurvivorRatio=8参数可用于设置Eden区和Survivor区空间比值，Survivor0区和Survivor1区大小相等</p><p><strong>-Xmn100m</strong>参数可用用来设置新生空间大小</p><h4 id=对象分配的一般过程>对象分配的一般过程<a hidden class=anchor aria-hidden=true href=#对象分配的一般过程>#</a></h4><p><img loading=lazy src=images/Snipaste_2020-05-20_14-40-06.jpg alt></p><p>对象最先被创建在Eden区，如果Eden区被放满，程序还需要创建对象时，JVM的垃圾回收器（Minor GC）会对Eden去进行垃圾回收，将Eden区不再被引用的对象销毁，再创建新的对象，此时Eden区中没有被垃圾回收器回收的幸存对象会被晋升到幸存者0区并且对象有一个年龄标识，当垃圾回收器再次被触发时，如果幸存者0区的对象还是没有被回收，那么会放到幸存者1区，并且年龄标志增加，如果下次垃圾回收器触发时，幸存者1区的对象还没有被回收，那么会放置在幸存者0区，年龄标志增加，依次循环往复，当达到一定的次数后，对象被放置在老年区（默认15可以设置）-XX:MaxTenuringThreshold=15</p><p>如果对象在Eden区放不下，并且在Survivor去也放不下，是有可能在老年区先通过Major GC后如果放的下的话直接放入老年区。</p><p>如果创建对象Eden区已满，Survivor区也满，有可能Survivor区对象没有达到晋升年龄就晋升到老年区。</p><p>Survivor区满并不会触发GC，只有Eden区满才会触发GC，如果Survivor区也满，会顺便回收。</p><h3 id=方法区>方法区<a hidden class=anchor aria-hidden=true href=#方法区>#</a></h3><p>方法区主要存储已被加载的<strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等。</p><p><strong>方法区是线程共享的</strong>。</p><p>方法区的大小决定了系统可以存放多少类，如果系统定义了太多的类（加载大量的jar包、tomcat部署war包过多），会导致方法区溢出。</p><p>在关闭JVM时会释放方法区的内存。</p><p>在jdk1.7及以前，把方法区称为永久代（PermGen）。jdk1.8开始，使用元空间（MetaSpace）取代永久代。</p><p>堆和方法区示意图：</p><p><img loading=lazy src=images/Snipaste_2020-05-21_15-10-01.jpg alt></p><p>元空间和永久代的本质类似，都是对JVM规范中方法区的实现。不过元空间和永久代的区别在于：元空间不在虚拟机中设置内存，而是使用本地内存。</p><p><strong>对于永久代方式实现方法区</strong>的，可以通过<code>-XX:PermSize=20.75m</code>来设置初始的永久代大小，默认值为20.72M，对于最大永久代大小，可以通过<code>-XX:MaxPermSize=82m</code>来设置，32位机器默认64M，64位机器默认82M</p><p><strong>对于元空间方法实现方法区</strong>的，可以通过<code>-XX:MetaspaceSize=21m</code>设置初始大小，默认为21M，通过<code>-XX:MaxMetaspaceSize=-1</code>设置最大元空间大小，默认为-1，即没有限制</p><p>通过<code>-XX:MetaspaceSize=21m</code>设置的值被称为高水平线，一旦触及了这个水平线，那么就会触发Full GC来回收没用的类，然后调整这个水平线，可能是增加也可能是减少，这取决于Full GC释放了多少空间，如果是提高，最大值也不能超过<code>-XX:MaxMetaspace=-1</code>设置的这个值，如果这个高水平线设置得过低，那么水平线就会调整多次，会频繁触发Full GC，为了避免频繁的GC，建议将这个高水平值设置为一个较大的值。</p><h4 id=方法区的演变>方法区的演变<a hidden class=anchor aria-hidden=true href=#方法区的演变>#</a></h4><table><thead><tr><th>jdk1.6及以前</th><th>有永久代，类型信息、域信息、方法信息、运行时常量池、静态变量都存放在永久代上</th></tr></thead><tbody><tr><td>jdk1.7</td><td>有永久代，但是运行时常量池中的字符串常量池、静态变量被移动到堆中</td></tr><tr><td>jdk1.8及以后</td><td>无永久代，类型信息、常量、域信息、方法信息存放在本地内存的元空间，字符串常量池和静态变量任然存放在堆上</td></tr></tbody></table><h3 id=直接内存>直接内存<a hidden class=anchor aria-hidden=true href=#直接内存>#</a></h3><p>直接内存不是JVM虚拟机运行时数据区的一部分，它是在java堆外直接向系统申请的内存区间，通常它的读写性能会比java堆高。</p><p>可以通过<code>-XX:MaxDirectMemorySize=10m</code>设置最大直接内存大小</p><h3 id=栈堆方法区之间的交互关系>栈、堆、方法区之间的交互关系<a hidden class=anchor aria-hidden=true href=#栈堆方法区之间的交互关系>#</a></h3><p><img loading=lazy src=images/Snipaste_2020-05-21_14-38-01.jpg alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-j data-lang=j><span class=line><span class=cl><span class=nv>Person</span> <span class=nv>p</span><span class=o>=</span><span class=nv>new</span> <span class=nv>Person</span><span class=p>()</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=err>↑</span>    <span class=err>↑</span>     <span class=err>↑</span>
</span></span><span class=line><span class=cl> <span class=err>方法区</span> <span class=err>栈</span>   <span class=err>堆</span>
</span></span></code></pre></div><h3 id=方法区的垃圾回收>方法区的垃圾回收<a hidden class=anchor aria-hidden=true href=#方法区的垃圾回收>#</a></h3><p><strong>主要回收的内容</strong>：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类</strong></p><h2 id=对象实例化>对象实例化<a hidden class=anchor aria-hidden=true href=#对象实例化>#</a></h2><p>步骤：</p><ol><li>判断类是否已经加载、连接、初始化，如果没有加载，那么先进行加载</li><li>为对象分配空间</li><li>处理并发安全问题（采用CAS或TLAB）</li><li>初始化分配空间，为对象的属性赋默认值</li><li>设置对象头</li><li>执行init方法进行初始化</li></ol><h3 id=对象在堆中的内存布局>对象在堆中的内存布局<a hidden class=anchor aria-hidden=true href=#对象在堆中的内存布局>#</a></h3><p>推中对象主要包含三部分：</p><ol><li>对象头，有包含两部分，运行时元数据和类型指针，运行元时数据包括哈希值、GC分代年龄、锁标志，类型指针用于指向方法区中对象的类</li><li>实例数据，类的实例数据和父类的实例数据，先存放父类的属性然后存放当前类</li><li>对齐填充，不是必须的，起到填充的作用</li></ol><h3 id=对象访问方法>对象访问方法<a hidden class=anchor aria-hidden=true href=#对象访问方法>#</a></h3><h4 id=句柄访问>句柄访问<a hidden class=anchor aria-hidden=true href=#句柄访问>#</a></h4><p><img loading=lazy src=images/Snipaste_2020-05-22_16-18-46.jpg alt></p><p>优点：由于实例数据是存储在实例池中，当在GC时需要移动对象位置时，不需要移动实例数据</p><p>缺点：需要多使用空间来保存实例数据指针</p><h4 id=直接指针hotspot使用>直接指针(HotSpot使用)<a hidden class=anchor aria-hidden=true href=#直接指针hotspot使用>#</a></h4><p><img loading=lazy src=images/Snipaste_2020-05-22_16-21-19.jpg alt></p><p>优点：实例数据直接和对象存储在一起，相较于句柄访问方式，节约空间</p><p>缺点：当触发GC需要移动对象时，实例数据页需要一起移动，相较于句柄访问性能略差</p><h2 id=执行引擎>执行引擎<a hidden class=anchor aria-hidden=true href=#执行引擎>#</a></h2><p>执行引擎的任务就是讲字节码指令解释/编译为对应平台的本地机器指令。</p><p>执行引擎包括<strong>解释器</strong>和<strong>JIT编译器</strong>。</p><p>解释器：将字节码文件解释为机器码并执行。采用解释器的执行硬引擎的优点是响应时间快，适合用于客户端。</p><p>JIT编译器：将字节码文件生成机器码指令，并缓存，当下次再次执行代码时，直接指向字节码，不需要再将字节码解释为机器码的过程。JIT对于经常执行的代码效率很好，适合服务器端执行引擎，确定是首次启动是时间长。</p><p><strong>HotSpot的执行引擎采用解释器和JIT编译器并存的架构</strong>，原因在于解释器在执行字节码，由于不需要缓存机器码，所以响应快，它的缺点是每次执行时都需要将字节码解释为机器码，对于经常执行的代码，性能不好，所以引入了JIT编译器，这样用于经常执行代码的优化。</p><h2 id=垃圾回收算法>垃圾回收算法<a hidden class=anchor aria-hidden=true href=#垃圾回收算法>#</a></h2><h3 id=标记阶段>标记阶段<a hidden class=anchor aria-hidden=true href=#标记阶段>#</a></h3><p>目的：判断对象是否存活</p><p>一个对象不被任何一个对象引用时，会被标记死亡，只有被标记为已经死亡的对象，GC才会执行垃圾回收，释放其所占的内存空间</p><h4 id=引用计数算法>引用计数算法<a hidden class=anchor aria-hidden=true href=#引用计数算法>#</a></h4><p>每个对象保存一个整型的引用计数器，用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器-1.对象A的引用计数器为0，即表示A没有任何对象引用A，可以进行回收。</p><p>优点：</p><p>​ 简单</p><p>​ 高效</p><p>缺点：</p><p>​ 需要使用单独的字段存储计数器，增加了存储空间的开销</p><p>​ 每次赋值都要更新程序计数器，增加了时间开销</p><p>​ <strong>无法处理循环引用问题，由于这一条缺陷，导致java在垃圾回收器中没有使用这个算法</strong>（主要）</p><p><img loading=lazy src=images/Snipaste_2020-06-01_15-52-53.jpg alt></p><h4 id=可达性分析算法根搜索算法>可达性分析算法(根搜索算法)<a hidden class=anchor aria-hidden=true href=#可达性分析算法根搜索算法>#</a></h4><p>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索根对象集合所连接的目标对象是否可达。</p><p>使用可达性分析算法后 ，内存中的存活对象都会被根对象集合直接或间接连接着，搜索锁走过的路径称为引用链。</p><p>如果目标对象没有任何的引用链，那么对象是不可达的，就意味着对象已经死亡，会被标记为垃圾对象。</p><p>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活的对象。</p><p><img loading=lazy src=images/Snipaste_2020-06-01_16-43-33.jpg alt></p><p><strong>GC Root包含的元素：</strong></p><ul><li>虚拟机栈中引用的对象：方法的参数、局部变量</li><li>本地方法栈内引用的对象</li><li>方法区中类的静态数据：类的引用型静态变量</li><li>方法区中的常量引用对象：字符串常量池里的引用</li><li>所有被synchronize持有的对象</li><li>java虚拟机内部引用：基本数据类型对应的Class对象、异常对象、系统类加载器</li></ul><h3 id=清除阶段>清除阶段<a hidden class=anchor aria-hidden=true href=#清除阶段>#</a></h3><p>目标：清除已经被标记为垃圾的对象</p><h4 id=标记-清除算法marksweep>标记-清除算法（Mark—Sweep）<a hidden class=anchor aria-hidden=true href=#标记-清除算法marksweep>#</a></h4><p>执行过程：</p><p>​ 当堆中有效空间要被耗尽时，会停止整个程序（STW）,然后进行两项工作，第一项是标记，第二项是清除。</p><p>​ 标记：垃圾收集器（GC）从根节点（GC Roots）开始遍历，标记所有被引用的对象。</p><p>​ 清除：垃圾收集器（GC）对堆内存从头到尾进行线性遍历，如果某个对象没有被标记，则将其回收。</p><p><strong>注意：标记阶段标记的是有被其他对象引用的对象</strong></p><p><img loading=lazy src=images/Snipaste_2020-06-03_15-36-17.jpg alt></p><p>优点：</p><ul><li>​</li></ul><p>缺点：</p><ul><li>效率不高</li><li>在进行垃圾清理（GC）的时候需要停止整个应用程序</li><li><strong>这种方式清理出来的内存不是连续的，会产生碎片，需要维护一个空闲列表。</strong></li></ul><h4 id=复制算法copying>复制算法（Copying）<a hidden class=anchor aria-hidden=true href=#复制算法copying>#</a></h4><p>执行过程：</p><p>​ 将内存块分成两块，每次只使用其中一块，在进行垃圾回收时，将正使用的内存块中活着的对象复制到未被使用的内存块中，之后清除正在使用内存块中的所有对象，交换两内存块的角色，完成垃圾回收。</p><p><img loading=lazy src=images/Snipaste_2020-06-03_15-43-09.jpg alt></p><p>优点：</p><ul><li>没有标记和清除的过程，更加高效</li><li>复制过去以后保证了空间的连续性，不会出现碎片</li></ul><p>缺点：</p><ul><li>需要两倍的内存空间</li><li>保证对象复制前后的对象引用关系，开销不小</li></ul><p><strong>注意：如果系统的垃圾很多，那么需要移动的对象相对较少，复制算法才更加高效</strong></p><h4 id=标记-压缩算法mark-compact>标记-压缩算法（Mark-Compact）<a hidden class=anchor aria-hidden=true href=#标记-压缩算法mark-compact>#</a></h4><p>背景：</p><p>​ 标记-清除算法的确可以应用到老年代中，但是该算法不仅效率低下而且会产生碎片问题，设计者在标记-清除算法的基础上进行改进，产生了标记-压缩算法。</p><p>执行过程：</p><p>​ 1.标记所有被引用的对象</p><p>​ 2.将所有存活的对象压缩存放在内存的一端，顺序排放</p><p>​ 3.清除边界外所有对象</p><p><img loading=lazy src=images/Snipaste_2020-06-03_15-53-05.jpg alt></p><p>优点：</p><ul><li>清除了标记-清除算法中内存分散的问题，当创建对象的时候JVM只需要修改一个指针</li><li>消除了复制算法中内存减半的高额代价</li></ul><p>缺点：</p><ul><li>从效率上来说，标记整理算法效率要低于标记-清除算法和复制算法。</li><li>移动对象时，如果该对象被其他对象引用，要调整引用地址。</li><li>需要暂停程序的时间更长</li></ul><h4 id=三种清除算法比较>三种清除算法比较<a hidden class=anchor aria-hidden=true href=#三种清除算法比较>#</a></h4><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少</td><td>少</td><td>2倍活对象空间</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>为了兼顾所有指标，标记-压缩算法相对来说更加好一些，但是它的效率比较差，比复制算法多个一个标记阶段，比标记-清除算法多个一个内存整理阶段。</p><h3 id=增量收集算法>增量收集算法<a hidden class=anchor aria-hidden=true href=#增量收集算法>#</a></h3><p>背景：</p><p>​ 标记-清除算法、复制算法、标记-压缩算法在垃圾回收过程中，应用软甲将处于一种Stop the World的状态。在这种状态下所有的线程都会挂起，暂停一切正常工作，等待垃圾回收的完成。如果垃圾回收的时间过长，应用程序会被挂起很久，将严重影响用户体验和系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究导致了增量收集算法的诞生。</p><p>基本思想：</p><p>​ 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一片小的内存空间，接着切换到用户线程。反复依次，直到垃圾收集完成。</p><p>缺点：</p><p>​ 使用这种方式，由于在垃圾回收过程中，间断性地执行应用程序线程，所以能减少系统的停顿时间。但是，因为线程切换和上下文切换的消耗，会使垃圾回收的总体成本上升，造成系统的吞吐量下降。</p><h3 id=并发和并行>并发和并行<a hidden class=anchor aria-hidden=true href=#并发和并行>#</a></h3><p>并发：在一段时间里，多个程序在一个cpu上快速切换地运行，看似所有程序同时在执行。</p><p>并行：当系统有一个以上cpu时，一个cpu（cpu具有多核，也可能是一个核心）执行一个进程，另一个cpu执行另外一个进程，两个进程不互相抢占资源，称为并行。</p><h3 id=安全点和安全区域>安全点和安全区域<a hidden class=anchor aria-hidden=true href=#安全点和安全区域>#</a></h3><p>程序在执行的时候，并非在所有的位置都能停下来，只有在特定的位置才能停下来GC，这些位置就是“安全点”。</p><p>安全点很重要，如果太少可能导致GC等待时间太长，如果太多会导致运行时性能，通常选择一些执行时间比较长的点设置安全点。</p><p>安全点机制保证了程序执行时，在不太长的时间内就可能遇到可进入GC的安全点。但是程序如果不执行，如：线程的sleep和blocked，这是线程无法响应JVM的中断请求，运行到安全点，JVM也不可能把线程唤醒，对于这种情况就需要安全区域。</p><p>安全区域是指一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置执行GC都是安全的。</p><h3 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h3><p>在jdk1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用。虚引用四种，这四种引用的强度依次减弱。</p><ul><li>强引用：在程序代码中普遍存在的引用赋值，如：Object obj=new Object（）；这种引用关系。无论在什么情况下，垃圾回收器永远不会回收掉这种引用。</li><li>软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围进行二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出。</li><li>弱引用：被弱引用关联的对象只能生存到下一次垃圾回收之前，当进行垃圾回收时，不管内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用：为一个对象设置虚引用的唯一目的就是能在对象被回收时收到一个系统通知。</li></ul><h4 id=强引用>强引用<a hidden class=anchor aria-hidden=true href=#强引用>#</a></h4><p>在java程序中，强引用时最常见的引用类型，也是默认的引用类型。</p><p>强引用的对象是可触及的，垃圾回收器就永远不会回收掉被引用的对象。</p><p>特点：</p><p>​ 可以访问目标对象。</p><p>​ 强引用指向的对象任何时候都不会被回收。</p><p>​ 强引用可能导致内存泄漏。</p><h4 id=软引用>软引用<a hidden class=anchor aria-hidden=true href=#软引用>#</a></h4><p>软引用用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前把这些对象列入回收范围进行二次回收，如果这是内存还不够，才抛出内存溢出。</p><p>在内存足够时，不会回收可触及的软引用对象，内存不够内，才回收软引用对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>User</span> <span class=n>u</span><span class=o>=</span><span class=k>new</span> <span class=n>User</span><span class=o>(</span><span class=s>&#34;zhangsan&#34;</span><span class=o>,</span> <span class=mi>20</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>softReference</span><span class=o>=</span><span class=k>new</span> <span class=n>SoftReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;(</span><span class=n>u</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>//把强引用消除
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>u</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>softReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=kt>byte</span><span class=o>[]</span> <span class=n>bytes</span><span class=o>=</span><span class=k>new</span> <span class=kt>byte</span><span class=o>[</span><span class=mi>7</span><span class=o>*</span><span class=mi>1024</span><span class=o>*</span><span class=mi>1024</span><span class=o>];</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span><span class=k>catch</span><span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span><span class=k>finally</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>softReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>在没有设置堆内存的情况下，输出：</span>
</span></span><span class=line><span class=cl><span class=n>User</span> <span class=o>[</span><span class=n>name</span><span class=o>=</span><span class=n>zhangsan</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>20</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=n>User</span> <span class=o>[</span><span class=n>name</span><span class=o>=</span><span class=n>zhangsan</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>20</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=err>由于堆内存足够，那么软引用对象不会被回收</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>设置参数：</span><span class=o>-</span><span class=n>Xms10m</span> <span class=o>-</span><span class=n>Xmx10m</span> <span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=n>User</span> <span class=o>[</span><span class=n>name</span><span class=o>=</span><span class=n>zhangsan</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>20</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=kc>null</span>
</span></span><span class=line><span class=cl><span class=err>说明在堆内存不够的情况下，软引用的对象是会被</span>
</span></span></code></pre></div><h4 id=弱引用>弱引用<a hidden class=anchor aria-hidden=true href=#弱引用>#</a></h4><p>只被弱引用关联的对象只能存活到下一次垃圾收集为止。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>User</span> <span class=n>u</span><span class=o>=</span><span class=k>new</span> <span class=n>User</span><span class=o>(</span><span class=s>&#34;zhangsan&#34;</span><span class=o>,</span> <span class=mi>20</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>weakReference</span><span class=o>=</span><span class=k>new</span> <span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;(</span><span class=n>u</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>//把强引用清除
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>u</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>weakReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=c1>//模拟一次GC
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>System</span><span class=o>.</span><span class=na>gc</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>3</span><span class=o>*</span><span class=mi>1000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>weakReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>在堆内存足够的情况下，输出：</span>
</span></span><span class=line><span class=cl><span class=n>User</span> <span class=o>[</span><span class=n>name</span><span class=o>=</span><span class=n>zhangsan</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>20</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=kc>null</span>
</span></span><span class=line><span class=cl><span class=err>说明弱引用关联的对象只能存活到下一次</span><span class=n>GC</span>
</span></span></code></pre></div><h4 id=虚引用>虚引用<a hidden class=anchor aria-hidden=true href=#虚引用>#</a></h4><p>一个对象是否有虚引用完全不会决定对象的生命周期。如果一个对象只有虚引用，和没有引用一样。</p><p>为一个对象设置虚引用的唯一作用是追踪对象的回收时间。</p><p>虚引用创建是必须提供一个引用队列作为参数，当垃圾回收器准备回收对象时，如果发现是虚引用，就会在回收对象后把虚引用加入引用队列，以通知应用程序对象的回收情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test4</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=n>ReferenceQueue</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>queue</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>CheckReferenceQueue</span> <span class=kd>extends</span> <span class=n>Thread</span><span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span><span class=o>(</span><span class=n>queue</span><span class=o>!=</span><span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>					<span class=n>Reference</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>User</span><span class=o>&gt;</span> <span class=n>remove</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>					<span class=k>try</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>						 <span class=n>remove</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>remove</span><span class=o>();</span>
</span></span><span class=line><span class=cl>					<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>InterruptedException</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>						<span class=n>e</span><span class=o>.</span><span class=na>printStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl>					<span class=o>}</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span><span class=o>(</span><span class=n>remove</span><span class=o>!=</span><span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>						<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;接收到通知&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>					<span class=o>}</span>
</span></span><span class=line><span class=cl>				<span class=o>}</span>
</span></span><span class=line><span class=cl>			<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=o>};</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>queue</span><span class=o>=</span><span class=k>new</span> <span class=n>ReferenceQueue</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>Thread</span> <span class=n>t</span><span class=o>=</span><span class=k>new</span> <span class=n>CheckReferenceQueue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>t</span><span class=o>.</span><span class=na>setDaemon</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>t</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>User</span> <span class=n>u</span><span class=o>=</span><span class=k>new</span> <span class=n>User</span><span class=o>(</span><span class=s>&#34;zhangsan&#34;</span><span class=o>,</span><span class=mi>20</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>PhantomReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>phantomReference</span><span class=o>=</span><span class=k>new</span> <span class=n>PhantomReference</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;(</span><span class=n>u</span><span class=o>,</span> <span class=n>queue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>//清除强引用
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>u</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>phantomReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>gc</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>3</span><span class=o>*</span><span class=mi>1000</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>phantomReference</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=kc>null</span>
</span></span><span class=line><span class=cl><span class=err>接收到通知</span>
</span></span><span class=line><span class=cl><span class=kc>null</span>
</span></span></code></pre></div><h2 id=垃圾回收器>垃圾回收器<a hidden class=anchor aria-hidden=true href=#垃圾回收器>#</a></h2><h3 id=垃圾回收器分类>垃圾回收器分类<a hidden class=anchor aria-hidden=true href=#垃圾回收器分类>#</a></h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li></ul><h3 id=垃圾收集器与分代之间的关系>垃圾收集器与分代之间的关系<a hidden class=anchor aria-hidden=true href=#垃圾收集器与分代之间的关系>#</a></h3><p><img loading=lazy src=images/Snipaste_2020-06-06_15-34-29.jpg alt></p><h3 id=垃圾回收器组合关系>垃圾回收器组合关系<a hidden class=anchor aria-hidden=true href=#垃圾回收器组合关系>#</a></h3><p><img loading=lazy src=images/Snipaste_2020-06-06_15-35-26.jpg alt></p><h3 id=查看默认垃圾回收器>查看默认垃圾回收器<a hidden class=anchor aria-hidden=true href=#查看默认垃圾回收器>#</a></h3><p>使用-XX:+PrintCommandLineFlags参数或<code>jinfo -flag 参数 线程 </code>可以查看JVM中使用的垃圾回收器情况</p><p>jdk1.8中使用的是Parallel GC和Parallel Old GC</p><p>jdk1.9中只使用了G1垃圾收集器</p><h3 id=serial收集器>Serial收集器<a hidden class=anchor aria-hidden=true href=#serial收集器>#</a></h3><p>serial收集器采用<strong>复制算法</strong>、串行回收和“Stop The World”机制的方式执行内存回收。</p><h3 id=serial--old收集器>Serial Old收集器<a hidden class=anchor aria-hidden=true href=#serial--old收集器>#</a></h3><p>serial old收集器同样采用串行回收和“Stop The World”机制，不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p><ul><li>Serial Old是运行在Client模式下默认的老年代垃圾收集器</li><li>Serial Old在Server模式下主要有两个用途：①与新生代Parallel Scavenge配合使用。②作为老年代CMS收集器的后备垃圾收集器</li></ul><p><img loading=lazy src=images/Snipaste_2020-06-06_16-48-14.jpg alt></p><p>在HotSpot虚拟机中，可以使用<code>-XX：+UseSerialGC</code>指定新生代使用Serial GC、老年代使用Serial Old GC。</p><h3 id=parnew收集器>ParNew收集器<a hidden class=anchor aria-hidden=true href=#parnew收集器>#</a></h3><p>如果说serial gc是新生代的单线程垃圾收集器，那么parnew收集器就是serial gc的<strong>多线程版本</strong>。</p><p>Par是Parallel的简写，New是说该收集器只能处理新生代</p><p>ParNew收集器除了采用并行回收方式外，与Serial GC之间几乎没有区别，ParNew G同样是使用<strong>复制算法</strong>和“Stop The World”机制。</p><p><img loading=lazy src=images/Snipaste_2020-06-06_17-00-47.jpg alt></p><ul><li>对于新生代，回收次数频繁，使用多线程并行方式更高效。</li><li>对于老年代，回收次数少，使用串行方式更加节省资源。</li></ul><p>可以使用<code>-XX:+UseParNewGC</code>手动指定新生代使用ParNew收集器进行内存回收</p><p>使用<code>-XX:ParallelGCThreads</code>参数限制线程数量，默认和CPU相同的线程数</p><h3 id=parallel-scavenge收集器>Parallel Scavenge收集器<a hidden class=anchor aria-hidden=true href=#parallel-scavenge收集器>#</a></h3><p>Parallel Scavenge收集器是新生代垃圾收集器</p><p>Parallel Scavenge收集器基于<strong>多线程</strong>，采用<strong>复制算法</strong>、并行回收和“Stop The World”机制。</p><p>可以使用<code>-XX：+UseParallelGC</code>指定新生代使用Parallel GC，老年代使用Parallel old收集器</p><p>使用<code>-XX:ParallelGCThreads</code>参数限制线程数量，默认和CPU相同的线程数</p><h3 id=parallel-old收集器>Parallel Old收集器<a hidden class=anchor aria-hidden=true href=#parallel-old收集器>#</a></h3><p>Parallel Old收集器是老年代垃圾收集器</p><p>Parallel Old收集器也是基于多线程的，配合Parallel收集器使用，它采用<strong>标记-压缩算法</strong>和“Stop The World”机制。</p><p>使用参数<code>-XX:+UseParallelOldGC</code>指定老年代使用Parallel Old收集器,新生代使用Parallel收集器</p><p><img loading=lazy src=images/Snipaste_2020-06-06_17-34-52.jpg alt></p><h3 id=cms收集器>CMS收集器<a hidden class=anchor aria-hidden=true href=#cms收集器>#</a></h3><p>CMS(Concurrent-Mark-Sweep)收集器是HotSpot虚拟机中第一款真正意义上 的<strong>并发收集器</strong>，它第一次实现垃圾收集线程与用户线程同时工作。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短，就越适合与用户交互的程序。</p><p>CMS收集器采用<strong>标记-清除算法</strong>。</p><p><img loading=lazy src=images/Snipaste_2020-06-08_14-46-00.jpg alt></p><ul><li>初始标记阶段：在这个阶段，程序中所有的工作线程都会“Stop The World”，这个阶段的任务仅仅是标记处GC Roots能够直接关联的对象。</li><li>并发标记阶段：从GC Root的直接关联对象开始遍历整个对象图，这个过程用时较长，但是不需要停止用户线程。</li><li>重新标记阶段：在并发标记阶段中，程序的工作线程和垃圾收集线程同时运行，这个阶段时为了修正并发标记阶段，因为程序继续运行而导致的标记变动，这个阶段和初始标记一样也会“Stop The World”，这个阶段的停顿时间通常比初始标记阶段稍长，但是比并发标记阶段短。</li><li>并发清理阶段：此阶段的任务是清除掉标记阶段判断依据死亡的对象，释放内存空间。由于不需要移动对象，所以这个阶段是可以与程序工作线程同时进行的。</li></ul><p>由于垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，应当确保应用程序线程有足够的内存可用。CMS收集器不能像其他收集器内存几乎填满才进行回收，它必须在内存达到一个阈值就开始执行垃圾收集。</p><p>缺点：</p><p>CMS收集器采用的<strong>标记-清除算法</strong>所以会产生内存碎片，可能在并发清除后，无法为大对象分配空间，从而触发Full GC</p><p>CMS由于是并发的收集器，由于垃圾收集的时候垃圾收集线程和用户线程同时执行，减少了系统的并发吞吐量</p><p>CMS收集器无法处理浮动垃圾。在并发标记阶段，用于垃圾收集线程和用户线程是同时执行的，那么在并发标记阶段产生的新垃圾对象，CMS无法对这些垃圾进行标记，最终会导致这些垃圾没有及时被回收。</p><p>使用：</p><p>可以使用<code>-XX:+UseConcMarkSweepGC</code>来开启老年代用时CMS垃圾收集器，如果设置这个参数，那么年轻代默认使用ParNew垃圾收集器</p><h3 id=g1收集器>G1收集器<a hidden class=anchor aria-hidden=true href=#g1收集器>#</a></h3><p>G1收集器的目标是在可控的暂停时间内，尽可能的提高吞吐量。</p><p>G1垃圾收集器针对新生代使用的是<strong>复制算法</strong>，老年代使用的是<strong>标记-压缩算法</strong>。</p><p>G1收集器是一个并行回收器，它把堆内存划分为一个个region，这个region在物理上是不连续的，使用不同的region来表示Eden、Survivor 0、Survivor 1和 Tenured，G1收集器把堆内存划分为region避免了在堆中进行全区域垃圾收集，G1跟踪各个region里面垃圾堆积的大小，维护一个优先列表，每次根据允许的收集时间，优先收集回收价值最大的region。</p><p><img loading=lazy src=images/Snipaste_2020-06-08_16-14-20.jpg alt></p><p>G1收集器是一款面向服务端的垃圾收集器，主要针对配备多核cpu及大容量内存的机器，在允许的延迟范围内，兼具高吞吐量的特性。</p><p>G1收集器在jdk1.7正式启用，在jdk1.9成为默认垃圾收集器，取代了CMS收集器和Parallel+Parallel Old的组合。</p><p>使用：</p><p>可以使用<code>-XX:+UseG1GC</code>来开启使用G1收集器</p><p>G1收集器回收过程：</p><ul><li>年轻代</li><li>老年代并发标记过程</li><li>混合回收</li></ul><p><img loading=lazy src=images/Snipaste_2020-06-08_17-54-46.jpg alt></p><p>当年轻代的Eden区用尽时开始年轻代的回收：G1的年轻代收集阶段是一个并行的独占式收集器，在这个阶段会停止所有的引用程序线程，启动多线程进行回收，然后将存活对象移动到Survivor去或Tenured或Survivor、Tenured。</p><p>当堆内存使用到了45%，就开始老年代的并发标记过程。标记完成马上开始混合回收，和其他收集器不同的是，G1收集器的老年代回收不需要回收所以老年代，而只需要回收一部分老年代region，然后把存活的对象移动到空闲区域，这个区域也就成为另一个老年代的region</p><p>Remembered Set</p><p>问题：</p><p>一个region不可能是谷孤立的，一个region中的对象可能被其他任意的region中的对象引用，判断对象是否存活，是否要遍历整个堆呢？</p><p>解决：</p><p>无论是G1收集器还是其他收集器，JVM都使用Remembered Set来避免全表扫描。在G1收集器中，每一个region都有一个对应的Remembered Set，每次Reference类型数据写操作时，会产生一个Write Barrier暂时中断操作，检查将要写入的引用对象是否和该Reference类型数据在不同的region，如果不在，通过CardTable把相关的引用记录添加到引用对象所在region的Remembered Set中。当进行垃圾收集时，在GC根节点的枚举范围加入Remember Set，这样就可以保证不进行全局扫描，也不会有遗漏。</p><h3 id=几种收集器的比较>几种收集器的比较<a hidden class=anchor aria-hidden=true href=#几种收集器的比较>#</a></h3><p><img loading=lazy src=images/Snipaste_2020-06-09_15-06-23.jpg alt></p><h3 id=导出gc日志>导出GC日志<a hidden class=anchor aria-hidden=true href=#导出gc日志>#</a></h3><p>使用<code>-Xloggc:./logs/gc.log</code>来把GC日志保存到外部文件</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>