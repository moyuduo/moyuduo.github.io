<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ArrayList、LinkedList和Vector源码分析 | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="ArrayList、LinkedList和Vector源码分析 ArrayList ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类
ArrayList的类结构关系 public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { } ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法
ArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快
所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess
public void test1() { List<Integer> list=new ArrayList<Integer>(); list.add(1); if(list instanceof RandomAccess) {//RandomAccess实现类，使用下标访问 for(int i=0;i<list.size();i++) { //todo } }else {//不是RandomAccess实现类，使用iterator遍历 Iterator<Integer> iterator = list.iterator(); while(iterator.hasNext()) { //todo } } } ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出CloneNotSupporteddException，详见
ArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，详见
属性 //序列化Id private static final long serialVersionUID = 8683452581122892189L; //默认初始化大小 private static final int DEFAULT_CAPACITY = 10; //空数组对象，用于有参构造且初始化大小为0时 private static final Object[] EMPTY_ELEMENTDATA = {}; //空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; //保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java."><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/arraylistlinkedlist%E5%92%8Cvector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="ArrayList、LinkedList和Vector源码分析"><meta property="og:description" content="ArrayList、LinkedList和Vector源码分析 ArrayList ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类
ArrayList的类结构关系 public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { } ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法
ArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快
所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess
public void test1() { List<Integer> list=new ArrayList<Integer>(); list.add(1); if(list instanceof RandomAccess) {//RandomAccess实现类，使用下标访问 for(int i=0;i<list.size();i++) { //todo } }else {//不是RandomAccess实现类，使用iterator遍历 Iterator<Integer> iterator = list.iterator(); while(iterator.hasNext()) { //todo } } } ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出CloneNotSupporteddException，详见
ArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，详见
属性 //序列化Id private static final long serialVersionUID = 8683452581122892189L; //默认初始化大小 private static final int DEFAULT_CAPACITY = 10; //空数组对象，用于有参构造且初始化大小为0时 private static final Object[] EMPTY_ELEMENTDATA = {}; //空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; //保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java."><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/arraylistlinkedlist%E5%92%8Cvector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ArrayList、LinkedList和Vector源码分析"><meta name=twitter:description content="ArrayList、LinkedList和Vector源码分析 ArrayList ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类
ArrayList的类结构关系 public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { } ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法
ArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快
所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess
public void test1() { List<Integer> list=new ArrayList<Integer>(); list.add(1); if(list instanceof RandomAccess) {//RandomAccess实现类，使用下标访问 for(int i=0;i<list.size();i++) { //todo } }else {//不是RandomAccess实现类，使用iterator遍历 Iterator<Integer> iterator = list.iterator(); while(iterator.hasNext()) { //todo } } } ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出CloneNotSupporteddException，详见
ArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，详见
属性 //序列化Id private static final long serialVersionUID = 8683452581122892189L; //默认初始化大小 private static final int DEFAULT_CAPACITY = 10; //空数组对象，用于有参构造且初始化大小为0时 private static final Object[] EMPTY_ELEMENTDATA = {}; //空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; //保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ArrayList、LinkedList和Vector源码分析","item":"https://moyuduo.github.io/posts/arraylistlinkedlist%E5%92%8Cvector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ArrayList、LinkedList和Vector源码分析","name":"ArrayList、LinkedList和Vector源码分析","description":"ArrayList、LinkedList和Vector源码分析 ArrayList ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类\nArrayList的类结构关系 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { } ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法\nArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快\n所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess\npublic void test1() { List\u0026lt;Integer\u0026gt; list=new ArrayList\u0026lt;Integer\u0026gt;(); list.add(1); if(list instanceof RandomAccess) {//RandomAccess实现类，使用下标访问 for(int i=0;i\u0026lt;list.size();i++) { //todo } }else {//不是RandomAccess实现类，使用iterator遍历 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while(iterator.hasNext()) { //todo } } } ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出CloneNotSupporteddException，详见\nArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，详见\n属性 //序列化Id private static final long serialVersionUID = 8683452581122892189L; //默认初始化大小 private static final int DEFAULT_CAPACITY = 10; //空数组对象，用于有参构造且初始化大小为0时 private static final Object[] EMPTY_ELEMENTDATA = {}; //空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; //保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java.","keywords":[],"articleBody":"ArrayList、LinkedList和Vector源码分析 ArrayList ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类\nArrayList的类结构关系 public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable { } ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法\nArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快\n所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess\npublic void test1() { List\u003cInteger\u003e list=new ArrayList\u003cInteger\u003e(); list.add(1); if(list instanceof RandomAccess) {//RandomAccess实现类，使用下标访问 for(int i=0;i\u003clist.size();i++) { //todo } }else {//不是RandomAccess实现类，使用iterator遍历 Iterator\u003cInteger\u003e iterator = list.iterator(); while(iterator.hasNext()) { //todo } } } ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出CloneNotSupporteddException，详见\nArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，详见\n属性 //序列化Id private static final long serialVersionUID = 8683452581122892189L; //默认初始化大小 private static final int DEFAULT_CAPACITY = 10; //空数组对象，用于有参构造且初始化大小为0时 private static final Object[] EMPTY_ELEMENTDATA = {}; //空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; //保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java.io.ObjectOutputStream s)只把保存的数据序列化了，而不是把整个数组序列化，提高效率 transient Object[] elementData; //保存的对象个数 private int size; //最大容量2的31次方减9 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造器 ArrayList提供了三个构造器，一个是指定初始化大小的构造器，一个人无参默认初始化大小构造器，一个是使用集合初始化的构造器\npublic ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { //数组的大小为指定大小 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { //大小为0用一个共享的空数组赋值 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } public ArrayList() { //用共享的空数组赋值，不使用EMPTY_ELEMENTDATA主要是区分是使用的哪个构造器 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 集合为空，使用空数组 this.elementData = EMPTY_ELEMENTDATA; } } 添加元素 在数组尾添加元素 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //计算容量 private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {//通过无参构造器创建 return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // 如果最小需要的容量\u003e数组大小 if (minCapacity - elementData.length \u003e 0) //进行扩容 grow(minCapacity); } private void grow(int minCapacity) { int oldCapacity = elementData.length; //新容量=老容量+老容量\u003e\u003e1;老容量\u003e\u003e1即老容量无符号右移1位，即除以2，所以最后新容量是老容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0)//新容量比最小容量小那么把最小容量赋值给新容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0)//如果minCapacity很大，计算得出newCapacity超出最大容量 newCapacity = hugeCapacity(minCapacity); // 复制未扩容之前的数据 elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u003c 0) // overflow throw new OutOfMemoryError(); //如果最小容量还超出ArrayList规定的最大值那么数组大小为Integer.MAX_VALUE否则为ArrayList规定的最大值 return (minCapacity \u003e MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 在指定位置添加元素 public void add(int index, E element) { //检查添加元素的下标 rangeCheckForAdd(index); //检查容量，进行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // public static native void arraycopy(src, srcPos,dest, destPos,length); //src：源数组；srcPos：源数组起始下标；dest：目标数组；destPos：目标数组起始下标；length：拷贝长度 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } private void rangeCheckForAdd(int index) { //元素的下标必须为0-size if (index \u003e size || index \u003c 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 移除元素 按照下标移除元素 public E remove(int index) { //检查下标 rangeCheck(index); modCount++; //按照下标获取元素 E oldValue = elementData(index); //计算需要移动的数据个数 int numMoved = size - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //清理数组elementData[size]位置的元素 elementData[--size] = null; // clear to let GC do its work return oldValue; } private void rangeCheck(int index) { //下标必须在0到size-1之间 if (index \u003e= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } E elementData(int index) { return (E) elementData[index]; } 按值移除元素 public boolean remove(Object o) { if (o == null) {//如果移除的元素为null,依次遍历保存的元素，移除第一个为null的元素 for (int index = 0; index \u003c size; index++) if (elementData[index] == null) { //移除 fastRemove(index); return true; } } else { for (int index = 0; index \u003c size; index++) //使用equals判断是否相等 if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } private void fastRemove(int index) { modCount++; //计算移除后需要移动的元素个数 int numMoved = size - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //清理数组elementData[size]位置的元素 elementData[--size] = null; // clear to let GC do its work } modCount ArrayList在进行add、set、remove时，都进行了modCount+1操作，这个属性与fast fail有关，当对象创建Iterator对象时会把modCount赋值给expectedModCount，当使用Iterator进行遍历时，如果发现对象的modCount与expectedModCount不相等，会直接抛出ConcurrentModificationException异常\npublic Iterator\u003cE\u003e iterator() { return new Itr(); } private class Itr implements Iterator\u003cE\u003e { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; ... public E next() { checkForComodification(); ... } final void checkForComodification() { if (modCount != expectedModCount)//直接抛出异常 throw new ConcurrentModificationException(); } 出现情况：当Iterator遍历时，如果对象的modCount和expectedModCount不等就会抛出异常，主要有这些情况\n使用iterator遍历时，进行了add、remove等破坏结构的操作 多线程环境下，一个线程在遍历时，另一个线程进行了add、remove等破坏结构的操作 通过源码学习，我发现set方法并没有增加modCount,为什么呢？难道一个线程在使用iterator遍历，另外一个线程改变了一个位置的元素，Iterator不用抛出异常？有知道的请赐教！\nLinkedList LinkedList类结构 public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable LinkedList继承AbstractSequentialList可以实现通过Iterator的随机访问\nLinkedList实现List接口可以进行添加删除等操作\nLinkedList实现了DeQue,允许在队列的两端进行入队和出队，所以可以把LinkedList当做队列或栈使用\nLinkedList实现了Cloneable，可以通过clone快速克隆对象\nLinkedList实现了Serializable接口，可以将LinkedList序列化，进行流操作\n构造器 public LinkedList() { } //使用集合初始化链表 public LinkedList(Collection\u003c? extends E\u003e c) { this(); addAll(c); } 属性 //链表的大小，transient表明在序列化的时候不进行序列化，但是LinkedList自定义的序列化方法中进行了序列化 transient int size = 0; //链表的头节点 transient Node\u003cE\u003e first; //链表的尾节点 transient Node\u003cE\u003e last; 节点 private static class Node\u003cE\u003e { E item; //前驱 Node\u003cE\u003e next; //后继 Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } 可以看到LinkedList是一个双向链表\n方法 Deque是一个双端链表，即链表可有当做栈和队列使用\ngetFirst方法,相当于Queue中的element方法,如果队空，就抛出异常\npublic E getFirst() { final Node\u003cE\u003e f = first; if (f == null) throw new NoSuchElementException(); return f.item; } getLast方法\npublic E getLast() { final Node\u003cE\u003e l = last; if (l == null) throw new NoSuchElementException(); return l.item; } removeFirst方法，相当于Queue的remove方法，删除队头元素，如果队空，抛出异常\npublic E removeFirst() { final Node\u003cE\u003e f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } private E unlinkFirst(Node\u003cE\u003e f) { // assert f == first \u0026\u0026 f != null; final E element = f.item; final Node\u003cE\u003e next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) //如果原头节点的后继为空，那么把尾指针也更新为空 last = null; else //原头节点的后继为不空，那么需要把它的前驱更新为空 next.prev = null; //更新链表大小 size--; modCount++; return element; } removeLast方法，如果队空，抛出异常\npublic E removeLast() { final Node\u003cE\u003e l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } private E unlinkLast(Node\u003cE\u003e l) { // assert l == last \u0026\u0026 l != null; final E element = l.item; final Node\u003cE\u003e prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) //如果原尾指针的前驱为空，那么头指针指向也为空 first = null; else //原尾指针的前驱不为空，那么它的后继应该改为空 prev.next = null; size--; modCount++; return element; } addFirst方法，相当于Statck中的push方法\npublic void addFirst(E e) { linkFirst(e); } private void linkFirst(E e) { final Node\u003cE\u003e f = first; //创建一个前驱为空，后驱为first的新节点 final Node\u003cE\u003e newNode = new Node\u003c\u003e(null, e, f); first = newNode; if (f == null) //如果原头指针为空，那么把尾指针也赋值为新加节点 last = newNode; else //原头指正不空，把它的前驱更新为新节点 f.prev = newNode; size++; modCount++; } addLast方法,相当于Queue中的add方法\npublic void addLast(E e) { linkLast(e); } void linkLast(E e) { final Node\u003cE\u003e l = last; final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null); last = newNode; if (l == null) //如果原为指针指向就为空，那么头指针也指向新节点 first = newNode; else //原为指针指向就不为空，那么它的后继更新为新加节点 l.next = newNode; size++; modCount++; } add方法是重写AbstractList中的方法，即往List中添加元素\npublic boolean add(E e) { linkLast(e); return true; } void linkLast(E e) { final Node\u003cE\u003e l = last; final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } remove方法移除链表中指定元素\npublic boolean remove(Object o) { if (o == null) { //如果要移除的对象为null,那么取链表中找第一个null元素并移除 for (Node\u003cE\u003e x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node\u003cE\u003e x = first; x != null; x = x.next) { if (o.equals(x.item)) {//使用equals比较两个对象是否相同 unlink(x); return true; } } } return false; } addAll方法向链表中添加指定集合的元素\npublic boolean addAll(Collection\u003c? extends E\u003e c) { return addAll(size, c); } public boolean addAll(int index, Collection\u003c? extends E\u003e c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; //如果集合大小为0 if (numNew == 0) return false; //什么一个前驱节点和一个后继节点 Node\u003cE\u003e pred, succ; if (index == size) { //如果添加的位置恰好是size即在链表最后添加,那么后继为null，前驱为链表尾指针 succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node\u003cE\u003e newNode = new Node\u003c\u003e(pred, e, null); if (pred == null)//如果没有前驱节点 //把链表头指针指向新节点 first = newNode; else pred.next = newNode; //前驱节点赋值为当前新节点 pred = newNode; } if (succ == null) {//如果没有后继节点 //把尾指针指向'前驱节点' last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } clear方法清空链表，但是modCount并不会清空\npublic void clear() { for (Node\u003cE\u003e x = first; x != null; ) { Node\u003cE\u003e next = x.next; //help GC？ x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; modCount++; } get方法获取指定下标元素，非法下标抛出异常\npublic E get(int index) { checkElementIndex(index); return node(index).item; } Node\u003cE\u003e node(int index) { // assert isElementIndex(index); //通过一个二分遍历拿元素 if (index \u003c (size \u003e\u003e 1)) { Node\u003cE\u003e x = first; for (int i = 0; i \u003c index; i++) x = x.next; return x; } else { Node\u003cE\u003e x = last; for (int i = size - 1; i \u003e index; i--) x = x.prev; return x; } } set方法设置指定下标元素值，非法下标抛出异常，set方法modCount不++？why？\npublic E set(int index, E element) { checkElementIndex(index); //获取元素 Node\u003cE\u003e x = node(index); E oldVal = x.item; //替换 x.item = element; return oldVal; } add方法，指定下标添加元素，非法下标抛出异常\npublic void add(int index, E element) { checkPositionIndex(index); if (index == size)//链表尾添加元素 linkLast(element); else //链表中间位置添加元素 linkBefore(element, node(index)); } void linkBefore(E e, Node\u003cE\u003e succ) { // assert succ != null; final Node\u003cE\u003e pred = succ.prev; final Node\u003cE\u003e newNode = new Node\u003c\u003e(pred, e, succ); succ.prev = newNode; if (pred == null)//添加元素位置前驱为null，即添加位置本来就是头指针位置 first = newNode; else //更新前驱的next为当前添加节点 pred.next = newNode; size++; modCount++; } remove方法，移除指定下标元素，非法下标抛出异常\npublic E remove(int index) { checkElementIndex(index); return unlink(node(index)); } E unlink(Node\u003cE\u003e x) { // assert x != null; final E element = x.item; final Node\u003cE\u003e next = x.next; final Node\u003cE\u003e prev = x.prev; if (prev == null) {//如果移除节点的前驱为null，即移除节点为头指针指向位置 first = next; } else { prev.next = next; //help GC？ x.prev = null; } if (next == null) {//如果移除节点的后继节点为null，即移除节点是尾指针指向位置 last = prev; } else { next.prev = prev; //help GC？ x.next = null; } //help GC？ x.item = null; size--; modCount++; return element; } peek方法，获取链表头节点，可为Queue/Stack方法，Queue方法即获取队手元素，Stack方法即获取栈顶元素\npublic E peek() { final Node\u003cE\u003e f = first; return (f == null) ? null : f.item; } element方法，获取链表头节点，与peek方法不同的是，如果队列为空，抛出异常\npublic E element() { return getFirst(); } public E getFirst() { final Node\u003cE\u003e f = first; if (f == null) //链表空抛出异常 throw new NoSuchElementException(); return f.item; } poll方法移除链表头节点，链表空返回null\npublic E poll() { final Node\u003cE\u003e f = first; return (f == null) ? null : unlinkFirst(f); } remove方法移除链表头节点，链表空抛出异常\npublic E remove() { return removeFirst(); } public E removeFirst() { final Node\u003cE\u003e f = first; if (f == null) //链表空抛出异常 throw new NoSuchElementException(); return unlinkFirst(f); } offer方法，在链表尾添加元素\npublic boolean offer(E e) { return add(e); } public boolean add(E e) { linkLast(e); return true; } offerFirst方法，在链表头添加节点，对应栈的入栈操作\npublic boolean offerFirst(E e) { addFirst(e); return true; } public void addFirst(E e) { linkFirst(e); } offerLast方法，在链表尾添加元素，本质上和offer方法没有区别\npublic boolean offerLast(E e) { addLast(e); return true; } public void addLast(E e) { linkLast(e); } peekFirst方法，查看链表头节点，相当于Queue和Stack的peek方法，链表空返回null\npublic E peekFirst() { final Node\u003cE\u003e f = first; return (f == null) ? null : f.item; } peekLast方法，查看链表尾节点，链表空返回null\npublic E peekLast() { final Node\u003cE\u003e l = last; return (l == null) ? null : l.item; } pollFirst方法，查看并删除链表头节点，链表空返回null\npublic E pollFirst() { final Node\u003cE\u003e f = first; return (f == null) ? null : unlinkFirst(f); } pollLast查看并删除链表尾节点，链表空返回null\npublic E pollLast() { final Node\u003cE\u003e l = last; return (l == null) ? null : unlinkLast(l); } push方法头节点位置添加，Stack的push方法\npublic void push(E e) { addFirst(e); } public void addFirst(E e) { linkFirst(e); } pop方法删除头节点位置元素,Stack的pop方法\npublic E pop() { return removeFirst(); } public E removeFirst() { final Node\u003cE\u003e f = first; if (f == null)//链表空抛异常 throw new NoSuchElementException(); return unlinkFirst(f); } removeFirstOccurrence方法从头结点开始查找指定元素并移除\npublic boolean removeFirstOccurrence(Object o) { return remove(o); } public boolean remove(Object o) { if (o == null) {//要移除的元素为null for (Node\u003cE\u003e x = first; x != null; x = x.next) {//从头查找，移除第一个为null元素 if (x.item == null) { unlink(x); return true; } } } else { for (Node\u003cE\u003e x = first; x != null; x = x.next) {//依次遍历 if (o.equals(x.item)) {//使用equals判断相等 unlink(x); return true; } } } return false; } removeLastOccurrence方法从尾节点开始查找并移除指定元素\npublic boolean removeLastOccurrence(Object o) { if (o == null) {//如果移除元素为null for (Node\u003cE\u003e x = last; x != null; x = x.prev) {//从后往前遍历 if (x.item == null) { unlink(x); return true; } } } else { for (Node\u003cE\u003e x = last; x != null; x = x.prev) { if (o.equals(x.item)) {//使用equals判断相等 unlink(x); return true; } } } return false; } listIterator方法返回链表迭代器\npublic ListIterator\u003cE\u003e listIterator(int index) { checkPositionIndex(index); return new ListItr(index); } //由于LinkedList是双向链表，所以可以双向遍历 private class ListItr implements ListIterator\u003cE\u003e { private Node\u003cE\u003e lastReturned; private Node\u003cE\u003e next; private int nextIndex; //expectedModCount保存拿到迭代器时，LinkedList的modCount值，与快速失败有关 private int expectedModCount = modCount; public boolean hasNext() { return nextIndex \u003c size; } public E next() { checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; } public boolean hasPrevious() { return nextIndex \u003e 0; } public E previous() { checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; } final void checkForComodification() { if (modCount != expectedModCount)//如果链表的modCount和拿到迭代器时modCount不同，说明在迭代过程中，链表进行了破坏结构的修改，那么应该直接抛出异常 throw new ConcurrentModificationException(); } } Vector 类结构 可以看到，Vector的类结构和ArrayList的一模一样\nVector继承AbstractList实现了List接口\nVector实现了RandomAccess接口，可以随机访问\nVector实现了Cloneable接口，可以使用克隆对象\nVector实现了Serializable接口，可以序列化\n属性 //保存对象的数组 protected Object[] elementData; //保存元素个数 protected int elementCount; //增长因子 protected int capacityIncrement; //定义的最大容量，为2的31次方-9 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造器 public Vector(int initialCapacity, int capacityIncrement) {//指定初始容量和增长因子 super(); if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); //直接把数组创建为初始化值大小 this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } public Vector(int initialCapacity) { //把增长因子设置为0 this(initialCapacity, 0); } public Vector() { //默认初始化大小为10 this(10); } public Vector(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); } 方法 线程安全的方法 copyInto方法把元素拷贝到指定数组\npublic synchronized void copyInto(Object[] anArray) { System.arraycopy(elementData, 0, anArray, 0, elementCount); } trimToSize方法把保存元素的数组修改到保存元素个数大小\npublic synchronized void trimToSize() { modCount++; int oldCapacity = elementData.length; if (elementCount \u003c oldCapacity) {//如果元素个数比容量小 elementData = Arrays.copyOf(elementData, elementCount); } } ensureCapacity方法用于添加元素时，确保数组大小\npublic synchronized void ensureCapacity(int minCapacity) { if (minCapacity \u003e 0) { modCount++; ensureCapacityHelper(minCapacity); } } private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length \u003e 0)//如果需要的最小容量大于数组大小 //扩容 grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; //如果指定了增长因子而且增长因子\u003e0那么新容量就等于原容量+增长因子，否则就是原容量的二倍 int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } setSize方法设置向量的大小\npublic synchronized void setSize(int newSize) { modCount++; if (newSize \u003e elementCount) {//如果新容量比原容量大，多的元素全为null ensureCapacityHelper(newSize); } else { //新容量比原容量小 for (int i = newSize ; i \u003c elementCount ; i++) { elementData[i] = null; } } elementCount = newSize; } removeElementAt移除指定位置元素\npublic synchronized void removeElementAt(int index) { modCount++; if (index \u003e= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" \u003e= \" + elementCount); } else if (index \u003c 0) { throw new ArrayIndexOutOfBoundsException(index); } //要移动的元素个数 int j = elementCount - index - 1; if (j \u003e 0) { System.arraycopy(elementData, index + 1, elementData, index, j); } elementCount--; elementData[elementCount] = null; /* to let gc do its work */ } insertElementAt指定位置插入元素\npublic synchronized void insertElementAt(E obj, int index) { modCount++; if (index \u003e elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" \u003e \" + elementCount); } //确保容量 ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; } addElement在尾部添加元素\npublic synchronized void addElement(E obj) { modCount++; //确保容量 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } removeElement移除指定元素\npublic synchronized boolean removeElement(Object obj) { modCount++; int i = indexOf(obj); if (i \u003e= 0) { removeElementAt(i); return true; } return false; } removeAllElements移除所有元素\npublic synchronized void removeAllElements() { modCount++; // Let gc do its work for (int i = 0; i \u003c elementCount; i++) elementData[i] = null; elementCount = 0; } get获取指定位置元素\npublic synchronized E get(int index) { if (index \u003e= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); } set替换指定位置元素\npublic synchronized E set(int index, E element) { if (index \u003e= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } add方法添加元素，与addElement方法的区别仅仅是返回值不同\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } remove移除尾元素\npublic boolean remove(Object o) { return removeElement(o); } add指定位置添加元素\npublic void add(int index, E element) { insertElementAt(element, index); } remove移除指定位置元素\npublic synchronized E remove(int index) { modCount++; if (index \u003e= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); //计算要移动的元素个数 int numMoved = elementCount - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; } listIterator获取向量的迭代器，可以进行向前向后遍历\npublic synchronized ListIterator\u003cE\u003e listIterator() { return new ListItr(0); } final class ListItr extends Itr implements ListIterator\u003cE\u003e { ListItr(int index) { super(); cursor = index; } public boolean hasPrevious() { return cursor != 0; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } public E previous() { synchronized (Vector.this) { checkForComodification(); int i = cursor - 1; if (i \u003c 0) throw new NoSuchElementException(); cursor = i; return elementData(lastRet = i); } } public void set(E e) { if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) { checkForComodification(); Vector.this.set(lastRet, e); } } public void add(E e) { int i = cursor; synchronized (Vector.this) { checkForComodification(); Vector.this.add(i, e); expectedModCount = modCount; } cursor = i + 1; lastRet = -1; } } 可以看到Vector和ArrayList的源码基本相同，只是Vector是线程安全的，还有就是Vector和ArrayList在扩容上有一点点不同，Vector如果指定了增长因子，那么新容量是原容量+增长因子，而ArrayList是直接扩大两倍原容量\n","wordCount":"2687","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/arraylistlinkedlist%E5%92%8Cvector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://moyuduo.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://moyuduo.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>ArrayList、LinkedList和Vector源码分析</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#arraylist>ArrayList</a><ul><li><a href=#arraylist的类结构关系>ArrayList的类结构关系</a></li><li><a href=#属性>属性</a></li><li><a href=#构造器>构造器</a></li><li><a href=#添加元素>添加元素</a></li><li><a href=#移除元素>移除元素</a></li><li><a href=#modcount>modCount</a></li></ul></li><li><a href=#linkedlist>LinkedList</a><ul><li><a href=#linkedlist类结构>LinkedList类结构</a></li><li><a href=#构造器-1>构造器</a></li><li><a href=#属性-1>属性</a></li><li><a href=#节点>节点</a></li><li><a href=#方法>方法</a></li></ul></li><li><a href=#vector>Vector</a><ul><li><a href=#类结构>类结构</a></li><li><a href=#属性-2>属性</a></li><li><a href=#构造器-2>构造器</a></li><li><a href=#方法-1>方法</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=arraylistlinkedlist和vector源码分析>ArrayList、LinkedList和Vector源码分析<a hidden class=anchor aria-hidden=true href=#arraylistlinkedlist和vector源码分析>#</a></h1><h2 id=arraylist>ArrayList<a hidden class=anchor aria-hidden=true href=#arraylist>#</a></h2><blockquote><p>ArrayList是一个底层使用数组来存储对象，但不是线程安全的集合类</p></blockquote><h3 id=arraylist的类结构关系>ArrayList的类结构关系<a hidden class=anchor aria-hidden=true href=#arraylist的类结构关系>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>AbstractList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;,</span> <span class=n>RandomAccess</span><span class=o>,</span> <span class=n>Cloneable</span><span class=o>,</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span></code></pre></div><p><img loading=lazy src=images/Snipaste_2020-04-09_11-35-04.jpg alt></p><p>ArrayList实现了List接口，List接口中定义了一些对列表通过下标进行添加删除等方法</p><p>ArrayList实现了RandomAccess接口，这个接口是一个标记接口，接口中并没有任何的方法，ArrayList底层是用数组来存储对象，当然是能够通过下标随机访问的，实现了RandomAccess接口的类在查询时的速度会很快但是添加删除元素慢，而LinkedList是通过链表的方式实现的，它没有实现RandomAccess接口，在查询时慢但是增加删除的速度快</p><p>所以在使用集合遍历大量数据时，可以先用instanceof来判断集合是不是实现了RandomAccess</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>=</span><span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>		<span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=o>(</span><span class=n>list</span> <span class=k>instanceof</span> <span class=n>RandomAccess</span><span class=o>)</span> <span class=o>{</span><span class=c1>//RandomAccess实现类，使用下标访问
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=o>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>list</span><span class=o>.</span><span class=na>size</span><span class=o>();</span><span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>//todo
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span><span class=k>else</span> <span class=o>{</span><span class=c1>//不是RandomAccess实现类，使用iterator遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>iterator</span> <span class=o>=</span> <span class=n>list</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span><span class=o>(</span><span class=n>iterator</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>//todo
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span></code></pre></div><p>ArrayList实现了Cloneable接口,所以可以合法调用clone方法，如果没有实现Cloneable接口，那么会抛出<strong>CloneNotSupporteddException</strong>，<a href=https://www.cnblogs.com/moyuduo/p/12670541.html>详见</a></p><p>ArrayList实现了Serializable接口，可以将对象序列化，用于传输或持久化，<a href=https://www.cnblogs.com/moyuduo/p/12676987.html>详见</a></p><h3 id=属性>属性<a hidden class=anchor aria-hidden=true href=#属性>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//序列化Id
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=mi>8683452581122892189L</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//默认初始化大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>DEFAULT_CAPACITY</span> <span class=o>=</span> <span class=mi>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//空数组对象，用于有参构造且初始化大小为0时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>EMPTY_ELEMENTDATA</span> <span class=o>=</span> <span class=o>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//空数组对象，用于无参构造时，这两个属性主要用来区分创建ArrayList时有没有指定容量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class=o>=</span> <span class=o>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//保存对象的容器，使用transient修饰即在序列化时，不进行序列化，这是因为ArrayList添加了序列化方法private void writeObject(java.io.ObjectOutputStream s)只把保存的数据序列化了，而不是把整个数组序列化，提高效率
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elementData</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//保存的对象个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kt>int</span> <span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//最大容量2的31次方减9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span> <span class=o>-</span> <span class=mi>8</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=构造器>构造器<a hidden class=anchor aria-hidden=true href=#构造器>#</a></h3><p>ArrayList提供了三个构造器，一个是指定初始化大小的构造器，一个人无参默认初始化大小构造器，一个是使用集合初始化的构造器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ArrayList</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//数组的大小为指定大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>this</span><span class=o>.</span><span class=na>elementData</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//大小为0用一个共享的空数组赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>this</span><span class=o>.</span><span class=na>elementData</span> <span class=o>=</span> <span class=n>EMPTY_ELEMENTDATA</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal Capacity: &#34;</span><span class=o>+</span>
</span></span><span class=line><span class=cl>                                       <span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ArrayList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//用共享的空数组赋值，不使用EMPTY_ELEMENTDATA主要是区分是使用的哪个构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>this</span><span class=o>.</span><span class=na>elementData</span> <span class=o>=</span> <span class=n>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=nf>ArrayList</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>elementData</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>((</span><span class=n>size</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// c.toArray might (incorrectly) not return Object[] (see 6260652)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>elementData</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>!=</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=n>elementData</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>size</span><span class=o>,</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 集合为空，使用空数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>this</span><span class=o>.</span><span class=na>elementData</span> <span class=o>=</span> <span class=n>EMPTY_ELEMENTDATA</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=添加元素>添加元素<a hidden class=anchor aria-hidden=true href=#添加元素>#</a></h3><h4 id=在数组尾添加元素>在数组尾添加元素<a hidden class=anchor aria-hidden=true href=#在数组尾添加元素>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ensureCapacityInternal</span><span class=o>(</span><span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>  <span class=c1>// Increments modCount!!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>elementData</span><span class=o>[</span><span class=n>size</span><span class=o>++]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>ensureCapacityInternal</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ensureExplicitCapacity</span><span class=o>(</span><span class=n>calculateCapacity</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>minCapacity</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//计算容量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>calculateCapacity</span><span class=o>(</span><span class=n>Object</span><span class=o>[]</span> <span class=n>elementData</span><span class=o>,</span> <span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>elementData</span> <span class=o>==</span> <span class=n>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=o>)</span> <span class=o>{</span><span class=c1>//通过无参构造器创建
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>DEFAULT_CAPACITY</span><span class=o>,</span> <span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>minCapacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>ensureExplicitCapacity</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果最小需要的容量&gt;数组大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>-</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//进行扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>grow</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>grow</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>oldCapacity</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//新容量=老容量+老容量&gt;&gt;1;老容量&gt;&gt;1即老容量无符号右移1位，即除以2，所以最后新容量是老容量的1.5倍
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>oldCapacity</span> <span class=o>+</span> <span class=o>(</span><span class=n>oldCapacity</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>-</span> <span class=n>minCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span><span class=c1>//新容量比最小容量小那么把最小容量赋值给新容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>minCapacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>-</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span><span class=c1>//如果minCapacity很大，计算得出newCapacity超出最大容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>hugeCapacity</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 复制未扩容之前的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>elementData</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>newCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>hugeCapacity</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=c1>// overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>throw</span> <span class=k>new</span> <span class=n>OutOfMemoryError</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>//如果最小容量还超出ArrayList规定的最大值那么数组大小为Integer.MAX_VALUE否则为ArrayList规定的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>&gt;</span> <span class=n>MAX_ARRAY_SIZE</span><span class=o>)</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>    <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>MAX_ARRAY_SIZE</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=在指定位置添加元素>在指定位置添加元素<a hidden class=anchor aria-hidden=true href=#在指定位置添加元素>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//检查添加元素的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rangeCheckForAdd</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//检查容量，进行扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ensureCapacityInternal</span><span class=o>(</span><span class=n>size</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>  <span class=c1>// Increments modCount!!
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// public static native void arraycopy(src, srcPos,dest, destPos,length);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//src：源数组；srcPos：源数组起始下标；dest：目标数组；destPos：目标数组起始下标；length：拷贝长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>size</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>rangeCheckForAdd</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//元素的下标必须为0-size
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;</span> <span class=n>size</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span><span class=n>outOfBoundsMsg</span><span class=o>(</span><span class=n>index</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=移除元素>移除元素<a hidden class=anchor aria-hidden=true href=#移除元素>#</a></h3><h4 id=按照下标移除元素>按照下标移除元素<a hidden class=anchor aria-hidden=true href=#按照下标移除元素>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//检查下标
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rangeCheck</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//按照下标获取元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>E</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//计算需要移动的数据个数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>numMoved</span> <span class=o>=</span> <span class=n>size</span> <span class=o>-</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>numMoved</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>numMoved</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//清理数组elementData[size]位置的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>elementData</span><span class=o>[--</span><span class=n>size</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// clear to let GC do its work
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>rangeCheck</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//下标必须在0到size-1之间
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>size</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span><span class=n>outOfBoundsMsg</span><span class=o>(</span><span class=n>index</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>E</span> <span class=nf>elementData</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=按值移除元素>按值移除元素<a hidden class=anchor aria-hidden=true href=#按值移除元素>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果移除的元素为null,依次遍历保存的元素，移除第一个为null的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>index</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=o>(</span><span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//移除
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>fastRemove</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>index</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>      <span class=c1>//使用equals判断是否相等
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=o>(</span><span class=n>o</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>]))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fastRemove</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>fastRemove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//计算移除后需要移动的元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>numMoved</span> <span class=o>=</span> <span class=n>size</span> <span class=o>-</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>numMoved</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>numMoved</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//清理数组elementData[size]位置的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>elementData</span><span class=o>[--</span><span class=n>size</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// clear to let GC do its work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><h3 id=modcount>modCount<a hidden class=anchor aria-hidden=true href=#modcount>#</a></h3><p>ArrayList在进行add、set、remove时，都进行了modCount+1操作，这个属性与fast fail有关，当对象创建Iterator对象时会把modCount赋值给expectedModCount，当使用Iterator进行遍历时，如果发现对象的modCount与expectedModCount不相等，会直接抛出ConcurrentModificationException异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>iterator</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>Itr</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>class</span> <span class=nc>Itr</span> <span class=kd>implements</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>cursor</span><span class=o>;</span>       <span class=c1>// index of next element to return
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span> <span class=c1>// index of last element returned; -1 if no such
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>expectedModCount</span> <span class=o>=</span> <span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>void</span> <span class=nf>checkForComodification</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>modCount</span> <span class=o>!=</span> <span class=n>expectedModCount</span><span class=o>)</span><span class=c1>//直接抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span></code></pre></div><p>出现情况：当Iterator遍历时，如果对象的modCount和expectedModCount不等就会抛出异常，主要有这些情况</p><ul><li>使用iterator遍历时，进行了add、remove等破坏结构的操作</li><li>多线程环境下，一个线程在遍历时，另一个线程进行了add、remove等破坏结构的操作</li></ul><p>通过源码学习，我发现set方法并没有增加modCount,为什么呢？难道一个线程在使用iterator遍历，另外一个线程改变了一个位置的元素，Iterator不用抛出异常？有知道的请赐教！</p><h2 id=linkedlist>LinkedList<a hidden class=anchor aria-hidden=true href=#linkedlist>#</a></h2><h3 id=linkedlist类结构>LinkedList类结构<a hidden class=anchor aria-hidden=true href=#linkedlist类结构>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>LinkedList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>extends</span> <span class=n>AbstractSequentialList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;,</span> <span class=n>Deque</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;,</span> <span class=n>Cloneable</span><span class=o>,</span> <span class=n>java</span><span class=o>.</span><span class=na>io</span><span class=o>.</span><span class=na>Serializable</span>
</span></span></code></pre></div><p><img loading=lazy src=images/Snipaste_2020-04-13_09-58-01.jpg alt></p><p>LinkedList继承AbstractSequentialList可以实现通过Iterator的随机访问</p><p>LinkedList实现List接口可以进行添加删除等操作</p><p>LinkedList实现了DeQue,允许在队列的两端进行入队和出队，所以可以把LinkedList当做队列或栈使用</p><p>LinkedList实现了Cloneable，可以通过clone快速克隆对象</p><p>LinkedList实现了Serializable接口，可以将LinkedList序列化，进行流操作</p><h3 id=构造器-1>构造器<a hidden class=anchor aria-hidden=true href=#构造器-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>LinkedList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//使用集合初始化链表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedList</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>addAll</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><h3 id=属性-1>属性<a hidden class=anchor aria-hidden=true href=#属性-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//链表的大小，transient表明在序列化的时候不进行序列化，但是LinkedList自定义的序列化方法中进行了序列化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//链表的头节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//链表的尾节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>last</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=节点>节点<a hidden class=anchor aria-hidden=true href=#节点>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//前驱
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//后继
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Node</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>prev</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>可以看到LinkedList是一个双向链表</p><h3 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h3><p>Deque是一个双端链表，即链表可有当做栈和队列使用</p><p>getFirst方法,相当于Queue中的element方法,如果队空，就抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>getFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>f</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>getLast方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>getLast</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>l</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeFirst方法，相当于Queue的remove方法，删除队头元素，如果队空，抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>removeFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>unlinkFirst</span><span class=o>(</span><span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>E</span> <span class=nf>unlinkFirst</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// assert f == first &amp;&amp; f != null;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>final</span> <span class=n>E</span> <span class=n>element</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>f</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>first</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果原头节点的后继为空，那么把尾指针也更新为空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>last</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=c1>//原头节点的后继为不空，那么需要把它的前驱更新为空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>next</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//更新链表大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>removeLast方法，如果队空，抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>removeLast</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>unlinkLast</span><span class=o>(</span><span class=n>l</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>E</span> <span class=nf>unlinkLast</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// assert l == last &amp;&amp; l != null;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>final</span> <span class=n>E</span> <span class=n>element</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>prev</span> <span class=o>=</span> <span class=n>l</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// help GC
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>last</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>prev</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=c1>//如果原尾指针的前驱为空，那么头指针指向也为空
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>first</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=c1>//原尾指针的前驱不为空，那么它的后继应该改为空
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>prev</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>addFirst方法，相当于Statck中的push方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>addFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>linkFirst</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>linkFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//创建一个前驱为空，后驱为first的新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=kc>null</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>first</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//如果原头指针为空，那么把尾指针也赋值为新加节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>last</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=c1>//原头指正不空，把它的前驱更新为新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>addLast方法,相当于Queue中的add方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>addLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkLast</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>linkLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=n>l</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=c1>//如果原为指针指向就为空，那么头指针也指向新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>first</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=c1>//原为指针指向就不为空，那么它的后继更新为新加节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>l</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>add方法是重写AbstractList中的方法，即往List中添加元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkLast</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>linkLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=n>l</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>first</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove方法移除链表中指定元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>//如果要移除的对象为null,那么取链表中找第一个null元素并移除
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>o</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span><span class=o>))</span> <span class=o>{</span><span class=c1>//使用equals比较两个对象是否相同
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>addAll方法向链表中添加指定集合的元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>addAll</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>addAll</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>c</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>addAll</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>checkPositionIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Object</span><span class=o>[]</span> <span class=n>a</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>numNew</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>   <span class=c1>//如果集合大小为0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>numNew</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=c1>//什么一个前驱节点和一个后继节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>pred</span><span class=o>,</span> <span class=n>succ</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>size</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>//如果添加的位置恰好是size即在链表最后添加,那么后继为null，前驱为链表尾指针
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>succ</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>succ</span> <span class=o>=</span> <span class=n>node</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span> <span class=o>=</span> <span class=n>succ</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=n>Object</span> <span class=n>o</span> <span class=o>:</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span> <span class=n>E</span> <span class=n>e</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>o</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=n>pred</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>pred</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//如果没有前驱节点
</span></span></span><span class=line><span class=cl><span class=c1></span>              <span class=c1>//把链表头指针指向新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>first</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>//前驱节点赋值为当前新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>pred</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>succ</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果没有后继节点
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//把尾指针指向&#39;前驱节点&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>last</span> <span class=o>=</span> <span class=n>pred</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>succ</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>succ</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>pred</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>+=</span> <span class=n>numNew</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>clear方法清空链表，但是modCount并不会清空</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>clear</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>//help GC？
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>first</span> <span class=o>=</span> <span class=n>last</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>get方法获取指定下标元素，非法下标抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>get</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>checkElementIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>node</span><span class=o>(</span><span class=n>index</span><span class=o>).</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>node</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// assert isElementIndex(index);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//通过一个二分遍历拿元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=o>(</span><span class=n>size</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span><span class=o>--)</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>set方法设置指定下标元素值，非法下标抛出异常，set方法modCount不++？why？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>set</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>checkElementIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//获取元素
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>node</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>oldVal</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//替换
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>oldVal</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>add方法，指定下标添加元素，非法下标抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>checkPositionIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>size</span><span class=o>)</span><span class=c1>//链表尾添加元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>linkLast</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=c1>//链表中间位置添加元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>linkBefore</span><span class=o>(</span><span class=n>element</span><span class=o>,</span> <span class=n>node</span><span class=o>(</span><span class=n>index</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>linkBefore</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>succ</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// assert succ != null;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>pred</span> <span class=o>=</span> <span class=n>succ</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>newNode</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;&gt;(</span><span class=n>pred</span><span class=o>,</span> <span class=n>e</span><span class=o>,</span> <span class=n>succ</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>succ</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>pred</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//添加元素位置前驱为null，即添加位置本来就是头指针位置
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>first</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>          <span class=c1>//更新前驱的next为当前添加节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>pred</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove方法，移除指定下标元素，非法下标抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>checkElementIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>unlink</span><span class=o>(</span><span class=n>node</span><span class=o>(</span><span class=n>index</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>E</span> <span class=nf>unlink</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// assert x != null;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>final</span> <span class=n>E</span> <span class=n>element</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>prev</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>prev</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果移除节点的前驱为null，即移除节点为头指针指向位置
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>first</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>prev</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>//help GC？
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>x</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果移除节点的后继节点为null，即移除节点是尾指针指向位置
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>last</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>next</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>//help GC？
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>x</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=c1>//help GC？
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>peek方法，获取链表头节点，可为Queue/Stack方法，Queue方法即获取队手元素，Stack方法即获取栈顶元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>peek</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>f</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>element方法，获取链表头节点，与peek方法不同的是，如果队列为空，抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>element</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>getFirst</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>getFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//链表空抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>f</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>poll方法移除链表头节点，链表空返回null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>poll</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>unlinkFirst</span><span class=o>(</span><span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove方法移除链表头节点，链表空抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>removeFirst</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>removeFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//链表空抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>unlinkFirst</span><span class=o>(</span><span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>offer方法，在链表尾添加元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>offer</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>add</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkLast</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>offerFirst方法，在链表头添加节点，对应栈的入栈操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>offerFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>addFirst</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>addFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkFirst</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>offerLast方法，在链表尾添加元素，本质上和offer方法没有区别</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>offerLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>addLast</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>addLast</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkLast</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>peekFirst方法，查看链表头节点，相当于Queue和Stack的peek方法，链表空返回null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>peekFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>f</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>     <span class=o>}</span>
</span></span></code></pre></div><p>peekLast方法，查看链表尾节点，链表空返回null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>peekLast</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>l</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>pollFirst方法，查看并删除链表头节点，链表空返回null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>pollFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>unlinkFirst</span><span class=o>(</span><span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>pollLast查看并删除链表尾节点，链表空返回null</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>pollLast</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>l</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>l</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>unlinkLast</span><span class=o>(</span><span class=n>l</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>push方法头节点位置添加，Stack的push方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>addFirst</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>addFirst</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>linkFirst</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>pop方法删除头节点位置元素,Stack的pop方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>pop</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>removeFirst</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>removeFirst</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>f</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>f</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//链表空抛异常
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>unlinkFirst</span><span class=o>(</span><span class=n>f</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeFirstOccurrence方法从头结点开始查找指定元素并移除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>removeFirstOccurrence</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remove</span><span class=o>(</span><span class=n>o</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//要移除的元素为null
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span><span class=c1>//从头查找，移除第一个为null元素
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span><span class=c1>//依次遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>o</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span><span class=o>))</span> <span class=o>{</span><span class=c1>//使用equals判断相等
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeLastOccurrence方法从尾节点开始查找并移除指定元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>removeLastOccurrence</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>o</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果移除元素为null
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>prev</span><span class=o>)</span> <span class=o>{</span><span class=c1>//从后往前遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>.</span><span class=na>prev</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>o</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>x</span><span class=o>.</span><span class=na>item</span><span class=o>))</span> <span class=o>{</span><span class=c1>//使用equals判断相等
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>unlink</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>listIterator方法返回链表迭代器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>listIterator</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>checkPositionIndex</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ListItr</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>//由于LinkedList是双向链表，所以可以双向遍历
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>class</span> <span class=nc>ListItr</span> <span class=kd>implements</span> <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>lastReturned</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kt>int</span> <span class=n>nextIndex</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  		<span class=c1>//expectedModCount保存拿到迭代器时，LinkedList的modCount值，与快速失败有关
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>private</span> <span class=kt>int</span> <span class=n>expectedModCount</span> <span class=o>=</span> <span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasNext</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>nextIndex</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(!</span><span class=n>hasNext</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>lastReturned</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>lastReturned</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasPrevious</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>nextIndex</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>E</span> <span class=nf>previous</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(!</span><span class=n>hasPrevious</span><span class=o>())</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>lastReturned</span> <span class=o>=</span> <span class=n>next</span> <span class=o>=</span> <span class=o>(</span><span class=n>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>last</span> <span class=o>:</span> <span class=n>next</span><span class=o>.</span><span class=na>prev</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>lastReturned</span><span class=o>.</span><span class=na>item</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>final</span> <span class=kt>void</span> <span class=nf>checkForComodification</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>modCount</span> <span class=o>!=</span> <span class=n>expectedModCount</span><span class=o>)</span><span class=c1>//如果链表的modCount和拿到迭代器时modCount不同，说明在迭代过程中，链表进行了破坏结构的修改，那么应该直接抛出异常
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>throw</span> <span class=k>new</span> <span class=n>ConcurrentModificationException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=vector>Vector<a hidden class=anchor aria-hidden=true href=#vector>#</a></h2><h3 id=类结构>类结构<a hidden class=anchor aria-hidden=true href=#类结构>#</a></h3><p><img loading=lazy src=images/Snipaste_2020-04-14_22-16-49.jpg alt></p><p>可以看到，Vector的类结构和ArrayList的一模一样</p><p>Vector继承AbstractList实现了List接口</p><p>Vector实现了RandomAccess接口，可以随机访问</p><p>Vector实现了Cloneable接口，可以使用克隆对象</p><p>Vector实现了Serializable接口，可以序列化</p><h3 id=属性-2>属性<a hidden class=anchor aria-hidden=true href=#属性-2>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//保存对象的数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elementData</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//保存元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>int</span> <span class=n>elementCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//增长因子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>protected</span> <span class=kt>int</span> <span class=n>capacityIncrement</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//定义的最大容量，为2的31次方-9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span> <span class=o>-</span> <span class=mi>8</span><span class=o>;</span>
</span></span></code></pre></div><h3 id=构造器-2>构造器<a hidden class=anchor aria-hidden=true href=#构造器-2>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>Vector</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>int</span> <span class=n>capacityIncrement</span><span class=o>)</span> <span class=o>{</span><span class=c1>//指定初始容量和增长因子
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>super</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal Capacity: &#34;</span><span class=o>+</span>
</span></span><span class=line><span class=cl>                                               <span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//直接把数组创建为初始化值大小
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>.</span><span class=na>elementData</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>capacityIncrement</span> <span class=o>=</span> <span class=n>capacityIncrement</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>Vector</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//把增长因子设置为0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>Vector</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//默认初始化大小为10
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>(</span><span class=mi>10</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=nf>Vector</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>elementCount</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// c.toArray might (incorrectly) not return Object[] (see 6260652)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>elementData</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>!=</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>elementData</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>elementCount</span><span class=o>,</span> <span class=n>Object</span><span class=o>[].</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><h3 id=方法-1>方法<a hidden class=anchor aria-hidden=true href=#方法-1>#</a></h3><h4 id=线程安全的方法>线程安全的方法<a hidden class=anchor aria-hidden=true href=#线程安全的方法>#</a></h4><p>copyInto方法把元素拷贝到指定数组</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>copyInto</span><span class=o>(</span><span class=n>Object</span><span class=o>[]</span> <span class=n>anArray</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>anArray</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>elementCount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>trimToSize方法把保存元素的数组修改到保存元素个数大小</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>trimToSize</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>oldCapacity</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>elementCount</span> <span class=o>&lt;</span> <span class=n>oldCapacity</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果元素个数比容量小
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>elementData</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>elementCount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>ensureCapacity方法用于添加元素时，确保数组大小</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>ensureCapacity</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>            <span class=n>ensureCapacityHelper</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>ensureCapacityHelper</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// overflow-conscious code
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>minCapacity</span> <span class=o>-</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span><span class=c1>//如果需要的最小容量大于数组大小
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>grow</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>grow</span><span class=o>(</span><span class=kt>int</span> <span class=n>minCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// overflow-conscious code
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>oldCapacity</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//如果指定了增长因子而且增长因子&gt;0那么新容量就等于原容量+增长因子，否则就是原容量的二倍
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>oldCapacity</span> <span class=o>+</span> <span class=o>((</span><span class=n>capacityIncrement</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>                                         <span class=n>capacityIncrement</span> <span class=o>:</span> <span class=n>oldCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>-</span> <span class=n>minCapacity</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>minCapacity</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>newCapacity</span> <span class=o>-</span> <span class=n>MAX_ARRAY_SIZE</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>hugeCapacity</span><span class=o>(</span><span class=n>minCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>newCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>setSize方法设置向量的大小</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>setSize</span><span class=o>(</span><span class=kt>int</span> <span class=n>newSize</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>newSize</span> <span class=o>&gt;</span> <span class=n>elementCount</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果新容量比原容量大，多的元素全为null
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>ensureCapacityHelper</span><span class=o>(</span><span class=n>newSize</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>//新容量比原容量小
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>newSize</span> <span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>elementCount</span> <span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>elementData</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>elementCount</span> <span class=o>=</span> <span class=n>newSize</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeElementAt移除指定位置元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>removeElementAt</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>elementCount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=s>&#34; &gt;= &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                                     <span class=n>elementCount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//要移动的元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>elementCount</span> <span class=o>-</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>elementCount</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[</span><span class=n>elementCount</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=cm>/* to let gc do its work */</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>insertElementAt指定位置插入元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>insertElementAt</span><span class=o>(</span><span class=n>E</span> <span class=n>obj</span><span class=o>,</span> <span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;</span> <span class=n>elementCount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span>
</span></span><span class=line><span class=cl>                                                     <span class=o>+</span> <span class=s>&#34; &gt; &#34;</span> <span class=o>+</span> <span class=n>elementCount</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>//确保容量
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ensureCapacityHelper</span><span class=o>(</span><span class=n>elementCount</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>elementCount</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>obj</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>elementCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>addElement在尾部添加元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>addElement</span><span class=o>(</span><span class=n>E</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//确保容量
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ensureCapacityHelper</span><span class=o>(</span><span class=n>elementCount</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[</span><span class=n>elementCount</span><span class=o>++]</span> <span class=o>=</span> <span class=n>obj</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeElement移除指定元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>boolean</span> <span class=nf>removeElement</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>indexOf</span><span class=o>(</span><span class=n>obj</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>removeElementAt</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>removeAllElements移除所有元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>void</span> <span class=nf>removeAllElements</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Let gc do its work
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>elementCount</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
</span></span><span class=line><span class=cl>            <span class=n>elementData</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>elementCount</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>get获取指定位置元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>E</span> <span class=nf>get</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>elementCount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>elementData</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>set替换指定位置元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>E</span> <span class=nf>set</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>elementCount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>E</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>add方法添加元素，与addElement方法的区别仅仅是返回值不同</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=n>ensureCapacityHelper</span><span class=o>(</span><span class=n>elementCount</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[</span><span class=n>elementCount</span><span class=o>++]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove移除尾元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>removeElement</span><span class=o>(</span><span class=n>o</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>add指定位置添加元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>insertElementAt</span><span class=o>(</span><span class=n>element</span><span class=o>,</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove移除指定位置元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modCount</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&gt;=</span> <span class=n>elementCount</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArrayIndexOutOfBoundsException</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>E</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>elementData</span><span class=o>(</span><span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=c1>//计算要移动的元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>numMoved</span> <span class=o>=</span> <span class=n>elementCount</span> <span class=o>-</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>numMoved</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=o>,</span> <span class=n>elementData</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                             <span class=n>numMoved</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>elementData</span><span class=o>[--</span><span class=n>elementCount</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span> <span class=c1>// Let gc do its work
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>listIterator获取向量的迭代器，可以进行向前向后遍历</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>listIterator</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ListItr</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=kd>class</span> <span class=nc>ListItr</span> <span class=kd>extends</span> <span class=n>Itr</span> <span class=kd>implements</span> <span class=n>ListIterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ListItr</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>super</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span> <span class=o>=</span> <span class=n>index</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasPrevious</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cursor</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>int</span> <span class=nf>nextIndex</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cursor</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>int</span> <span class=nf>previousIndex</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cursor</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>E</span> <span class=nf>previous</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>synchronized</span> <span class=o>(</span><span class=n>Vector</span><span class=o>.</span><span class=na>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>cursor</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=n>NoSuchElementException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>elementData</span><span class=o>(</span><span class=n>lastRet</span> <span class=o>=</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>lastRet</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalStateException</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=kd>synchronized</span> <span class=o>(</span><span class=n>Vector</span><span class=o>.</span><span class=na>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>Vector</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>lastRet</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kd>synchronized</span> <span class=o>(</span><span class=n>Vector</span><span class=o>.</span><span class=na>this</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>checkForComodification</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=n>Vector</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>expectedModCount</span> <span class=o>=</span> <span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>lastRet</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p><strong>可以看到Vector和ArrayList的源码基本相同，只是Vector是线程安全的，还有就是Vector和ArrayList在扩容上有一点点不同，Vector如果指定了增长因子，那么新容量是原容量+增长因子，而ArrayList是直接扩大两倍原容量</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>