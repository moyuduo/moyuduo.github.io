<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>iptables | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="iptables 介绍 iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。
当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。
其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是
PREROUTING、FORWARD、POSTROUTING
也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。
根据上图，我们能够想象出某些常用场景中，报文的流向：
到本机某进程的报文：PREROUTING –> INPUT
由本机转发的报文：PREROUTING –> FORWARD –> POSTROUTING
由本机的某进程发出报文（通常为响应报文）：OUTPUT –> POSTROUTING
链 现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。
表 我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。
我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。
iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”
filter表：负责过滤功能，防火墙；内核模块：iptables_filter
nat表：network address translation，网络地址转换功能；内核模块：iptable_nat
mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle
raw表：关闭nat表上启用的连接追踪机制；iptable_raw
也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。
链和表的关系 我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。
那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。
我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。
这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。
根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，
或者说，每个”链”中的规则都存在于哪些”表”中。
PREROUTING 的规则可以存在于：raw表，mangle表，nat表。
INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。
FORWARD 的规则可以存在于：mangle表，filter表。
OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。
POSTROUTING 的规则可以存在于：mangle表，nat表。
我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。
prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：
raw –> mangle –> nat
但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。
优先级次序（由高而低）：
raw –> mangle –> nat –> filter
为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。"><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/iptables/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="iptables"><meta property="og:description" content="iptables 介绍 iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。
当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。
其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是
PREROUTING、FORWARD、POSTROUTING
也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。
根据上图，我们能够想象出某些常用场景中，报文的流向：
到本机某进程的报文：PREROUTING –> INPUT
由本机转发的报文：PREROUTING –> FORWARD –> POSTROUTING
由本机的某进程发出报文（通常为响应报文）：OUTPUT –> POSTROUTING
链 现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。
表 我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。
我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。
iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”
filter表：负责过滤功能，防火墙；内核模块：iptables_filter
nat表：network address translation，网络地址转换功能；内核模块：iptable_nat
mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle
raw表：关闭nat表上启用的连接追踪机制；iptable_raw
也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。
链和表的关系 我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。
那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。
我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。
这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。
根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，
或者说，每个”链”中的规则都存在于哪些”表”中。
PREROUTING 的规则可以存在于：raw表，mangle表，nat表。
INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。
FORWARD 的规则可以存在于：mangle表，filter表。
OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。
POSTROUTING 的规则可以存在于：mangle表，nat表。
我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。
prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：
raw –> mangle –> nat
但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。
优先级次序（由高而低）：
raw –> mangle –> nat –> filter
为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。"><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/iptables/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="iptables"><meta name=twitter:description content="iptables 介绍 iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。
当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。
其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是
PREROUTING、FORWARD、POSTROUTING
也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。
根据上图，我们能够想象出某些常用场景中，报文的流向：
到本机某进程的报文：PREROUTING –> INPUT
由本机转发的报文：PREROUTING –> FORWARD –> POSTROUTING
由本机的某进程发出报文（通常为响应报文）：OUTPUT –> POSTROUTING
链 现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。
表 我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。
我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。
iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”
filter表：负责过滤功能，防火墙；内核模块：iptables_filter
nat表：network address translation，网络地址转换功能；内核模块：iptable_nat
mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle
raw表：关闭nat表上启用的连接追踪机制；iptable_raw
也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。
链和表的关系 我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。
那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。
我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。
这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。
根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，
或者说，每个”链”中的规则都存在于哪些”表”中。
PREROUTING 的规则可以存在于：raw表，mangle表，nat表。
INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。
FORWARD 的规则可以存在于：mangle表，filter表。
OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。
POSTROUTING 的规则可以存在于：mangle表，nat表。
我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。
prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：
raw –> mangle –> nat
但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。
优先级次序（由高而低）：
raw –> mangle –> nat –> filter
为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"iptables","item":"https://moyuduo.github.io/posts/iptables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"iptables","name":"iptables","description":"iptables 介绍 iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。\n当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。\n其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是\nPREROUTING、FORWARD、POSTROUTING\n也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。\n根据上图，我们能够想象出某些常用场景中，报文的流向：\n到本机某进程的报文：PREROUTING –\u0026gt; INPUT\n由本机转发的报文：PREROUTING –\u0026gt; FORWARD –\u0026gt; POSTROUTING\n由本机的某进程发出报文（通常为响应报文）：OUTPUT –\u0026gt; POSTROUTING\n链 现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。\n表 我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。\n我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。\niptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”\nfilter表：负责过滤功能，防火墙；内核模块：iptables_filter\nnat表：network address translation，网络地址转换功能；内核模块：iptable_nat\nmangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle\nraw表：关闭nat表上启用的连接追踪机制；iptable_raw\n也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。\n链和表的关系 我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。\n那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。\n我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。\n这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。\n根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，\n或者说，每个”链”中的规则都存在于哪些”表”中。\nPREROUTING 的规则可以存在于：raw表，mangle表，nat表。\nINPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。\nFORWARD 的规则可以存在于：mangle表，filter表。\nOUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。\nPOSTROUTING 的规则可以存在于：mangle表，nat表。\n我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。\nprerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：\nraw –\u0026gt; mangle –\u0026gt; nat\n但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。\n优先级次序（由高而低）：\nraw –\u0026gt; mangle –\u0026gt; nat –\u0026gt; filter\n为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。","keywords":[],"articleBody":"iptables 介绍 iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。\n当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。\n其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是\nPREROUTING、FORWARD、POSTROUTING\n也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。\n根据上图，我们能够想象出某些常用场景中，报文的流向：\n到本机某进程的报文：PREROUTING –\u003e INPUT\n由本机转发的报文：PREROUTING –\u003e FORWARD –\u003e POSTROUTING\n由本机的某进程发出报文（通常为响应报文）：OUTPUT –\u003e POSTROUTING\n链 现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。\n表 我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。\n我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。\niptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”\nfilter表：负责过滤功能，防火墙；内核模块：iptables_filter\nnat表：network address translation，网络地址转换功能；内核模块：iptable_nat\nmangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle\nraw表：关闭nat表上启用的连接追踪机制；iptable_raw\n也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。\n链和表的关系 我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。\n那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。\n我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。\n这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。\n根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，\n或者说，每个”链”中的规则都存在于哪些”表”中。\nPREROUTING 的规则可以存在于：raw表，mangle表，nat表。\nINPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。\nFORWARD 的规则可以存在于：mangle表，filter表。\nOUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。\nPOSTROUTING 的规则可以存在于：mangle表，nat表。\n我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。\nprerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：\nraw –\u003e mangle –\u003e nat\n但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。\n优先级次序（由高而低）：\nraw –\u003e mangle –\u003e nat –\u003e filter\n为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。\n数据经过防火墙流程 链的规则存放于哪些表中（从链到表的对应关系）：\nPREROUTING 的规则可以存在于：raw表，mangle表，nat表。\nINPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。\nFORWARD 的规则可以存在于：mangle表，filter表。\nOUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。\nPOSTROUTING 的规则可以存在于：mangle表，nat表。\n表中的规则可以被哪些链使用（从表到链的对应关系）：\nraw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT\nmangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING\nnat 表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）\nfilter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT\n规则 规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理；\n那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条”链”都是一个”关卡”，每个通过这个”关卡”的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个”报文”，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的”规则”，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合”器宇轩昂”的标准，所以把你”放行”了，而我不符合标准，所以没有被放行，其实，”器宇轩昂”就是一种”匹配条件”，”放行”就是一种”动作”，”匹配条件”与”动作”组成了规则。\n规则由匹配条件和处理动作组成。\n匹配条件 匹配条件分为基本匹配条件与扩展匹配条件\n基本匹配：\n源地址Source IP，目标地址 Destination IP\n上述内容都可以作为基本匹配条件。\n扩展匹配：\n除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。\n源端口Source Port, 目标端口Destination Port\n上述内容都可以作为扩展匹配条件\n处理动作 处理动作在iptables中被称为target（这样说并不准确，我们暂且这样称呼），动作也可以分为基本动作和扩展动作。\n此处列出一些常用的动作，之后的文章会对它们进行详细的示例与总结：\nACCEPT：允许数据包通过。\nDROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。\nREJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。\nSNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。\nMASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。\nDNAT：目标地址转换。\nREDIRECT：在本机做端口映射。\nLOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。\n规则查询 查询filter表中的规则\n# -t参数指定要操作的表 # -L参数列出规则 # 如果是查询filter表中的规则可以省略-t filter 默认就是查询filter表 iptables -t filter -L 查询指定表中指定链上的规则\n# 查询指定链只需要在-L参数后指定链的名称即可，注意链的名字是大写的 # 使用-v参数显示更加详细的信息 # 使用-n参数把名称解析为ip，如anywhere =\u003e 0.0.0.0 # 使用--line-number显示规则的行号 iptables -t filter -nvL INPUT --line-number 规则管理 清空指定链的规则\n# 谨慎操作 iptables -F INPUT 添加规则\n# 使用-I参数指定向哪张表插入规则，默认会插入在表的第一行，也可以在表后指定要插入的行号 # 使用-s参数指定报文源地址,如果有多个ip可以用\",\"分隔开,除了可以指定ip还可以指定网段如：192.168.0.0/16 # 使用-d参数指定报文目的地址，用法和-s参数相同 # 使用-p参数来指定协议的类型， tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh # 当本机有多个网卡时，我们可以使用 -i 选项去匹配报文是通过哪块网卡流入本机的 # 可以使用-o选项，匹配报文将由哪块网卡流出，没错，-o选项与-i选项是相对的 # 使用-j参数指定动作 iptables -t filter -I INPUT 1 -s 192.168.37.131 -j REJECT #在192.168.37.131机器上ping本机 [root@centos72 ~]# ping 192.168.37.134 -c 1 PING 192.168.37.134 (192.168.37.134) 56(84) bytes of data. From 192.168.37.134 icmp_seq=1 Destination Port Unreachable --- 192.168.37.134 ping statistics --- 1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms # 使用-A参数也可以像表中插入规则，不过同-I参数不同的是-A参数把规则插入到表的末尾 iptables -t filter -A INPUT -s 192.168.37.131 -j REJECT # ！！！如果对同一地址具有两条规则，一条规则是拒绝规则在第一行，第二条规则是接受规则在第二行，那么在接受到该源地址的包时也不会处理，因为匹配到了第一条拒绝规则后执行拒绝动作就不会继续向下匹配规则 # 使用 -m tcp --dport 22指定匹配条件中的目标端口,-m参数指定使用哪个扩展模块，由于这里-p参数或-m参数的模块名相同，这里-m参数可以省略 iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m tcp --dport 22 -j REJECT #使用 -m tcp --sport xxx 指定匹配条件中的源端口 iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -sport 9999 -j REJECT #--dport或--sport也可以指定端口范围,但是不可以是离散的端口 如5001、6001、7001 iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -dport 5000:6000 -j REJECT #使用-m multiport参数可以指定--dport或--sport为离散的端口 iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m multiport --dport 5001,6001,7001 -j REJECT iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m multiport --dport 5001,6001,7001,8000:9000 -j REJECT #使用-m指定扩展模块iprange可以指定源地址或目的地址范围 iptables -t filter -I INPUT -m iprange --src-range 192.168.37.129-192.168.37.133 -j REJECT iptables -t filter -I INPUT -m iprange --dst-range 192.168.37.133-192.168.37.135 -j REJECT #使用-m指定扩展模块string可以过滤包含指定字符串的包 #--algo参数指定用于匹配字符串的算法，可选kmp或bm #--string指定过滤的字符串 iptables -t filter -I INPUT -m string --algo kmp --string xxoo -j REJECT #使用-m指定扩展模块time可以使用时间作为限制,如每天早上9点到下午6点不能看网页 #--timestart指定开始时间 #--timestop指定结束时间 iptables -t filter -I INPUT -m time --timestart=09:00:00 --timestop 18:00:00 -j REJECT #周六日不能看网页 iptables -t filter -I INPUT -m time --weekdays 6,7 -j REJECT #周六早上9点到下午6点不能看网页 iptables -t filter -I INPUT -m time --weekdays 6 --timestart=09:00:00 --timestop 18:00:00 -j REJECT #每月的22号，23号不能上网 iptables -t filter -I INPUT -m time --monthdays 22,23 -j REJECT #2020-10-1到2020-11-1日之间不能上网 iptables -t filter -I INPUT -m time --datestart 2020-10-1 --datestop 2020-11-1 -j REJECT #使用-m指定扩展模块connlimit，可以限制每个IP地址同时链接到server端的链接数量 #--connlimit-above参数指定同一IP最大连接数 iptables -t filter -I INPUT -p tcp --dport 5000 -m connlimit --connlimit-above 1 -j REJECT #使用-m指定扩展模块limit对”报文到达速率”进行限制，可以以秒为单位进行限制，可以对秒（second）、分钟（minute）、小时（hour）、天（day）作为单位进行限制 iptables -t filter -I INPUT -p icmp -m limit --limit 5/minute -j REJECT 删除规则\n# 使用-D参数来删除规则，可以在表后面指定要删除的具体是哪一行的规则 iptables -t filter -D INPUT 3 # 也可以按匹配条件和动作去删除规则 iptable -t filter -D INPUT -s 192.138.37.131 -j REJECT 修改规则\n#比如把一行的规则由REJECT改为DROP # 注意修改的时候也必须带上-s参数指定源地址，可以理解为-R参数是把原来的规则删除了再创建一条，如果不指定-s源地址那么默认就是0.0.0.0，会把所有地址的包都DROP iptables -t filter -R INPUT 1 -s 192.168.37.131 -j DROP 修改链的默认动作\n#使用-nvL参数我们可以看到链的默认动作，比如这里INPUT链的默认动作就是ACCEPT [root@localhost ~]# iptables -nvL INPUT Chain INPUT (policy ACCEPT 0 packets, 0 bytes) #使用-P参数来修改指定链的默认动作 ipatables -t filter -P INPUT DROP 保存规则 在默认的情况下，我们对”防火墙”所做出的修改都是”临时的”，换句话说就是，当重启iptables服务或者重启服务器以后，我们平常添加的规则或者对规则所做出的修改都将消失，为了防止这种情况的发生，我们需要将规则”保存”。\ncentos7中，已经不再使用init风格的脚本启动服务，而是使用unit文件，所以，在centos7中已经不能再使用类似service iptables start这样的命令了，所以service iptables save也无法执行，同时，在centos7中，使用firewall替代了原来的iptables service，不过不用担心，我们只要通过yum源安装iptables与iptables-services即可（iptables一般会被默认安装，但是iptables-services在centos7中一般不会被默认安装），在centos7中安装完iptables-services后，即可像centos6中一样，通过service iptables save命令保存规则了，规则同样保存在/etc/sysconfig/iptables文件中。\ncentos7中配置iptables-service的步骤：\n#配置好yum源以后安装iptables-service # yum install -y iptables-services #停止firewalld # systemctl stop firewalld #禁止firewalld自动启动 # systemctl disable firewalld #启动iptables # systemctl start iptables #将iptables设置为开机自动启动，以后即可通过iptables-service控制iptables服务 # systemctl enable iptables 上述配置过程只需一次，以后即可在centos7中愉快的使用service iptables save命令保存iptables规则了。\n自定义链 当默认链中的规则非常多时，不方便我们管理。想象一下，如果INPUT链中存放了200条规则，这200条规则有针对httpd服务的，有针对sshd服务的，有针对私网IP的，有针对公网IP的，假如，我们突然想要修改针对httpd服务的相关规则，难道我们还要从头看一遍这200条规则，找出哪些规则是针对httpd的吗？这显然不合理。所以，iptables中，可以自定义链，通过自定义链即可解决上述问题。\n假设，我们自定义一条链，链名叫IN_WEB，我们可以将所有针对80端口的入站规则都写入到这条自定义链中，当以后想要修改针对web服务的入站规则时，就直接修改IN_WEB链中的规则就好了，即使默认链中有再多的规则，我们也不会害怕了，因为我们知道，所有针对80端口的入站规则都存放在IN_WEB链中。\n但是需要注意的是，自定义链并不能直接使用，而是需要被默认链引用才能够使用。\n创建自定义链\n#使用-n参数指定要创建自定义链 iptables -t filter -N IN_WEB #查询创建的自定义链,可以看到自定义链未被任何默认链引用 iptables -t filter -nvL Chain IN_WEB (0 references) pkts bytes target prot opt in out source destination 向自定义链中插入规则\niptables -t filter -I IN_WEB -p tcp --dport 8080 -j REJECT iptables -t filter -I IN_WEB -p tcp --dport 9090 -j ACCEPT #查看自定义链中的规则,可以看到此时自定义链仍未被默认链引用，所以该链上的规则不生效 iptables -t filter -nvL IN_WEB Chain IN_WEB (0 references) pkts bytes target prot opt in out source destination 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:9090 0 0 REJECT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 reject-with icmp-port-unreachable 使用默认链引用自定义链\niptables -t filter -I INPUT -p tcp -m multiport --dport 8080,9090 -j IN_WEB #再次查看自定义链，此时可以看到自定义链就已经被默认链引用一次了 iptables -t filter -nvL IN_WEB Chain IN_WEB (1 references) pkts bytes target prot opt in out source destination 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:9090 0 0 REJECT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 reject-with icmp-port-unreachable 重命名自定义链\n#重命名 iptables -E IN_WEB WEB #查看 iptables -nvL ... Chain WEB (1 references) pkts bytes target prot opt in out source destination 5 272 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:9090 1 60 REJECT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 reject-with icmp-port-unreachable #查看原来在INPUT链中引用的自定义链，发现的名字也更新了 iptables -nvL INPUT Chain INPUT (policy ACCEPT 304 packets, 84228 bytes) pkts bytes target prot opt in out source destination 6 332 WEB tcp -- * * 0.0.0.0/0 0.0.0.0/0 multiport dports 8080,9090 删除自定义链\n#删除自定义链必须满足两个条件 # 1. 自定义链已经没有默认链引用了 # 2. 自定义链上已经没有任何规则了 #删除自定义链引用 iptables -D INPUT 1 #删除自定义链内的规则 iptables -F WEB #删除自定义链 iptables -X WEB 路由转发 环境：\n主机A和主机B在同一个网段，互相之间能够通信\ncontainer1是在主机B上起的docker容器，主机B能够与container1通信，主机A不能同container1通信\n现在要实现主机A能够与container1通信\n在主机A上添加路由，使得172.17.0.0/16网段的网关为主机B，那么访问该网段的包都会被发送到主机B\n#添加路由 route add -net 172.13.0.0/16 gw 192.168.37.134 #查看路由 route -n 在主机B上开启路由转发功能(默认是关闭的)，开启之后主机B会把接受到的访问172.17.0.0/16为目的地址的包通过docker0网卡转发到对应的容器\n#开启路由转发 echo \"1\" \u003e /proc/sys/net/ipv4/ip_forward #或 sysctl -w net.ipv4.ip_forward=1 #以上两种方法都是临时生效，要永久生效则需要设置/etc/sysctl.conf文件（centos7中配置/usr/lib/sysctl.d/00-system.conf文件），添加或修改net.ipv4.ip_forward = 1 测试访问\n#在主机A上测试ping ping 172.17.0.3 #测试tcp nc 172.17.0.3 5000 设置转发规则 经过以上配置后主机A可以访问container1是因为主机B上对转发没有做任何限制，默认转发了\n#在主机B上查看转发策略,可以看到没有任何限制并且默认也是ACCEPT [root@localhost ~]# iptables -nvL FORWARD Chain FORWARD (policy ACCEPT 6144 packets, 324K bytes) pkts bytes target prot opt in out source destination 使用白名单机制对转发规则进行限制\n#在filter表的FORWARD链末尾添加一条拒绝所有转发的规则，此时主机A不再能够访问container1 iptables -t filter -A FORWARD -j REJECT 在主机B上添加一条对目标端口8080转发ACCEPT的规则\niptables -t filter -I FORWARD -p tcp --dport 8080 -j ACCEPT 测试在主机A上访问container1,可以发现并不能建立连接，这是为什么呢？是因为我们只放行了外部到container1的8080端口的请求，并没有放行container1的回复包，所以TCP没办法建立连接\nnc 172.17.0.3 8080 在主机B上放行container1 8080端口回复包的转发\niptables -t filter -I FORWARD -p tcp --sport 8080 -j ACCEPT 再次在主机A上测试同container1通信，成功\nnc 172.17.0.3 8080 aaa AAA 从以上步骤中我们可以看到，每放行一个端口，不仅要放行对该端口的请求包，还要放行端口的回复包，需要配置两次，非常麻烦，有没有办法把所有回复包都放行？\niptables -t filter -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 动作 使用-j可以指定动作，比如\n-j ACCEPT\n-j DROP\n-j REJECT\n其实，”动作”也有自己的选项，我们可以在使用动作时，设置对应的选项\n###REJECT\nREJECT动作的常用选项为–reject-with，可以设置提示信息，当对方被拒绝时，会提示对方为什么被拒绝\n可用值如下\nicmp-net-unreachable\nicmp-host-unreachable\nicmp-port-unreachable,\nicmp-proto-unreachable\nicmp-net-prohibited\nicmp-host-pro-hibited\nicmp-admin-prohibited\n当不设置任何值时，默认值为icmp-port-unreachable。\n#查看,可以看到最后一条规则reject-with是icmp-port-unreachable iptable -nvL FORWARD Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 64 3340 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:9090 68 3548 ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 30 1578 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp spt:8080 41 2214 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 10 600 REJECT all -- * * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable #使用主机A ping container1,匹配到最后一条转发规则所以提示的信息是Destination Port Unreachable [root@centos72 ~]# ping 172.17.0.3 PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data. From 192.168.37.134 icmp_seq=1 Destination Port Unreachable From 192.168.37.134 icmp_seq=2 Destination Port Unreachable #给FORWARD链插入一条拒绝所有转发的规则reject-with设置成icmp-host-unreachable iptables -I FORWARD 5 -j REJECT --reject-with icmp-host-unreachable #再次在主机A上ping container1,可以看到这次的提示信息就是Destination Host Unreachable了 [root@centos72 ~]# ping 172.17.0.3 PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data. From 192.168.37.134 icmp_seq=1 Destination Host Unreachable From 192.168.37.134 icmp_seq=2 Destination Host Unreachable SNAT 环境：\n主机A具有公网IP(使用192.168.37.131模拟),提供web服务\n主机B具有公网IP(使用192.168.37.134模拟)并且具有内网IP(172.17.0.1),为边界路由器\ncontainer1是内网主机，具有私网IP(172.17.0.3)，为内网中的一个用户，该用户需要访问外网的主机A\n在主机B上配置SNAT使得内网主机container1能够访问公网主机A上提供的服务\n确保主机B sysctl -w net.ipv4.ip_forward=1并且filter表FORWARD链中的规则是空的并且默认动作是ACCEPT，此时主机container1不能访问主机A\n[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1 net.ipv4.ip_forward = 1 [root@localhost ~]# iptables -nvL FORWARD Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 在主机B上添加SNAT规则\n# --to-source表示将过滤到的包的源IP修改为192.168.37.134 iptables -t nat -A POSTROUTING -s 172.17.0.0/16 -j SNAT --to-source 192.168.37.134 在主机container1上访问主机A的服务\n#主机container1上执行,成功返回了内容 curl 192.168.37.131:8080 HELLO WORLD 查看主机A上服务的日志信息,可以看到记录的日志信息获取到的请求的源地址是192.168.37.134也就是主机B，至此主机B已经成功完成了对cotainer1主机请求的SNAT装换\n[root@centos72 ~]# ./echo-server -p http http server will listen on port: 8080 receive http request from 192.168.37.134:35816 DNAT 公司只有一个公网IP，但是公司的内网中却有很多服务器提供各种服务，我们想要通过公网访问这些服务，改怎么办呢？\n我们对外宣称，公司的公网IP上既提供了web服务，也提供了mysql，不管是访问web服务还是mysql，只要访问这个公网IP就行了，我们利用DNAT，将公网客户端发送过来的报文的目标地址与端口号做了映射，将访问web服务的报文转发到了内网中的container1主机中，将访问远程桌面的报文转发到了内网中的container2主机中\n环境：\n主机A为公网IP(使用192.168.37.131模拟)可以通主机B通信\n主机B具有两块网卡，一块IP为192.168.37.134可以通主机A通信，一块IP为172.17.0.1为内网IP，可以通container1、continer2通信\ncontainer1的IP为172.17.0.3，机器上部署有http服务\ncontainer2的IP为172.17.0.4，机器上部署有mysql\n要达到的效果为访问主机B的IP：8080端口可以访问到container1上部署的http服务，使用主机B的IP：3306可以访问到container2上部署的mysql\n在主机B上配置DNAT使得访问主机B上8080端口的包转发到container1，访问主机B上3306端口的包转发到container2上\n# --to-destination表示把过滤到的包的IP和port改为指定的 iptables -t nat -I PREROUTING -d 192.168.37.134 -p tcp --dport 8080 -j DNAT --to-destination 172.17.0.3:8080 iptables -t nat -I PREROUTING -d 192.168.37.134 -p tcp --dport 3306 -j DNAT --to-destination 172.17.0.4:3306 在主机A上测试访问主机B的IP的8080和3306端口,可以发现http服务和mysql都成功了，并且配置完DNAT也不用再配置SNAT了\ncurl 192.168.37.134:8080 HELLO WORLD mysql -h 192.168.37.134 -P 3306 -u root -p Enter password: ###MASQUERADE\n当我们拨号网上时，每次分配的IP地址往往不同，不会长期分给我们一个固定的IP地址，如果这时，我们想要让内网主机共享公网IP上网，就会很麻烦，因为每次IP地址发生变化以后，我们都要重新配置SNAT规则，这样显示不是很人性化，我们通过MASQUERADE即可解决这个问题，MASQUERADE会动态的将源地址转换为可用的IP地址，其实与SNAT实现的功能完全一致，都是修改源地址，只不过SNAT需要指明将报文的源地址改为哪个IP，而MASQUERADE则不用指定明确的IP，会动态的将报文的源地址修改为指定网卡上可用的IP地址\n环境：\n主机A的IP为192.168.37.131能够通主机B通信\n主机B具有两块网卡，一块的IP是192.168.37.134能够同主机A通信，一块的IP为172.17.0.1能够同container1通信\ncontainer1的IP为172.17.0.3能够同主机B通信\n目标：在主机B上配置MASQUERADE使得container1能够访问主机A上的http服务\n在主机B上配置MASQUERADE\niptables -t nat -I POSTROUTING -s 172.17.0.0/16 -o ens33 -j MASQUERADE 在container1上访问主机A的http服务\nHELLO WORLD 在主机A上查看http服务的日志,可以看到container1上的请求确实是经过了主机B代理\n[root@centos72 ~]# ./echo-server -p http http server will listen on port: 8080 receive http request from 192.168.37.134:43418 REDIRECT 使用REDIRECT动作可以在本机上进行端口映射\n将本机的80端口映射到本机的8080端口上\niptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080 在本机上测试访问,不能访问\ncurl 127.0.0.1 在同一局域网的其他主机访问，可以\t??? curl 192.168.37.134 HELLO WORLD 总结 规则的顺序非常重要\n如果报文已经被前面的规则匹配到，IPTABLES则会对报文执行对应的动作，通常是ACCEPT或者REJECT，报文被放行或拒绝以后，即使后面的规则也能匹配到刚才放行或拒绝的报文，也没有机会再对报文执行相应的动作了（前面规则的动作为LOG时除外），所以，针对相同服务的规则，更严格的规则应该放在前面\n当规则中有多个匹配条件时，条件之间默认存在”与”的关系\n如果一条规则中包含了多个匹配条件，那么报文必须同时满足这个规则中的所有匹配条件，报文才能被这条规则匹配到\n在不考虑1的情况下，应该将更容易被匹配到的规则放置在前面\n比如，你写了两条规则，一条针对sshd服务，一条针对web服务。\n假设，一天之内，有20000个请求访问web服务，有200个请求访问sshd服务，\n那么，应该将针对web服务的规则放在前面，针对sshd的规则放在后面，因为访问web服务的请求频率更高。\n如果将sshd的规则放在前面，当报文是访问web服务时，sshd的规则也要白白的验证一遍，由于访问web服务的频率更高，白白耗费的资源就更多。\n如果web服务的规则放在前面，由于访问web服务的频率更高，所以无用功会比较少。\n换句话说就是，在没有顺序要求的情况下，不同类别的规则，被匹配次数多的、匹配频率高的规则应该放在前面\n当IPTABLES所在主机作为网络防火 墙时，在配置规则时，应着重考虑方向性，双向都要考虑，从外到内，从内到外\n在配置IPTABLES白名单时，往往会将链的默认策略设置为ACCEPT，通过在链的最后设置REJECT规则实现白名单机制，而不是将链的默认策略设置为DROP，如果将链的默认策略设置为DROP，当链中的规则被清空时，管理员的请求也将会被DROP掉\n","wordCount":"1311","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/iptables/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://moyuduo.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://moyuduo.github.io/posts/>Posts</a></div><h1 class=post-title>iptables</h1><div class=post-meta><span title='2022-11-27 16:16:14 +0800 +0800'>November 27, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1311 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/iptables.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=iptables>iptables<a hidden class=anchor aria-hidden=true href=#iptables>#</a></h1><h2 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h2><p>iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p><p>当客户端访问服务器的web服务时，客户端发送报文到网卡，而tcp/ip协议栈是属于内核的一部分，所以，客户端的信息会通过内核的TCP协议传输到用户空间中的web服务中，而此时，客户端报文的目标终点为web服务所监听的套接字（IP：Port）上，当web服务需要响应客户端请求时，web服务发出的响应报文的目标终点则为客户端，这个时候，web服务所监听的IP与端口反而变成了原点，我们说过，netfilter才是真正的防火墙，它是内核的一部分，所以，如果我们想要防火墙能够达到”防火”的目的，则需要在内核中设置关卡，所有进出的报文都要通过这些关卡，经过检查后，符合放行条件的才能放行，符合阻拦条件的则需要被阻止，于是，就出现了input关卡和output关卡，而这些关卡在iptables中不被称为”关卡”,而被称为”链”。</p><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-26-17.jpg alt></p><p>其实我们上面描述的场景并不完善，因为客户端发来的报文访问的目标地址可能并不是本机，而是其他服务器，当本机的内核支持IP_FORWARD时，我们可以将报文转发给其他服务器，所以，这个时候，我们就会提到iptables中的其他”关卡”，也就是其他”链”，他们就是 “路由前”、”转发”、”路由后”，他们的英文名是</p><p>PREROUTING、FORWARD、POSTROUTING</p><p>也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，也就是说，根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。</p><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-27-53.jpg alt></p><p>根据上图，我们能够想象出某些常用场景中，报文的流向：</p><p>到本机某进程的报文：PREROUTING –> INPUT</p><p>由本机转发的报文：PREROUTING –> FORWARD –> POSTROUTING</p><p>由本机的某进程发出报文（通常为响应报文）：OUTPUT –> POSTROUTING</p><h3 id=链>链<a hidden class=anchor aria-hidden=true href=#链>#</a></h3><p>现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。</p><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-29-04.jpg alt></p><h3 id=表>表<a hidden class=anchor aria-hidden=true href=#表>#</a></h3><p>我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。</p><p>我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。</p><p>iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”</p><p>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</p><p>nat表：network address translation，网络地址转换功能；内核模块：iptable_nat</p><p>mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle</p><p>raw表：关闭nat表上启用的连接追踪机制；iptable_raw</p><p>也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。</p><h3 id=链和表的关系>链和表的关系<a hidden class=anchor aria-hidden=true href=#链和表的关系>#</a></h3><p>我们需要注意的是，某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。</p><p>那让我们来看看，每个”关卡”都有哪些能力，或者说，让我们看看每个”链”上的规则都存在于哪些”表”中。</p><p>我们还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。</p><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-30-33.jpg alt></p><p>这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。</p><p>根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能，</p><p>或者说，每个”链”中的规则都存在于哪些”表”中。</p><p>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</p><p>INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</p><p>FORWARD 的规则可以存在于：mangle表，filter表。</p><p>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</p><p>POSTROUTING 的规则可以存在于：mangle表，nat表。</p><p>我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。</p><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-33-44.jpg alt></p><p>prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：</p><p>raw –> mangle –> nat</p><p>但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下。</p><p>优先级次序（由高而低）：</p><p>raw –> mangle –> nat –> filter</p><p>为了更方便的管理，我们还可以在某个表里面创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，只能被某个默认的链当做动作去调用才能起作用，我们可以这样想象，自定义链就是一段比较”短”的链子，这条”短”链子上的规则都是针对某个应用程序制定的，但是这条短的链子并不能直接使用，而是需要”焊接”在iptables默认定义链子上，才能被IPtables使用，这就是为什么默认定义的”链”需要把”自定义链”当做”动作”去引用的原因。</p><h3 id=数据经过防火墙流程>数据经过防火墙流程<a hidden class=anchor aria-hidden=true href=#数据经过防火墙流程>#</a></h3><p><img loading=lazy src=./images/Snipaste_2021-11-13_11-36-40.jpg alt></p><p>链的规则存放于哪些表中（从链到表的对应关系）：</p><p>PREROUTING 的规则可以存在于：raw表，mangle表，nat表。</p><p>INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。</p><p>FORWARD 的规则可以存在于：mangle表，filter表。</p><p>OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。</p><p>POSTROUTING 的规则可以存在于：mangle表，nat表。</p><p>表中的规则可以被哪些链使用（从表到链的对应关系）：</p><p>raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT</p><p>mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</p><p>nat 表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）</p><p>filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT</p><h3 id=规则>规则<a hidden class=anchor aria-hidden=true href=#规则>#</a></h3><p>规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理；</p><p>那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条”链”都是一个”关卡”，每个通过这个”关卡”的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个”报文”，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的”规则”，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合”器宇轩昂”的标准，所以把你”放行”了，而我不符合标准，所以没有被放行，其实，”器宇轩昂”就是一种”匹配条件”，”放行”就是一种”动作”，”匹配条件”与”动作”组成了规则。</p><p>规则由匹配条件和处理动作组成。</p><h4 id=匹配条件>匹配条件<a hidden class=anchor aria-hidden=true href=#匹配条件>#</a></h4><p>匹配条件分为基本匹配条件与扩展匹配条件</p><p>基本匹配：</p><p>源地址Source IP，目标地址 Destination IP</p><p>上述内容都可以作为基本匹配条件。</p><p>扩展匹配：</p><p>除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。</p><p>源端口Source Port, 目标端口Destination Port</p><p>上述内容都可以作为扩展匹配条件</p><h4 id=处理动作>处理动作<a hidden class=anchor aria-hidden=true href=#处理动作>#</a></h4><p>处理动作在iptables中被称为target（这样说并不准确，我们暂且这样称呼），动作也可以分为基本动作和扩展动作。</p><p>此处列出一些常用的动作，之后的文章会对它们进行详细的示例与总结：</p><p><strong>ACCEPT</strong>：允许数据包通过。</p><p><strong>DROP</strong>：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</p><p><strong>REJECT</strong>：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</p><p><strong>SNAT</strong>：源地址转换，解决内网用户用同一个公网地址上网的问题。</p><p><strong>MASQUERADE</strong>：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</p><p><strong>DNAT</strong>：目标地址转换。</p><p><strong>REDIRECT</strong>：在本机做端口映射。</p><p><strong>LOG</strong>：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</p><h2 id=规则查询>规则查询<a hidden class=anchor aria-hidden=true href=#规则查询>#</a></h2><ul><li><p>查询filter表中的规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># -t参数指定要操作的表</span>
</span></span><span class=line><span class=cl><span class=c1># -L参数列出规则</span>
</span></span><span class=line><span class=cl><span class=c1># 如果是查询filter表中的规则可以省略-t filter 默认就是查询filter表</span>
</span></span><span class=line><span class=cl>iptables -t filter -L 
</span></span></code></pre></div></li><li><p>查询指定表中指定链上的规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 查询指定链只需要在-L参数后指定链的名称即可，注意链的名字是大写的</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-v参数显示更加详细的信息</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-n参数把名称解析为ip，如anywhere =&gt; 0.0.0.0</span>
</span></span><span class=line><span class=cl><span class=c1># 使用--line-number显示规则的行号</span>
</span></span><span class=line><span class=cl>iptables -t filter -nvL INPUT --line-number
</span></span></code></pre></div></li></ul><h2 id=规则管理>规则管理<a hidden class=anchor aria-hidden=true href=#规则管理>#</a></h2><ul><li><p>清空指定链的规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 谨慎操作</span>
</span></span><span class=line><span class=cl>iptables -F INPUT
</span></span></code></pre></div></li><li><p>添加规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 使用-I参数指定向哪张表插入规则，默认会插入在表的第一行，也可以在表后指定要插入的行号</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-s参数指定报文源地址,如果有多个ip可以用&#34;,&#34;分隔开,除了可以指定ip还可以指定网段如：192.168.0.0/16</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-d参数指定报文目的地址，用法和-s参数相同</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-p参数来指定协议的类型， tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh</span>
</span></span><span class=line><span class=cl><span class=c1># 当本机有多个网卡时，我们可以使用 -i 选项去匹配报文是通过哪块网卡流入本机的</span>
</span></span><span class=line><span class=cl><span class=c1># 可以使用-o选项，匹配报文将由哪块网卡流出，没错，-o选项与-i选项是相对的</span>
</span></span><span class=line><span class=cl><span class=c1># 使用-j参数指定动作</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT <span class=m>1</span> -s 192.168.37.131 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#在192.168.37.131机器上ping本机</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos72 ~<span class=o>]</span><span class=c1># ping 192.168.37.134 -c 1</span>
</span></span><span class=line><span class=cl>PING 192.168.37.134 <span class=o>(</span>192.168.37.134<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.
</span></span><span class=line><span class=cl>From 192.168.37.134 <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> Destination Port Unreachable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--- 192.168.37.134 ping statistics ---
</span></span><span class=line><span class=cl><span class=m>1</span> packets transmitted, <span class=m>0</span> received, +1 errors, 100% packet loss, <span class=nb>time</span> 0ms
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用-A参数也可以像表中插入规则，不过同-I参数不同的是-A参数把规则插入到表的末尾</span>
</span></span><span class=line><span class=cl>iptables -t filter -A INPUT -s 192.168.37.131 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ！！！如果对同一地址具有两条规则，一条规则是拒绝规则在第一行，第二条规则是接受规则在第二行，那么在接受到该源地址的包时也不会处理，因为匹配到了第一条拒绝规则后执行拒绝动作就不会继续向下匹配规则</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 -m tcp --dport 22指定匹配条件中的目标端口,-m参数指定使用哪个扩展模块，由于这里-p参数或-m参数的模块名相同，这里-m参数可以省略</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m tcp --dport <span class=m>22</span> -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用 -m tcp --sport xxx 指定匹配条件中的源端口</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -sport <span class=m>9999</span> -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--dport或--sport也可以指定端口范围,但是不可以是离散的端口 如5001、6001、7001</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -dport 5000:6000 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m multiport参数可以指定--dport或--sport为离散的端口</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m multiport --dport 5001,6001,7001 -j REJECT
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -s 192.168.37.131 -p tcp -m multiport --dport 5001,6001,7001,8000:9000 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m指定扩展模块iprange可以指定源地址或目的地址范围</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m iprange --src-range 192.168.37.129-192.168.37.133 -j REJECT
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m iprange --dst-range 192.168.37.133-192.168.37.135 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m指定扩展模块string可以过滤包含指定字符串的包</span>
</span></span><span class=line><span class=cl><span class=c1>#--algo参数指定用于匹配字符串的算法，可选kmp或bm</span>
</span></span><span class=line><span class=cl><span class=c1>#--string指定过滤的字符串</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m string --algo kmp --string xxoo -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m指定扩展模块time可以使用时间作为限制,如每天早上9点到下午6点不能看网页</span>
</span></span><span class=line><span class=cl><span class=c1>#--timestart指定开始时间</span>
</span></span><span class=line><span class=cl><span class=c1>#--timestop指定结束时间</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m <span class=nb>time</span> --timestart<span class=o>=</span>09:00:00 --timestop 18:00:00 -j REJECT
</span></span><span class=line><span class=cl><span class=c1>#周六日不能看网页</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m <span class=nb>time</span> --weekdays 6,7 -j REJECT
</span></span><span class=line><span class=cl><span class=c1>#周六早上9点到下午6点不能看网页</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m <span class=nb>time</span> --weekdays <span class=m>6</span> --timestart<span class=o>=</span>09:00:00 --timestop 18:00:00 -j REJECT
</span></span><span class=line><span class=cl><span class=c1>#每月的22号，23号不能上网</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m <span class=nb>time</span> --monthdays 22,23 -j REJECT
</span></span><span class=line><span class=cl><span class=c1>#2020-10-1到2020-11-1日之间不能上网</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -m <span class=nb>time</span> --datestart 2020-10-1 --datestop 2020-11-1 -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m指定扩展模块connlimit，可以限制每个IP地址同时链接到server端的链接数量</span>
</span></span><span class=line><span class=cl><span class=c1>#--connlimit-above参数指定同一IP最大连接数</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -p tcp --dport <span class=m>5000</span> -m connlimit --connlimit-above <span class=m>1</span> -j REJECT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-m指定扩展模块limit对”报文到达速率”进行限制，可以以秒为单位进行限制，可以对秒（second）、分钟（minute）、小时（hour）、天（day）作为单位进行限制</span>
</span></span><span class=line><span class=cl>iptables -t filter -I INPUT -p icmp -m limit --limit 5/minute -j REJECT
</span></span></code></pre></div></li><li><p>删除规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 使用-D参数来删除规则，可以在表后面指定要删除的具体是哪一行的规则</span>
</span></span><span class=line><span class=cl>iptables -t filter -D INPUT <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 也可以按匹配条件和动作去删除规则</span>
</span></span><span class=line><span class=cl>iptable -t filter -D INPUT -s 192.138.37.131 -j REJECT
</span></span></code></pre></div></li><li><p>修改规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#比如把一行的规则由REJECT改为DROP</span>
</span></span><span class=line><span class=cl><span class=c1># 注意修改的时候也必须带上-s参数指定源地址，可以理解为-R参数是把原来的规则删除了再创建一条，如果不指定-s源地址那么默认就是0.0.0.0，会把所有地址的包都DROP</span>
</span></span><span class=line><span class=cl>iptables -t filter -R INPUT <span class=m>1</span> -s 192.168.37.131 -j DROP
</span></span></code></pre></div></li><li><p>修改链的默认动作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#使用-nvL参数我们可以看到链的默认动作，比如这里INPUT链的默认动作就是ACCEPT</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># iptables -nvL INPUT</span>
</span></span><span class=line><span class=cl>Chain INPUT <span class=o>(</span>policy ACCEPT <span class=m>0</span> packets, <span class=m>0</span> bytes<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用-P参数来修改指定链的默认动作</span>
</span></span><span class=line><span class=cl>ipatables -t filter -P INPUT DROP
</span></span></code></pre></div></li></ul><h2 id=保存规则>保存规则<a hidden class=anchor aria-hidden=true href=#保存规则>#</a></h2><p>在默认的情况下，我们对”防火墙”所做出的修改都是”临时的”，换句话说就是，当重启iptables服务或者重启服务器以后，我们平常添加的规则或者对规则所做出的修改都将消失，为了防止这种情况的发生，我们需要将规则”保存”。</p><p><strong>centos7中</strong>，已经不再使用init风格的脚本启动服务，而是使用unit文件，所以，在centos7中已经不能再使用类似service iptables start这样的命令了，所以service iptables save也无法执行，同时，在centos7中，使用firewall替代了原来的iptables service，不过不用担心，我们只要通过yum源安装iptables与iptables-services即可（iptables一般会被默认安装，但是iptables-services在centos7中一般不会被默认安装），在centos7中安装完iptables-services后，即可像centos6中一样，通过service iptables save命令保存规则了，规则同样保存在/etc/sysconfig/iptables文件中。</p><p>centos7中配置iptables-service的步骤：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#配置好yum源以后安装iptables-service</span>
</span></span><span class=line><span class=cl><span class=c1># yum install -y iptables-services</span>
</span></span><span class=line><span class=cl><span class=c1>#停止firewalld</span>
</span></span><span class=line><span class=cl><span class=c1># systemctl stop firewalld</span>
</span></span><span class=line><span class=cl><span class=c1>#禁止firewalld自动启动</span>
</span></span><span class=line><span class=cl><span class=c1># systemctl disable firewalld</span>
</span></span><span class=line><span class=cl><span class=c1>#启动iptables</span>
</span></span><span class=line><span class=cl><span class=c1># systemctl start iptables</span>
</span></span><span class=line><span class=cl><span class=c1>#将iptables设置为开机自动启动，以后即可通过iptables-service控制iptables服务</span>
</span></span><span class=line><span class=cl><span class=c1># systemctl enable iptables</span>
</span></span></code></pre></div><p>上述配置过程只需一次，以后即可在centos7中愉快的使用service iptables save命令保存iptables规则了。</p><h2 id=自定义链>自定义链<a hidden class=anchor aria-hidden=true href=#自定义链>#</a></h2><p>当默认链中的规则非常多时，不方便我们管理。想象一下，如果INPUT链中存放了200条规则，这200条规则有针对httpd服务的，有针对sshd服务的，有针对私网IP的，有针对公网IP的，假如，我们突然想要修改针对httpd服务的相关规则，难道我们还要从头看一遍这200条规则，找出哪些规则是针对httpd的吗？这显然不合理。所以，iptables中，可以自定义链，通过自定义链即可解决上述问题。</p><p>假设，我们自定义一条链，链名叫IN_WEB，我们可以将所有针对80端口的入站规则都写入到这条自定义链中，当以后想要修改针对web服务的入站规则时，就直接修改IN_WEB链中的规则就好了，即使默认链中有再多的规则，我们也不会害怕了，因为我们知道，所有针对80端口的入站规则都存放在IN_WEB链中。</p><p>但是需要注意的是，自定义链并不能直接使用，而是需要被默认链引用才能够使用。</p><ul><li><p>创建自定义链</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#使用-n参数指定要创建自定义链</span>
</span></span><span class=line><span class=cl>iptables -t filter -N IN_WEB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查询创建的自定义链,可以看到自定义链未被任何默认链引用</span>
</span></span><span class=line><span class=cl>iptables -t filter -nvL
</span></span><span class=line><span class=cl>Chain IN_WEB <span class=o>(</span><span class=m>0</span> references<span class=o>)</span>
</span></span><span class=line><span class=cl>pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination 
</span></span></code></pre></div></li><li><p>向自定义链中插入规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t filter -I IN_WEB -p tcp --dport <span class=m>8080</span> -j REJECT
</span></span><span class=line><span class=cl>iptables -t filter -I IN_WEB -p tcp --dport <span class=m>9090</span> -j ACCEPT
</span></span><span class=line><span class=cl><span class=c1>#查看自定义链中的规则,可以看到此时自定义链仍未被默认链引用，所以该链上的规则不生效</span>
</span></span><span class=line><span class=cl>iptables -t filter -nvL IN_WEB
</span></span><span class=line><span class=cl>Chain IN_WEB <span class=o>(</span><span class=m>0</span> references<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination         
</span></span><span class=line><span class=cl>    <span class=m>0</span>     <span class=m>0</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:9090
</span></span><span class=line><span class=cl>    <span class=m>0</span>     <span class=m>0</span> REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 reject-with icmp-port-unreachable
</span></span></code></pre></div></li><li><p>使用默认链引用自定义链</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t filter -I INPUT -p tcp -m multiport --dport 8080,9090 -j IN_WEB
</span></span><span class=line><span class=cl><span class=c1>#再次查看自定义链，此时可以看到自定义链就已经被默认链引用一次了</span>
</span></span><span class=line><span class=cl>iptables -t filter -nvL IN_WEB
</span></span><span class=line><span class=cl>Chain IN_WEB <span class=o>(</span><span class=m>1</span> references<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination         
</span></span><span class=line><span class=cl>    <span class=m>0</span>     <span class=m>0</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:9090
</span></span><span class=line><span class=cl>    <span class=m>0</span>     <span class=m>0</span> REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 reject-with icmp-port-unreachable
</span></span></code></pre></div></li><li><p>重命名自定义链</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#重命名</span>
</span></span><span class=line><span class=cl>iptables -E IN_WEB WEB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看</span>
</span></span><span class=line><span class=cl>iptables -nvL
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>Chain WEB <span class=o>(</span><span class=m>1</span> references<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination         
</span></span><span class=line><span class=cl>    <span class=m>5</span>   <span class=m>272</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:9090
</span></span><span class=line><span class=cl>    <span class=m>1</span>    <span class=m>60</span> REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 reject-with icmp-port-unreachable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看原来在INPUT链中引用的自定义链，发现的名字也更新了</span>
</span></span><span class=line><span class=cl>iptables -nvL INPUT
</span></span><span class=line><span class=cl>Chain INPUT <span class=o>(</span>policy ACCEPT <span class=m>304</span> packets, <span class=m>84228</span> bytes<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination         
</span></span><span class=line><span class=cl>    <span class=m>6</span>   <span class=m>332</span> WEB        tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 8080,9090
</span></span></code></pre></div></li><li><p>删除自定义链</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#删除自定义链必须满足两个条件</span>
</span></span><span class=line><span class=cl><span class=c1># 1. 自定义链已经没有默认链引用了</span>
</span></span><span class=line><span class=cl><span class=c1># 2. 自定义链上已经没有任何规则了</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除自定义链引用</span>
</span></span><span class=line><span class=cl>iptables -D INPUT <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除自定义链内的规则</span>
</span></span><span class=line><span class=cl>iptables -F WEB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除自定义链</span>
</span></span><span class=line><span class=cl>iptables -X WEB
</span></span></code></pre></div></li></ul><h2 id=路由转发>路由转发<a hidden class=anchor aria-hidden=true href=#路由转发>#</a></h2><p>环境：</p><p><img loading=lazy src=./images/%e8%b7%af%e7%94%b1%e8%bd%ac%e5%8f%91.jpg alt></p><p>主机A和主机B在同一个网段，互相之间能够通信</p><p>container1是在主机B上起的docker容器，主机B能够与container1通信，主机A不能同container1通信</p><p>现在要实现主机A能够与container1通信</p><ol><li><p>在主机A上添加路由，使得172.17.0.0/16网段的网关为主机B，那么访问该网段的包都会被发送到主机B</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#添加路由</span>
</span></span><span class=line><span class=cl>route add -net 172.13.0.0/16 gw 192.168.37.134
</span></span><span class=line><span class=cl><span class=c1>#查看路由</span>
</span></span><span class=line><span class=cl>route -n
</span></span></code></pre></div></li><li><p>在主机B上开启路由转发功能(默认是关闭的)，开启之后主机B会把接受到的访问172.17.0.0/16为目的地址的包通过docker0网卡转发到对应的容器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#开启路由转发</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;1&#34;</span> &gt; /proc/sys/net/ipv4/ip_forward
</span></span><span class=line><span class=cl><span class=c1>#或</span>
</span></span><span class=line><span class=cl>sysctl -w net.ipv4.ip_forward<span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#以上两种方法都是临时生效，要永久生效则需要设置/etc/sysctl.conf文件（centos7中配置/usr/lib/sysctl.d/00-system.conf文件），添加或修改net.ipv4.ip_forward = 1</span>
</span></span></code></pre></div></li><li><p>测试访问</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#在主机A上测试ping</span>
</span></span><span class=line><span class=cl>ping 172.17.0.3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#测试tcp</span>
</span></span><span class=line><span class=cl>nc 172.17.0.3 <span class=m>5000</span>
</span></span></code></pre></div></li></ol><h3 id=设置转发规则>设置转发规则<a hidden class=anchor aria-hidden=true href=#设置转发规则>#</a></h3><p>经过以上配置后主机A可以访问container1是因为主机B上对转发没有做任何限制，默认转发了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#在主机B上查看转发策略,可以看到没有任何限制并且默认也是ACCEPT</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># iptables -nvL FORWARD</span>
</span></span><span class=line><span class=cl>Chain FORWARD <span class=o>(</span>policy ACCEPT <span class=m>6144</span> packets, 324K bytes<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination
</span></span></code></pre></div><p>使用白名单机制对转发规则进行限制</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#在filter表的FORWARD链末尾添加一条拒绝所有转发的规则，此时主机A不再能够访问container1</span>
</span></span><span class=line><span class=cl>iptables -t filter -A FORWARD -j REJECT
</span></span></code></pre></div><p>在主机B上添加一条对目标端口8080转发ACCEPT的规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t filter -I FORWARD -p tcp --dport <span class=m>8080</span> -j ACCEPT
</span></span></code></pre></div><p>测试在主机A上访问container1,可以发现并不能建立连接，这是为什么呢？<strong>是因为我们只放行了外部到container1的8080端口的请求，并没有放行container1的回复包，所以TCP没办法建立连接</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nc 172.17.0.3 <span class=m>8080</span>
</span></span></code></pre></div><p>在主机B上放行container1 8080端口回复包的转发</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t filter -I FORWARD -p tcp --sport <span class=m>8080</span> -j ACCEPT
</span></span></code></pre></div><p>再次在主机A上测试同container1通信，成功</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nc 172.17.0.3 <span class=m>8080</span>
</span></span><span class=line><span class=cl>aaa
</span></span><span class=line><span class=cl>AAA
</span></span></code></pre></div><p>从以上步骤中我们可以看到，每放行一个端口，不仅要放行对该端口的请求包，还要放行端口的回复包，需要配置两次，非常麻烦，有没有办法把所有回复包都放行？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t filter -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
</span></span></code></pre></div><h2 id=动作>动作<a hidden class=anchor aria-hidden=true href=#动作>#</a></h2><p>使用-j可以指定动作，比如</p><p>-j ACCEPT</p><p>-j DROP</p><p>-j REJECT</p><p>其实，”动作”也有自己的选项，我们可以在使用动作时，设置对应的选项</p><p>###REJECT</p><p>REJECT动作的常用选项为–reject-with，可以设置提示信息，当对方被拒绝时，会提示对方为什么被拒绝</p><p>可用值如下</p><p>icmp-net-unreachable</p><p>icmp-host-unreachable</p><p>icmp-port-unreachable,</p><p>icmp-proto-unreachable</p><p>icmp-net-prohibited</p><p>icmp-host-pro-hibited</p><p>icmp-admin-prohibited</p><p>当不设置任何值时，默认值为icmp-port-unreachable。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看,可以看到最后一条规则reject-with是icmp-port-unreachable</span>
</span></span><span class=line><span class=cl>iptable -nvL FORWARD
</span></span><span class=line><span class=cl>Chain FORWARD <span class=o>(</span>policy ACCEPT <span class=m>0</span> packets, <span class=m>0</span> bytes<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination         
</span></span><span class=line><span class=cl>   <span class=m>64</span>  <span class=m>3340</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:9090
</span></span><span class=line><span class=cl>   <span class=m>68</span>  <span class=m>3548</span> ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
</span></span><span class=line><span class=cl>   <span class=m>30</span>  <span class=m>1578</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp spt:8080
</span></span><span class=line><span class=cl>   <span class=m>41</span>  <span class=m>2214</span> ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080
</span></span><span class=line><span class=cl>   <span class=m>10</span>   <span class=m>600</span> REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-port-unreachable
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl><span class=c1>#使用主机A ping container1,匹配到最后一条转发规则所以提示的信息是Destination Port Unreachable</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos72 ~<span class=o>]</span><span class=c1># ping 172.17.0.3</span>
</span></span><span class=line><span class=cl>PING 172.17.0.3 <span class=o>(</span>172.17.0.3<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.
</span></span><span class=line><span class=cl>From 192.168.37.134 <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> Destination Port Unreachable
</span></span><span class=line><span class=cl>From 192.168.37.134 <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>2</span> Destination Port Unreachable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#给FORWARD链插入一条拒绝所有转发的规则reject-with设置成icmp-host-unreachable</span>
</span></span><span class=line><span class=cl>iptables -I FORWARD <span class=m>5</span> -j REJECT --reject-with icmp-host-unreachable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#再次在主机A上ping container1,可以看到这次的提示信息就是Destination Host Unreachable了</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos72 ~<span class=o>]</span><span class=c1># ping 172.17.0.3</span>
</span></span><span class=line><span class=cl>PING 172.17.0.3 <span class=o>(</span>172.17.0.3<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.
</span></span><span class=line><span class=cl>From 192.168.37.134 <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> Destination Host Unreachable
</span></span><span class=line><span class=cl>From 192.168.37.134 <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>2</span> Destination Host Unreachable
</span></span></code></pre></div><h3 id=snat>SNAT<a hidden class=anchor aria-hidden=true href=#snat>#</a></h3><p>环境：</p><p><img loading=lazy src=./images/%e8%b7%af%e7%94%b1%e8%bd%ac%e5%8f%91.jpg alt></p><p>主机A具有公网IP(使用192.168.37.131模拟),提供web服务</p><p>主机B具有公网IP(使用192.168.37.134模拟)并且具有内网IP(172.17.0.1),为边界路由器</p><p>container1是内网主机，具有私网IP(172.17.0.3)，为内网中的一个用户，该用户需要访问外网的主机A</p><p>在主机B上配置SNAT使得内网主机container1能够访问公网主机A上提供的服务</p><ol><li><p>确保主机B sysctl -w net.ipv4.ip_forward=1并且filter表FORWARD链中的规则是空的并且默认动作是ACCEPT，此时主机container1不能访问主机A</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># sysctl -w net.ipv4.ip_forward=1</span>
</span></span><span class=line><span class=cl>net.ipv4.ip_forward <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># iptables -nvL FORWARD</span>
</span></span><span class=line><span class=cl>Chain FORWARD <span class=o>(</span>policy ACCEPT <span class=m>0</span> packets, <span class=m>0</span> bytes<span class=o>)</span>
</span></span><span class=line><span class=cl> pkts bytes target     prot opt in     out     <span class=nb>source</span>               destination
</span></span></code></pre></div></li><li><p>在主机B上添加SNAT规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># --to-source表示将过滤到的包的源IP修改为192.168.37.134</span>
</span></span><span class=line><span class=cl>iptables -t nat -A POSTROUTING -s 172.17.0.0/16 -j SNAT --to-source 192.168.37.134
</span></span></code></pre></div></li><li><p>在主机container1上访问主机A的服务</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#主机container1上执行,成功返回了内容</span>
</span></span><span class=line><span class=cl>curl 192.168.37.131:8080
</span></span><span class=line><span class=cl>HELLO WORLD
</span></span></code></pre></div></li><li><p>查看主机A上服务的日志信息,可以看到记录的日志信息获取到的请求的源地址是192.168.37.134也就是主机B，至此主机B已经成功完成了对cotainer1主机请求的SNAT装换</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@centos72 ~<span class=o>]</span><span class=c1># ./echo-server -p http</span>
</span></span><span class=line><span class=cl>http server will listen on port: <span class=m>8080</span> 
</span></span><span class=line><span class=cl>receive http request from 192.168.37.134:35816
</span></span></code></pre></div></li></ol><h3 id=dnat>DNAT<a hidden class=anchor aria-hidden=true href=#dnat>#</a></h3><p>公司只有一个公网IP，但是公司的内网中却有很多服务器提供各种服务，我们想要通过公网访问这些服务，改怎么办呢？</p><p>我们对外宣称，公司的公网IP上既提供了web服务，也提供了mysql，不管是访问web服务还是mysql，只要访问这个公网IP就行了，我们利用DNAT，将公网客户端发送过来的报文的目标地址与端口号做了映射，将访问web服务的报文转发到了内网中的container1主机中，将访问远程桌面的报文转发到了内网中的container2主机中</p><p>环境：</p><p><img loading=lazy src=./images/DNAT.jpg alt></p><p>主机A为公网IP(使用192.168.37.131模拟)可以通主机B通信</p><p>主机B具有两块网卡，一块IP为192.168.37.134可以通主机A通信，一块IP为172.17.0.1为内网IP，可以通container1、continer2通信</p><p>container1的IP为172.17.0.3，机器上部署有http服务</p><p>container2的IP为172.17.0.4，机器上部署有mysql</p><p>要达到的效果为访问主机B的IP：8080端口可以访问到container1上部署的http服务，使用主机B的IP：3306可以访问到container2上部署的mysql</p><ol><li><p>在主机B上配置DNAT使得访问主机B上8080端口的包转发到container1，访问主机B上3306端口的包转发到container2上</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># --to-destination表示把过滤到的包的IP和port改为指定的</span>
</span></span><span class=line><span class=cl>iptables -t nat -I PREROUTING -d 192.168.37.134 -p tcp --dport <span class=m>8080</span> -j DNAT --to-destination 172.17.0.3:8080
</span></span><span class=line><span class=cl>iptables -t nat -I PREROUTING -d 192.168.37.134 -p tcp --dport <span class=m>3306</span> -j DNAT --to-destination 172.17.0.4:3306
</span></span></code></pre></div></li><li><p>在主机A上测试访问主机B的IP的8080和3306端口,可以发现http服务和mysql都成功了，并且配置完DNAT也不用再配置SNAT了</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl 192.168.37.134:8080
</span></span><span class=line><span class=cl>HELLO WORLD
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mysql -h 192.168.37.134 -P <span class=m>3306</span> -u root -p
</span></span><span class=line><span class=cl>Enter password: 
</span></span></code></pre></div><p>###MASQUERADE</p><p>当我们拨号网上时，每次分配的IP地址往往不同，不会长期分给我们一个固定的IP地址，如果这时，我们想要让内网主机共享公网IP上网，就会很麻烦，因为每次IP地址发生变化以后，我们都要重新配置SNAT规则，这样显示不是很人性化，我们通过MASQUERADE即可解决这个问题，MASQUERADE会动态的将源地址转换为可用的IP地址，其实与SNAT实现的功能完全一致，都是修改源地址，只不过SNAT需要指明将报文的源地址改为哪个IP，而MASQUERADE则不用指定明确的IP，会动态的将报文的源地址修改为指定网卡上可用的IP地址</p><p>环境：</p><p><img loading=lazy src=./images/%e8%b7%af%e7%94%b1%e8%bd%ac%e5%8f%91.jpg alt></p><p>主机A的IP为192.168.37.131能够通主机B通信</p><p>主机B具有两块网卡，一块的IP是192.168.37.134能够同主机A通信，一块的IP为172.17.0.1能够同container1通信</p><p>container1的IP为172.17.0.3能够同主机B通信</p><p>目标：在主机B上配置MASQUERADE使得container1能够访问主机A上的http服务</p><ol><li><p>在主机B上配置MASQUERADE</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t nat -I POSTROUTING -s 172.17.0.0/16 -o ens33 -j MASQUERADE
</span></span></code></pre></div></li><li><p>在container1上访问主机A的http服务</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>HELLO WORLD
</span></span></code></pre></div></li><li><p>在主机A上查看http服务的日志,可以看到container1上的请求确实是经过了主机B代理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@centos72 ~<span class=o>]</span><span class=c1># ./echo-server -p http</span>
</span></span><span class=line><span class=cl>http server will listen on port: <span class=m>8080</span>
</span></span><span class=line><span class=cl>receive http request from 192.168.37.134:43418
</span></span></code></pre></div></li></ol><h3 id=redirect>REDIRECT<a hidden class=anchor aria-hidden=true href=#redirect>#</a></h3><p>使用REDIRECT动作可以在本机上进行端口映射</p><ol><li><p>将本机的80端口映射到本机的8080端口上</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>iptables -t nat -I PREROUTING -p tcp --dport <span class=m>80</span> -j REDIRECT --to-ports <span class=m>8080</span>
</span></span></code></pre></div></li><li><p><strong>在本机上测试访问,不能访问</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl 127.0.0.1
</span></span></code></pre></div><ol><li><strong>在同一局域网的其他主机访问，可以</strong> <strong>???</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl 192.168.37.134
</span></span><span class=line><span class=cl>HELLO WORLD
</span></span></code></pre></div></li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ol><li><p>规则的顺序非常重要</p><p>如果报文已经被前面的规则匹配到，IPTABLES则会对报文执行对应的动作，通常是ACCEPT或者REJECT，报文被放行或拒绝以后，即使后面的规则也能匹配到刚才放行或拒绝的报文，也没有机会再对报文执行相应的动作了（前面规则的动作为LOG时除外），所以，针对相同服务的规则，更严格的规则应该放在前面</p></li><li><p>当规则中有多个匹配条件时，条件之间默认存在”与”的关系</p><p>如果一条规则中包含了多个匹配条件，那么报文必须同时满足这个规则中的所有匹配条件，报文才能被这条规则匹配到</p></li><li><p>在不考虑1的情况下，应该将更容易被匹配到的规则放置在前面</p><p>比如，你写了两条规则，一条针对sshd服务，一条针对web服务。</p><p>假设，一天之内，有20000个请求访问web服务，有200个请求访问sshd服务，</p><p>那么，应该将针对web服务的规则放在前面，针对sshd的规则放在后面，因为访问web服务的请求频率更高。</p><p>如果将sshd的规则放在前面，当报文是访问web服务时，sshd的规则也要白白的验证一遍，由于访问web服务的频率更高，白白耗费的资源就更多。</p><p>如果web服务的规则放在前面，由于访问web服务的频率更高，所以无用功会比较少。</p><p>换句话说就是，在没有顺序要求的情况下，不同类别的规则，被匹配次数多的、匹配频率高的规则应该放在前面</p></li><li><p>当IPTABLES所在主机作为网络防火 墙时，在配置规则时，应着重考虑方向性，双向都要考虑，从外到内，从内到外</p></li><li><p>在配置IPTABLES白名单时，往往会将链的默认策略设置为ACCEPT，通过在链的最后设置REJECT规则实现白名单机制，而不是将链的默认策略设置为DROP，如果将链的默认策略设置为DROP，当链中的规则被清空时，管理员的请求也将会被DROP掉</p></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://moyuduo.github.io/posts/iot%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/><span class=title>« Prev</span><br><span>iot部署流程</span></a>
<a class=next href=https://moyuduo.github.io/posts/java8%E6%96%B0%E7%89%B9%E6%80%A7/><span class=title>Next »</span><br><span>Java8新特性</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share iptables on twitter" href="https://twitter.com/intent/tweet/?text=iptables&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share iptables on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f&title=iptables&summary=iptables&source=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share iptables on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f&title=iptables"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share iptables on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share iptables on whatsapp" href="https://api.whatsapp.com/send?text=iptables%20-%20https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share iptables on telegram" href="https://telegram.me/share/url?text=iptables&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fiptables%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>