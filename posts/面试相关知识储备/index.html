<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面试储备 | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="面试相关知识储备 你觉得java研发岗位需要什么能力？ 要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。
你觉得你有什么缺点？ 我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。
你还有什么要问的？ 加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？
你的职业规划是怎么样的？ 作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。
集合 ArrayList ArrayList底层使用Object数组来保存元素，默认初始化大小为10，当需要扩容时，新容量是原容量的1.5倍，modCount属性与集合遍历时的快速失败机制有关，ArrayList不是线程安全的
Vector Vector底层使用Object数组来保存元素，默认初始化大小是10，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么新容量为原容量+增长因子，否则新容量为原容量的2倍，Vector的所有方法都加了锁，所以是线程安全的
LinkedList LinkedList底层使用的是一个不带头结点的双向链表来保存元素的，在插入元素的时候进行的是尾插法，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以可以把LinkedList当做栈和队列使用，LinkedList不是线程安全的
HashMap 在jdk1.7以前HashMap使用的是数组+链表的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用数组+链表+红黑树的结构存储元素，当添加元素后，链表的长度达到8（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的初始化大小是16，加载因子是0.75，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的新容量扩大为原来的2倍，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以不是线程安全的
HashSet HashSet底层维护了一个HashMap，把添加的元素当做key来存储，利用HashMap中key不能重复的特性了保证HashSet中的元素不重复，不是线程安全的
Hashtable Hashtable底层采用数组+链表结构存储，默认初始化大小为11，加载因子为0.75，当元素个数达到阈值进行扩容时，新容量为原容量的2倍+1，并且使用头插法进行rehash，Hashtable的所有方法都加了锁，所以是线程安全的
LinkedHashMap LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，LinkedHashMap保证了遍历时按照添加/访问的顺序,LinkedHashMap不是线程安全的
项目遇到的问题 主键问题 在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题
413错误 在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题
JVM 类加载器有什么好处？ 可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。 确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。 不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。 mybatis中#和$有什么区别 #{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号
${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用
mybatis中嵌套查询和嵌套结果有什么区别 嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低
嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装
mysql中如何实现分页 可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize
servlet的生命周期 servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止
当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。
http和https区别 http采用的是明文传输，信息在网络上有可能被拦截
https采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译
TCP/IP几次握手，为什么 三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。
TCP和UDP有什么区别 TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。
UDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。
有哪些状态码 200 500 404 401 413 302 304
401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问
413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题
302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址"><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="面试储备"><meta property="og:description" content="面试相关知识储备 你觉得java研发岗位需要什么能力？ 要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。
你觉得你有什么缺点？ 我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。
你还有什么要问的？ 加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？
你的职业规划是怎么样的？ 作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。
集合 ArrayList ArrayList底层使用Object数组来保存元素，默认初始化大小为10，当需要扩容时，新容量是原容量的1.5倍，modCount属性与集合遍历时的快速失败机制有关，ArrayList不是线程安全的
Vector Vector底层使用Object数组来保存元素，默认初始化大小是10，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么新容量为原容量+增长因子，否则新容量为原容量的2倍，Vector的所有方法都加了锁，所以是线程安全的
LinkedList LinkedList底层使用的是一个不带头结点的双向链表来保存元素的，在插入元素的时候进行的是尾插法，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以可以把LinkedList当做栈和队列使用，LinkedList不是线程安全的
HashMap 在jdk1.7以前HashMap使用的是数组+链表的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用数组+链表+红黑树的结构存储元素，当添加元素后，链表的长度达到8（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的初始化大小是16，加载因子是0.75，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的新容量扩大为原来的2倍，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以不是线程安全的
HashSet HashSet底层维护了一个HashMap，把添加的元素当做key来存储，利用HashMap中key不能重复的特性了保证HashSet中的元素不重复，不是线程安全的
Hashtable Hashtable底层采用数组+链表结构存储，默认初始化大小为11，加载因子为0.75，当元素个数达到阈值进行扩容时，新容量为原容量的2倍+1，并且使用头插法进行rehash，Hashtable的所有方法都加了锁，所以是线程安全的
LinkedHashMap LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，LinkedHashMap保证了遍历时按照添加/访问的顺序,LinkedHashMap不是线程安全的
项目遇到的问题 主键问题 在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题
413错误 在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题
JVM 类加载器有什么好处？ 可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。 确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。 不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。 mybatis中#和$有什么区别 #{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号
${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用
mybatis中嵌套查询和嵌套结果有什么区别 嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低
嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装
mysql中如何实现分页 可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize
servlet的生命周期 servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止
当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。
http和https区别 http采用的是明文传输，信息在网络上有可能被拦截
https采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译
TCP/IP几次握手，为什么 三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。
TCP和UDP有什么区别 TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。
UDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。
有哪些状态码 200 500 404 401 413 302 304
401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问
413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题
302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址"><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面试储备"><meta name=twitter:description content="面试相关知识储备 你觉得java研发岗位需要什么能力？ 要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。
你觉得你有什么缺点？ 我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。
你还有什么要问的？ 加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？
你的职业规划是怎么样的？ 作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。
集合 ArrayList ArrayList底层使用Object数组来保存元素，默认初始化大小为10，当需要扩容时，新容量是原容量的1.5倍，modCount属性与集合遍历时的快速失败机制有关，ArrayList不是线程安全的
Vector Vector底层使用Object数组来保存元素，默认初始化大小是10，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么新容量为原容量+增长因子，否则新容量为原容量的2倍，Vector的所有方法都加了锁，所以是线程安全的
LinkedList LinkedList底层使用的是一个不带头结点的双向链表来保存元素的，在插入元素的时候进行的是尾插法，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以可以把LinkedList当做栈和队列使用，LinkedList不是线程安全的
HashMap 在jdk1.7以前HashMap使用的是数组+链表的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用数组+链表+红黑树的结构存储元素，当添加元素后，链表的长度达到8（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的初始化大小是16，加载因子是0.75，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的新容量扩大为原来的2倍，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以不是线程安全的
HashSet HashSet底层维护了一个HashMap，把添加的元素当做key来存储，利用HashMap中key不能重复的特性了保证HashSet中的元素不重复，不是线程安全的
Hashtable Hashtable底层采用数组+链表结构存储，默认初始化大小为11，加载因子为0.75，当元素个数达到阈值进行扩容时，新容量为原容量的2倍+1，并且使用头插法进行rehash，Hashtable的所有方法都加了锁，所以是线程安全的
LinkedHashMap LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，LinkedHashMap保证了遍历时按照添加/访问的顺序,LinkedHashMap不是线程安全的
项目遇到的问题 主键问题 在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题
413错误 在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题
JVM 类加载器有什么好处？ 可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。 确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。 不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。 mybatis中#和$有什么区别 #{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号
${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用
mybatis中嵌套查询和嵌套结果有什么区别 嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低
嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装
mysql中如何实现分页 可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize
servlet的生命周期 servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止
当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。
http和https区别 http采用的是明文传输，信息在网络上有可能被拦截
https采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译
TCP/IP几次握手，为什么 三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。
TCP和UDP有什么区别 TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。
UDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。
有哪些状态码 200 500 404 401 413 302 304
401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问
413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题
302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"面试储备","item":"https://moyuduo.github.io/posts/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面试储备","name":"面试储备","description":"面试相关知识储备 你觉得java研发岗位需要什么能力？ 要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。\n你觉得你有什么缺点？ 我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。\n你还有什么要问的？ 加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？\n你的职业规划是怎么样的？ 作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。\n集合 ArrayList ArrayList底层使用Object数组来保存元素，默认初始化大小为10，当需要扩容时，新容量是原容量的1.5倍，modCount属性与集合遍历时的快速失败机制有关，ArrayList不是线程安全的\nVector Vector底层使用Object数组来保存元素，默认初始化大小是10，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么新容量为原容量+增长因子，否则新容量为原容量的2倍，Vector的所有方法都加了锁，所以是线程安全的\nLinkedList LinkedList底层使用的是一个不带头结点的双向链表来保存元素的，在插入元素的时候进行的是尾插法，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以可以把LinkedList当做栈和队列使用，LinkedList不是线程安全的\nHashMap 在jdk1.7以前HashMap使用的是数组+链表的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用数组+链表+红黑树的结构存储元素，当添加元素后，链表的长度达到8（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的初始化大小是16，加载因子是0.75，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的新容量扩大为原来的2倍，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以不是线程安全的\nHashSet HashSet底层维护了一个HashMap，把添加的元素当做key来存储，利用HashMap中key不能重复的特性了保证HashSet中的元素不重复，不是线程安全的\nHashtable Hashtable底层采用数组+链表结构存储，默认初始化大小为11，加载因子为0.75，当元素个数达到阈值进行扩容时，新容量为原容量的2倍+1，并且使用头插法进行rehash，Hashtable的所有方法都加了锁，所以是线程安全的\nLinkedHashMap LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，LinkedHashMap保证了遍历时按照添加/访问的顺序,LinkedHashMap不是线程安全的\n项目遇到的问题 主键问题 在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题\n413错误 在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题\nJVM 类加载器有什么好处？ 可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。 确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。 不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。 mybatis中#和$有什么区别 #{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号\n${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用\nmybatis中嵌套查询和嵌套结果有什么区别 嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低\n嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装\nmysql中如何实现分页 可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize\nservlet的生命周期 servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止\n当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。\nhttp和https区别 http采用的是明文传输，信息在网络上有可能被拦截\nhttps采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译\nTCP/IP几次握手，为什么 三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。\nTCP和UDP有什么区别 TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。\nUDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。\n有哪些状态码 200 500 404 401 413 302 304\n401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问\n413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题\n302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址","keywords":[],"articleBody":"面试相关知识储备 你觉得java研发岗位需要什么能力？ 要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。\n你觉得你有什么缺点？ 我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。\n你还有什么要问的？ 加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？\n你的职业规划是怎么样的？ 作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。\n集合 ArrayList ArrayList底层使用Object数组来保存元素，默认初始化大小为10，当需要扩容时，新容量是原容量的1.5倍，modCount属性与集合遍历时的快速失败机制有关，ArrayList不是线程安全的\nVector Vector底层使用Object数组来保存元素，默认初始化大小是10，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么新容量为原容量+增长因子，否则新容量为原容量的2倍，Vector的所有方法都加了锁，所以是线程安全的\nLinkedList LinkedList底层使用的是一个不带头结点的双向链表来保存元素的，在插入元素的时候进行的是尾插法，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以可以把LinkedList当做栈和队列使用，LinkedList不是线程安全的\nHashMap 在jdk1.7以前HashMap使用的是数组+链表的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用数组+链表+红黑树的结构存储元素，当添加元素后，链表的长度达到8（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的初始化大小是16，加载因子是0.75，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的新容量扩大为原来的2倍，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以不是线程安全的\nHashSet HashSet底层维护了一个HashMap，把添加的元素当做key来存储，利用HashMap中key不能重复的特性了保证HashSet中的元素不重复，不是线程安全的\nHashtable Hashtable底层采用数组+链表结构存储，默认初始化大小为11，加载因子为0.75，当元素个数达到阈值进行扩容时，新容量为原容量的2倍+1，并且使用头插法进行rehash，Hashtable的所有方法都加了锁，所以是线程安全的\nLinkedHashMap LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，LinkedHashMap保证了遍历时按照添加/访问的顺序,LinkedHashMap不是线程安全的\n项目遇到的问题 主键问题 在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题\n413错误 在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题\nJVM 类加载器有什么好处？ 可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。 确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。 不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。 mybatis中#和$有什么区别 #{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号\n${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用\nmybatis中嵌套查询和嵌套结果有什么区别 嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低\n嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装\nmysql中如何实现分页 可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize\nservlet的生命周期 servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止\n当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。\nhttp和https区别 http采用的是明文传输，信息在网络上有可能被拦截\nhttps采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译\nTCP/IP几次握手，为什么 三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。\nTCP和UDP有什么区别 TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。\nUDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。\n有哪些状态码 200 500 404 401 413 302 304\n401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问\n413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题\n302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址\n304是请求资源未修改，直接使用缓存，常用于图片的缓存\njava堆为什么要分代 由于java中对象的生命周期是不一样的，有的对象的生命周期很长，有的对象被创建后马上就不再使用，所有JVM堆的设计者为了提高垃圾回收的效率，设计了堆的分代，如果不进行分代，那么不同生命周期的对象被放在一个空间中，GC需要去判断每个对象是否需要被回收，其实很多生命周期长的对象并不需要被回收，不分代那么这些对象也需要进行判断，增加了开销。\n为什么要有TLAB（Thread Local Allocation Buffer） 堆区是线程共享区域，当多个线程同时操作同一地址时，需要进行加锁，影响并发效率，为了解决这个问题，在Eden区内每个线程创建一个私有的缓存区域TLAB，当需要创建对象时，先在线程的TLAB中创建，由于TLAB是线程私有的，这个过程可以多个线程同时进行，不需要加锁，如果空间不够再在Eden中创建对象，由于堆中创建的对象绝大多数都是小对象，所以都使用TLAB，这样就提高了效率。\n堆是分配对象存储的唯一选择吗 不是。在java虚拟机中，有这种特殊的情况，如果经过逃逸分析后发现一个对象没有逃逸出方法，那么就可以被优化为栈上分配。但是由于进行逃逸分析消耗的性能可能比把对象存放在堆上消耗的性能还多，所以在HotSpot虚拟机中并没有运用逃逸分析，也就是说针对HotSpot虚拟机而言，对象都是分配在堆上的。\n逃逸分析：如果一个对象是在方法内new的，如果在方法外不能使用该对象，那么就说该对象没能逃逸出方法。\n//对象只在方法内使用，没能逃逸出方法 public void test(){ User u=new User(\"tom\"); //use u u=null; } //对象逃逸出方法,对象可能在方法外被使用 public User createUser(){ User u=new User(\"tom\"); return u; } 为什么要使用元空间替换永久代 因为永久代的空间大小很难确定，在某些情况下，我们的类加载过多（使用到很多jar包、tomcat下部署了很多war包），容易导致永久代OOM，而使用元空间就不会存在这个问题，因为元空间并不在虚拟机中，它是直接使用的本地内存，默认情况下，元空间大小仅受本地内存大小限制。\n我们公司业务慢，请你从数据库的角度分析下原因 首先判断是应急性的慢还是持续性的慢。如果是应急性的慢，先使用show processlist;查看导致慢的执行语句，再使用explain/desc分析执行的SQL的执行计划，有没有走索引，索引的类型，分析出原因后根据原因建索引或改语句。如果是持续性的慢，先查看slowlog查看哪些SQL执行慢，再使用explain/desc分析SQL执行计划找到原因。\nMysql数据引擎InnoDB和MyISAM有什么区别 InnoDB是Mysql的默认存储引擎，InnoDB支持事务，MyISAM不支持事务；InnoDB的锁粒度为行级锁，MyISAM为表级锁；InnoDB支持文件，MyISAM不支持外键；除此之外，InnoDB还具有自动故障恢复、热备份等优点。\n说说Mysql脏读、不可重复读、幻读的区别，Mysql默认的隔离级别是什么，不同隔离级别下会出现什么问题 脏读是一个事务读取了另一个事务未提交的事务，然后这个事务回滚了，这个数据就是脏数据。不可重复读是一个事务第一次读取一个数据，这时第二个事务修改了这个数据，当第一个事务再次读取这个数据时，就发现两次读同一个数据不一致。幻读是一个事务在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。\nmysql的默认事务隔离级别是可重复读，一共有读取未提交、读取已提交、可重复读和串行化四种隔离级别。在读取未提交隔离级别下，脏读、不可重复读、幻读都有可能出现。读取已提交不会出现脏读但是任然有不可重复读和幻读现象。可重复读解决了脏读和不可重复读，但是还是有幻读现象。串行化隔离模式下，脏读、不可重复读、幻读都不会出现。\n静态代理和动态代理有何不同 静态代理类需要手动实现，并且每个代理类只能代理一个目标对象，如果目标对象过多，那么就会生成大量的代理类。动态代理是在执行过程中，使用jdk的反射来创建代理类对象，并动态的指定要代理的目标对象。\n为什么要把字符串常量池从方法区移动到堆 jdk1.7中把字符串常量池从永久代移动到堆的原因是，永久代的GC频率很低，只有当老年代或永久代的空间不足时，才会触发Full GC，而我们开发中往往会创建大量的字符串，放在永久代回收效率低，放在堆中，GC更加频繁，更能即时回收空间。\n垃圾回收是否会涉及到java虚拟机栈 不会。虚拟机栈中的每个栈帧对应着每一个调用的方法，当方法执行结束，栈帧也就出栈了，栈帧中的局部变量表、操作数栈、动态链接等也就销毁了，所以不存在垃圾回收。\n方法中定义的局部变量是否线程安全 方法中定义的局部变量是线程安全的，因为方法中的局部变量是保存在java虚拟机栈中的局部变量表中的，而java虚拟机栈是线程私有的。\n什么是垃圾回收 垃圾是指运行的程序中没有任何指针指向的对象，如果不及时对内存进行垃圾清理，那么这些垃圾对象所占的内存空降会一致保留到程序结束，这些空间无法被其他对象使用，甚至可能导致内存溢出。\n为什么需要GC 对于高级语言来说，如果不进行垃圾会输，内存迟早都会被消耗完，因为不断的分配内存空间而不进行回收，就好像不停生成生活垃圾而不进行打扫。除了释放没用的对象，垃圾回收也可以清除内存碎片，碎片整理将所占的堆内存移动到堆的一端，方便后续给对象分配空间。随着程序的业务逐渐扩大，用户增多，如果没有垃圾回收就不能保证程序正常运行。\n哪些内存需要回收 从GC Root无法访问的对象，即没有对象引用该对象，这些对象在内存中不能被访问到，需要被回收\n什么时候进行垃圾回收 怎么进行垃圾回收 ParNew收集器是并行回收，那么是否可以断定ParNew收集器一定比Serial收集器的效率高 ParNew收集器运行在多CPU环境下，可以充分利用多CPU、多核心的硬件优势，可以更快的进行垃圾收集。但是在单CPU环境下，ParNew收集器的效率不比Serial收集器高，因为Serial收集器是基于单线程的，不需要CPU频繁的进行垃圾收集线程切换，避免了多线程切换过程中的一些额外开销。\nCMS收集器采用的是标记-清除算法，会产生内存碎片，那为什么不换成标记-压缩算法，解决内存碎片问题呢 CMS收集器是一款并发的垃圾收集器，它追求的是低延迟，如果把垃圾清除算法，换成标记-压缩算法的话，由于标记压缩算法需要移动对象，这个阶段必须“Stop The World”，如果采用这种算法的话，势必会增加延迟，这个这个垃圾收集器的设计初衷是相悖的。\n","wordCount":"136","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://moyuduo.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://moyuduo.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>面试储备</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#你觉得java研发岗位需要什么能力>你觉得java研发岗位需要什么能力？</a></li><li><a href=#你觉得你有什么缺点>你觉得你有什么缺点？</a></li><li><a href=#你还有什么要问的>你还有什么要问的？</a></li><li><a href=#你的职业规划是怎么样的>你的职业规划是怎么样的？</a></li><li><a href=#集合>集合</a><ul><li><a href=#arraylist>ArrayList</a></li><li><a href=#vector>Vector</a></li><li><a href=#linkedlist>LinkedList</a></li><li><a href=#hashmap>HashMap</a></li><li><a href=#hashset>HashSet</a></li><li><a href=#hashtable>Hashtable</a></li><li><a href=#linkedhashmap>LinkedHashMap</a></li></ul></li><li><a href=#项目遇到的问题>项目遇到的问题</a><ul><li><a href=#主键问题>主键问题</a></li><li><a href=#413错误>413错误</a></li></ul></li><li><a href=#jvm>JVM</a><ul><li><a href=#类加载器有什么好处>类加载器有什么好处？</a></li></ul></li><li><a href=#mybatis中和有什么区别>mybatis中#和$有什么区别</a></li><li><a href=#mybatis中嵌套查询和嵌套结果有什么区别>mybatis中嵌套查询和嵌套结果有什么区别</a></li><li><a href=#mysql中如何实现分页>mysql中如何实现分页</a></li><li><a href=#servlet的生命周期>servlet的生命周期</a></li><li><a href=#http和https区别>http和https区别</a></li><li><a href=#tcpip几次握手为什么>TCP/IP几次握手，为什么</a></li><li><a href=#tcp和udp有什么区别>TCP和UDP有什么区别</a></li><li><a href=#有哪些状态码>有哪些状态码</a></li><li><a href=#java堆为什么要分代>java堆为什么要分代</a></li><li><a href=#为什么要有tlabthread-local--allocation-buffer>为什么要有TLAB（Thread Local Allocation Buffer）</a></li><li><a href=#堆是分配对象存储的唯一选择吗>堆是分配对象存储的唯一选择吗</a></li><li><a href=#为什么要使用元空间替换永久代>为什么要使用元空间替换永久代</a></li><li><a href=#我们公司业务慢请你从数据库的角度分析下原因>我们公司业务慢，请你从数据库的角度分析下原因</a></li><li><a href=#mysql数据引擎innodb和myisam有什么区别>Mysql数据引擎InnoDB和MyISAM有什么区别</a></li><li><a href=#说说mysql脏读不可重复读幻读的区别mysql默认的隔离级别是什么不同隔离级别下会出现什么问题>说说Mysql脏读、不可重复读、幻读的区别，Mysql默认的隔离级别是什么，不同隔离级别下会出现什么问题</a></li><li><a href=#静态代理和动态代理有何不同>静态代理和动态代理有何不同</a></li><li><a href=#为什么要把字符串常量池从方法区移动到堆>为什么要把字符串常量池从方法区移动到堆</a></li><li><a href=#垃圾回收是否会涉及到java虚拟机栈>垃圾回收是否会涉及到java虚拟机栈</a></li><li><a href=#方法中定义的局部变量是否线程安全>方法中定义的局部变量是否线程安全</a><ul><li><a href=#什么是垃圾回收>什么是垃圾回收</a></li><li><a href=#为什么需要gc>为什么需要GC</a></li><li><a href=#哪些内存需要回收>哪些内存需要回收</a></li><li><a href=#什么时候进行垃圾回收>什么时候进行垃圾回收</a></li><li><a href=#怎么进行垃圾回收>怎么进行垃圾回收</a></li><li><a href=#parnew收集器是并行回收那么是否可以断定parnew收集器一定比serial收集器的效率高>ParNew收集器是并行回收，那么是否可以断定ParNew收集器一定比Serial收集器的效率高</a></li><li><a href=#cms收集器采用的是标记-清除算法会产生内存碎片那为什么不换成标记-压缩算法解决内存碎片问题呢>CMS收集器采用的是标记-清除算法，会产生内存碎片，那为什么不换成标记-压缩算法，解决内存碎片问题呢</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=面试相关知识储备>面试相关知识储备<a hidden class=anchor aria-hidden=true href=#面试相关知识储备>#</a></h1><h2 id=你觉得java研发岗位需要什么能力>你觉得java研发岗位需要什么能力？<a hidden class=anchor aria-hidden=true href=#你觉得java研发岗位需要什么能力>#</a></h2><p>要成为java研发工程师，我觉得首先要具备很好的代码能力，能够使用技术完成需求，其次需要有良好的沟通能力，因为我们是一个团队进行开发，每个人都不是独立的一个单位，需要彼此合作，才能完成项目。然后还需要有学习的能力，作为互联网从业者，我们都知道技术的更替是很快的，有不断的新技术出现，作为一个开发者，快速学习新技术是很有必要的。</p><h2 id=你觉得你有什么缺点>你觉得你有什么缺点？<a hidden class=anchor aria-hidden=true href=#你觉得你有什么缺点>#</a></h2><p>我是一个不太愿意去麻烦别人的人，如果遇到了什么问题，必须要寻求别人的帮助，那么我也一定会在物质和态度上去感谢对方，这就导致我也不喜欢别人轻易麻烦我，这可能算是我很大一个缺点。</p><h2 id=你还有什么要问的>你还有什么要问的？<a hidden class=anchor aria-hidden=true href=#你还有什么要问的>#</a></h2><p>加入我有幸加入贵公司，那在入职之前还有什么需要去学习和准备的吗？入职之后公司有没有相关培训？</p><h2 id=你的职业规划是怎么样的>你的职业规划是怎么样的？<a hidden class=anchor aria-hidden=true href=#你的职业规划是怎么样的>#</a></h2><p>作为一个一个应届毕业生，刚刚工作，在工作经验和技术上面还有很多需要积累的，我准备在未来2-3年主要提升自己的技术实力，达到能在团队内独挡一面，然后再经过 几年的学习，能够带领团队，进行项目开发，当自己技术具备一定广度，我准备往架构师方向发展。</p><h2 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h2><h3 id=arraylist>ArrayList<a hidden class=anchor aria-hidden=true href=#arraylist>#</a></h3><p>ArrayList底层使用Object数组来保存元素，<strong>默认初始化大小为10</strong>，当需要扩容时，<strong>新容量是原容量的1.5倍</strong>，modCount属性与集合遍历时的快速失败机制有关，ArrayList<strong>不是线程安全的</strong></p><h3 id=vector>Vector<a hidden class=anchor aria-hidden=true href=#vector>#</a></h3><p>Vector底层使用Object数组来保存元素，<strong>默认初始化大小是10</strong>，具有一个capacityIncrement属性，可以指定扩容时的增长因子，在进行扩容时，如果指定了增长因子，那么<strong>新容量为原容量+增长因子</strong>，否则<strong>新容量为原容量的2倍</strong>，Vector的所有方法都加了锁，所以是<strong>线程安全</strong>的</p><h3 id=linkedlist>LinkedList<a hidden class=anchor aria-hidden=true href=#linkedlist>#</a></h3><p>LinkedList底层使用的是一个<strong>不带头结点</strong>的<strong>双向链表</strong>来保存元素的，在插入元素的时候进行的是<strong>尾插法</strong>，LinkedList实现了Deque接口，可以在链表的两端进行入队和出队的操作，所以<strong>可以把LinkedList当做栈和队列使用</strong>，LinkedList<strong>不是线程安全的</strong></p><h3 id=hashmap>HashMap<a hidden class=anchor aria-hidden=true href=#hashmap>#</a></h3><p>在jdk1.7以前HashMap使用的是<strong>数组+链表</strong>的结构来存储元素的，由于添加元素过多后，hash碰撞的次数增加，导致链表的长度过长，访问的时候有效率的问题，jdk1.8为了解决这个问题采用<strong>数组+链表+红黑树</strong>的结构存储元素，当添加元素后，<strong>链表的长度达到8</strong>（还需要满足最少有64个元素的一条件）就会把链表转化为红黑树，HashMap默认的<strong>初始化大小是16</strong>，<strong>加载因子是0.75</strong>，添加元素如果对应节点是链表，进行的是尾插法，添加元素后到达阈值，需要进行扩容时，数组的<strong>新容量扩大为原来的2倍</strong>，并将所有元素进行rehash操作，HashMap的所有方法都没有加锁，所以<strong>不是线程安全的</strong></p><h3 id=hashset>HashSet<a hidden class=anchor aria-hidden=true href=#hashset>#</a></h3><p><strong>HashSet底层维护了一个HashMap</strong>，把添加的元素当做key来存储，<strong>利用HashMap中key不能重复的特性了保证HashSet中的元素不重复</strong>，<strong>不是线程安全的</strong></p><h3 id=hashtable>Hashtable<a hidden class=anchor aria-hidden=true href=#hashtable>#</a></h3><p>Hashtable底层采用<strong>数组+链表</strong>结构存储，<strong>默认初始化大小为11</strong>，<strong>加载因子为0.75</strong>，当元素个数达到阈值进行扩容时，<strong>新容量为原容量的2倍+1</strong>，并且使用<strong>头插法</strong>进行rehash，Hashtable的所有方法都加了锁，所以是<strong>线程安全</strong>的</p><h3 id=linkedhashmap>LinkedHashMap<a hidden class=anchor aria-hidden=true href=#linkedhashmap>#</a></h3><p>LinkedHashMap是HashMap的子类，节点新增了before和after两个属性保存前驱了后继，<strong>LinkedHashMap保证了遍历时按照添加/访问的顺序</strong>,<strong>LinkedHashMap不是线程安全的</strong></p><h2 id=项目遇到的问题>项目遇到的问题<a hidden class=anchor aria-hidden=true href=#项目遇到的问题>#</a></h2><h3 id=主键问题>主键问题<a hidden class=anchor aria-hidden=true href=#主键问题>#</a></h3><p>在在线学习项目中，数据库的主键使用的是mybatisPlus的生成策略，默认生成的是一个19位字符长度，js只能解析16位长度整数，发现这个问题户我们把主键生成策略改成了生成字符串，解决了这个问题</p><h3 id=413错误>413错误<a hidden class=anchor aria-hidden=true href=#413错误>#</a></h3><p>在视频上传的时候，刚开始测试是没有问题，配置了nginx请求转发后报出了413异常，我们直接判断是nginx出了问题，后来查阅资料发现是nginx的上传问题默认不能超过1M，通过配置client_max_body_size解决了这个问题</p><h2 id=jvm>JVM<a hidden class=anchor aria-hidden=true href=#jvm>#</a></h2><h3 id=类加载器有什么好处>类加载器有什么好处？<a hidden class=anchor aria-hidden=true href=#类加载器有什么好处>#</a></h3><ol><li>可以确保java核心类库的安全：如果java类库中的类是由自定义的加载器去加载的，那么可能在会在JVM中存在多个版本类，而且这些类是不兼容的，项目不可见的，借助双亲委派机制，java核心类库都由启动类加载器来统一加载，所以他们是类型兼容的。</li><li>确保java的核心类库不会被自定义类替换，每个加载器都有自己的加载路径，即使和java核心类同名，也会去加载java自己的类。</li><li>不同类的加载器可以为同名的类创建额外的命名空间，使得相同名称的类可以并存在java虚拟机中，并且他们 是不兼容的，相当于在java虚拟机中创建了一个个隔离的类空间，这种技术在很多框架中都有使用。</li></ol><h2 id=mybatis中和有什么区别>mybatis中#和$有什么区别<a hidden class=anchor aria-hidden=true href=#mybatis中和有什么区别>#</a></h2><p>#{}意味着预编译语句，sql语句中的#{}参数会使用jdbc的PreparedStatement替换为？占位符，这种方式可以防止sql注入,替换后的每个参数都有单引号</p><p>${}是直接将参数的字符串取值拼接sql后再去编译，这样就带来了sql注入的风险，当然${}并不是一无是处，在进行动态排序时，就需要使用</p><h2 id=mybatis中嵌套查询和嵌套结果有什么区别>mybatis中嵌套查询和嵌套结果有什么区别<a hidden class=anchor aria-hidden=true href=#mybatis中嵌套查询和嵌套结果有什么区别>#</a></h2><p>嵌套查询是对单表的查询后拿到关联的列再对关联对象进行查询，特点是简单但是需要执行多条sql语句效率低</p><p>嵌套结果是对多表的连接查询，一条sql查出所有的信息，然后再进行对象封装</p><h2 id=mysql中如何实现分页>mysql中如何实现分页<a hidden class=anchor aria-hidden=true href=#mysql中如何实现分页>#</a></h2><p>可以使用limit来进行分页，如果要查询pageNum页时，就使用limit （pageNum-1）*pageSize,pageSize</p><h2 id=servlet的生命周期>servlet的生命周期<a hidden class=anchor aria-hidden=true href=#servlet的生命周期>#</a></h2><p>servlet的生命周期主要包括四个阶段：①加载和实例化 ②初始化 ③处理请求 ④服务终止</p><p>当客户端第一次向web服务器发起一个servlet请求时，web服务器会创建一个该servlet的实例，并调用servlet的init方法；如果web服务器已经存在该servlet实例，那么就直接使用该实例；然后调用service方法；当web服务器reload或关闭tocat时，web服务器将调用servlet的destroy方法释放资源，然后将servlet从服务器内存中删除。</p><p><img loading=lazy src=images/servlet.png alt></p><h2 id=http和https区别>http和https区别<a hidden class=anchor aria-hidden=true href=#http和https区别>#</a></h2><p>http采用的是明文传输，信息在网络上有可能被拦截</p><p>https采用ssl证书，运用对称加密+非对称加密+CA第三方对传输的数据进行加密，即使传输的数据在网络上被劫持了也不能被破译</p><h2 id=tcpip几次握手为什么>TCP/IP几次握手，为什么<a hidden class=anchor aria-hidden=true href=#tcpip几次握手为什么>#</a></h2><p>三次握手。第一次握手是客户端向服务器发送一个syn包包含一个seq标志位，第二次握手是服务器收到了客户端连接的请求，同意建议连接，回复一个包，包含syn+ack，ack为seq+1表示收到了请求包，并且也有一个同步标志seq，第三次握手是客户端收到这个syn+ack包，此时客户端就知道服务器同意连接，并且准备就绪。如果只是两次握手，由于包在网络上传输是有延迟的，tcp是具有超时重传的，如果第一个请求建立连接的包在网络上阻塞了，客户端发送了第二个请求建立连接的包后，服务器收到了第一个延迟的包，给客户端回了一个确认包就建立连接的话。由于服务器是以延迟包的seq为标志，而客户端以为是新的请求连接的seq，导致后续客户端发送数据包时以客户端的seq的准，这些数据包发送到服务器都被丢弃了。如果是四次握手的话，也能保证建立连接，但是并不能显著增加可靠性，没有必要。</p><h2 id=tcp和udp有什么区别>TCP和UDP有什么区别<a hidden class=anchor aria-hidden=true href=#tcp和udp有什么区别>#</a></h2><p>TCP是面向连接的，在建立逻辑连接之前需要三次握手建立连接，并且TCP协议具有超时重传，数据包去重，所以TCP是保证可靠性的协议。</p><p>UDP是面向无连接的，不需要建立连接，发送端不保证数据包能被接收端收到，可能存在丢包的情况，是不保证数据可靠性的连接。</p><h2 id=有哪些状态码>有哪些状态码<a hidden class=anchor aria-hidden=true href=#有哪些状态码>#</a></h2><p>200 500 404 401 413 302 304</p><p>401是访问一些需要权限页面时，如果直接使用url访问，会返回状态码401表示没有权限访问</p><p>413请求体大小超过了nginx的默认1m大小，可以配置client_max_body_size解决了这个问题</p><p>302重定向，浏览器会从响应头中取出Location值的地址，然后去请求这个地址</p><p>304是请求资源未修改，直接使用缓存，常用于图片的缓存</p><h2 id=java堆为什么要分代>java堆为什么要分代<a hidden class=anchor aria-hidden=true href=#java堆为什么要分代>#</a></h2><p>由于java中对象的生命周期是不一样的，有的对象的生命周期很长，有的对象被创建后马上就不再使用，所有JVM堆的设计者为了提高垃圾回收的效率，设计了堆的分代，如果不进行分代，那么不同生命周期的对象被放在一个空间中，GC需要去判断每个对象是否需要被回收，其实很多生命周期长的对象并不需要被回收，不分代那么这些对象也需要进行判断，增加了开销。</p><h2 id=为什么要有tlabthread-local--allocation-buffer>为什么要有TLAB（Thread Local Allocation Buffer）<a hidden class=anchor aria-hidden=true href=#为什么要有tlabthread-local--allocation-buffer>#</a></h2><p>堆区是线程共享区域，当多个线程同时操作同一地址时，需要进行加锁，影响并发效率，为了解决这个问题，在Eden区内每个线程创建一个私有的缓存区域TLAB，当需要创建对象时，先在线程的TLAB中创建，由于TLAB是线程私有的，这个过程可以多个线程同时进行，不需要加锁，如果空间不够再在Eden中创建对象，由于堆中创建的对象绝大多数都是小对象，所以都使用TLAB，这样就提高了效率。</p><h2 id=堆是分配对象存储的唯一选择吗>堆是分配对象存储的唯一选择吗<a hidden class=anchor aria-hidden=true href=#堆是分配对象存储的唯一选择吗>#</a></h2><p>不是。在java虚拟机中，有这种特殊的情况，如果经过<strong>逃逸分析</strong>后发现一个对象没有逃逸出方法，那么就可以被优化为栈上分配。但是由于进行逃逸分析消耗的性能可能比把对象存放在堆上消耗的性能还多，所以在HotSpot虚拟机中并没有运用逃逸分析，也就是说针对HotSpot虚拟机而言，对象都是分配在堆上的。</p><p>逃逸分析：如果一个对象是在方法内new的，如果在方法外不能使用该对象，那么就说该对象没能逃逸出方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//对象只在方法内使用，没能逃逸出方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>User</span> <span class=n>u</span><span class=o>=</span><span class=k>new</span> <span class=n>User</span><span class=o>(</span><span class=s>&#34;tom&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>//use u
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>u</span><span class=o>=</span><span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//对象逃逸出方法,对象可能在方法外被使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=n>User</span> <span class=nf>createUser</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>  <span class=n>User</span> <span class=n>u</span><span class=o>=</span><span class=k>new</span> <span class=n>User</span><span class=o>(</span><span class=s>&#34;tom&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>u</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=为什么要使用元空间替换永久代>为什么要使用元空间替换永久代<a hidden class=anchor aria-hidden=true href=#为什么要使用元空间替换永久代>#</a></h2><p>因为永久代的空间大小很难确定，在某些情况下，我们的类加载过多（使用到很多jar包、tomcat下部署了很多war包），容易导致永久代OOM，而使用元空间就不会存在这个问题，因为元空间并不在虚拟机中，它是直接使用的本地内存，默认情况下，元空间大小仅受本地内存大小限制。</p><h2 id=我们公司业务慢请你从数据库的角度分析下原因>我们公司业务慢，请你从数据库的角度分析下原因<a hidden class=anchor aria-hidden=true href=#我们公司业务慢请你从数据库的角度分析下原因>#</a></h2><p>首先判断是<strong>应急性的慢</strong>还是<strong>持续性的慢</strong>。如果是应急性的慢，先使用<code>show processlist;</code>查看导致慢的执行语句，再使用explain/desc分析执行的SQL的执行计划，有没有走索引，索引的类型，分析出原因后根据原因建索引或改语句。如果是持续性的慢，先查看slowlog查看哪些SQL执行慢，再使用explain/desc分析SQL执行计划找到原因。</p><h2 id=mysql数据引擎innodb和myisam有什么区别>Mysql数据引擎InnoDB和MyISAM有什么区别<a hidden class=anchor aria-hidden=true href=#mysql数据引擎innodb和myisam有什么区别>#</a></h2><p>InnoDB是Mysql的默认存储引擎，InnoDB支持事务，MyISAM不支持事务；InnoDB的锁粒度为行级锁，MyISAM为表级锁；InnoDB支持文件，MyISAM不支持外键；除此之外，InnoDB还具有自动故障恢复、热备份等优点。</p><h2 id=说说mysql脏读不可重复读幻读的区别mysql默认的隔离级别是什么不同隔离级别下会出现什么问题>说说Mysql脏读、不可重复读、幻读的区别，Mysql默认的隔离级别是什么，不同隔离级别下会出现什么问题<a hidden class=anchor aria-hidden=true href=#说说mysql脏读不可重复读幻读的区别mysql默认的隔离级别是什么不同隔离级别下会出现什么问题>#</a></h2><p>脏读是一个事务读取了另一个事务未提交的事务，然后这个事务回滚了，这个数据就是脏数据。不可重复读是一个事务第一次读取一个数据，这时第二个事务修改了这个数据，当第一个事务再次读取这个数据时，就发现两次读同一个数据不一致。幻读是一个事务在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</p><p>mysql的默认事务隔离级别是可重复读，一共有读取未提交、读取已提交、可重复读和串行化四种隔离级别。在读取未提交隔离级别下，脏读、不可重复读、幻读都有可能出现。读取已提交不会出现脏读但是任然有不可重复读和幻读现象。可重复读解决了脏读和不可重复读，但是还是有幻读现象。串行化隔离模式下，脏读、不可重复读、幻读都不会出现。</p><h2 id=静态代理和动态代理有何不同>静态代理和动态代理有何不同<a hidden class=anchor aria-hidden=true href=#静态代理和动态代理有何不同>#</a></h2><p>静态代理类需要手动实现，并且每个代理类只能代理一个目标对象，如果目标对象过多，那么就会生成大量的代理类。动态代理是在执行过程中，使用jdk的反射来创建代理类对象，并动态的指定要代理的目标对象。</p><h2 id=为什么要把字符串常量池从方法区移动到堆>为什么要把字符串常量池从方法区移动到堆<a hidden class=anchor aria-hidden=true href=#为什么要把字符串常量池从方法区移动到堆>#</a></h2><p>jdk1.7中把字符串常量池从永久代移动到堆的原因是，永久代的GC频率很低，只有当老年代或永久代的空间不足时，才会触发Full GC，而我们开发中往往会创建大量的字符串，放在永久代回收效率低，放在堆中，GC更加频繁，更能即时回收空间。</p><h2 id=垃圾回收是否会涉及到java虚拟机栈>垃圾回收是否会涉及到java虚拟机栈<a hidden class=anchor aria-hidden=true href=#垃圾回收是否会涉及到java虚拟机栈>#</a></h2><p>不会。虚拟机栈中的每个栈帧对应着每一个调用的方法，当方法执行结束，栈帧也就出栈了，栈帧中的局部变量表、操作数栈、动态链接等也就销毁了，所以不存在垃圾回收。</p><h2 id=方法中定义的局部变量是否线程安全>方法中定义的局部变量是否线程安全<a hidden class=anchor aria-hidden=true href=#方法中定义的局部变量是否线程安全>#</a></h2><p>方法中定义的局部变量是线程安全的，因为方法中的局部变量是保存在java虚拟机栈中的局部变量表中的，而java虚拟机栈是线程私有的。</p><h3 id=什么是垃圾回收>什么是垃圾回收<a hidden class=anchor aria-hidden=true href=#什么是垃圾回收>#</a></h3><p>垃圾是指运行的程序中没有任何指针指向的对象，如果不及时对内存进行垃圾清理，那么这些垃圾对象所占的内存空降会一致保留到程序结束，这些空间无法被其他对象使用，甚至可能导致内存溢出。</p><h3 id=为什么需要gc>为什么需要GC<a hidden class=anchor aria-hidden=true href=#为什么需要gc>#</a></h3><p>对于高级语言来说，如果不进行垃圾会输，内存迟早都会被消耗完，因为不断的分配内存空间而不进行回收，就好像不停生成生活垃圾而不进行打扫。除了释放没用的对象，垃圾回收也可以清除内存碎片，碎片整理将所占的堆内存移动到堆的一端，方便后续给对象分配空间。随着程序的业务逐渐扩大，用户增多，如果没有垃圾回收就不能保证程序正常运行。</p><h3 id=哪些内存需要回收>哪些内存需要回收<a hidden class=anchor aria-hidden=true href=#哪些内存需要回收>#</a></h3><p>从GC Root无法访问的对象，即没有对象引用该对象，这些对象在内存中不能被访问到，需要被回收</p><h3 id=什么时候进行垃圾回收>什么时候进行垃圾回收<a hidden class=anchor aria-hidden=true href=#什么时候进行垃圾回收>#</a></h3><h3 id=怎么进行垃圾回收>怎么进行垃圾回收<a hidden class=anchor aria-hidden=true href=#怎么进行垃圾回收>#</a></h3><h3 id=parnew收集器是并行回收那么是否可以断定parnew收集器一定比serial收集器的效率高>ParNew收集器是并行回收，那么是否可以断定ParNew收集器一定比Serial收集器的效率高<a hidden class=anchor aria-hidden=true href=#parnew收集器是并行回收那么是否可以断定parnew收集器一定比serial收集器的效率高>#</a></h3><p>ParNew收集器运行在多CPU环境下，可以充分利用多CPU、多核心的硬件优势，可以更快的进行垃圾收集。但是在单CPU环境下，ParNew收集器的效率不比Serial收集器高，因为Serial收集器是基于单线程的，不需要CPU频繁的进行垃圾收集线程切换，避免了多线程切换过程中的一些额外开销。</p><h3 id=cms收集器采用的是标记-清除算法会产生内存碎片那为什么不换成标记-压缩算法解决内存碎片问题呢>CMS收集器采用的是标记-清除算法，会产生内存碎片，那为什么不换成标记-压缩算法，解决内存碎片问题呢<a hidden class=anchor aria-hidden=true href=#cms收集器采用的是标记-清除算法会产生内存碎片那为什么不换成标记-压缩算法解决内存碎片问题呢>#</a></h3><p>CMS收集器是一款并发的垃圾收集器，它追求的是低延迟，如果把垃圾清除算法，换成标记-压缩算法的话，由于标记压缩算法需要移动对象，这个阶段必须“Stop The World”，如果采用这种算法的话，势必会增加延迟，这个这个垃圾收集器的设计初衷是相悖的。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>