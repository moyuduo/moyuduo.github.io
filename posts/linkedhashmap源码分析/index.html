<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LinkedHashMap源码分析 | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="LinkedHashMap源码分析 为什么要有LinkedHashMap？ 在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致 @Test public void test1() { HashMap<String,String> hashMap=new HashMap<String, String>(); hashMap.put(&#34;tom&#34;, &#34;american&#34;); hashMap.put(&#34;jack&#34;, &#34;chainese&#34;); hashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = hashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry<String, String> entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&#34;:&#34;+value); } } 输出： tom:american mary:japanese jack:chainese LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别 @Test public void test2() { LinkedHashMap<String,String> linkedHashMap=new LinkedHashMap(); linkedHashMap.put(&#34;tom&#34;, &#34;american&#34;); linkedHashMap.put(&#34;jack&#34;, &#34;chainese&#34;); linkedHashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = linkedHashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet."><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/linkedhashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="LinkedHashMap源码分析"><meta property="og:description" content="LinkedHashMap源码分析 为什么要有LinkedHashMap？ 在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致 @Test public void test1() { HashMap<String,String> hashMap=new HashMap<String, String>(); hashMap.put(&#34;tom&#34;, &#34;american&#34;); hashMap.put(&#34;jack&#34;, &#34;chainese&#34;); hashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = hashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry<String, String> entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&#34;:&#34;+value); } } 输出： tom:american mary:japanese jack:chainese LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别 @Test public void test2() { LinkedHashMap<String,String> linkedHashMap=new LinkedHashMap(); linkedHashMap.put(&#34;tom&#34;, &#34;american&#34;); linkedHashMap.put(&#34;jack&#34;, &#34;chainese&#34;); linkedHashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = linkedHashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet."><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/linkedhashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="LinkedHashMap源码分析"><meta name=twitter:description content="LinkedHashMap源码分析 为什么要有LinkedHashMap？ 在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致 @Test public void test1() { HashMap<String,String> hashMap=new HashMap<String, String>(); hashMap.put(&#34;tom&#34;, &#34;american&#34;); hashMap.put(&#34;jack&#34;, &#34;chainese&#34;); hashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = hashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry<String, String> entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&#34;:&#34;+value); } } 输出： tom:american mary:japanese jack:chainese LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别 @Test public void test2() { LinkedHashMap<String,String> linkedHashMap=new LinkedHashMap(); linkedHashMap.put(&#34;tom&#34;, &#34;american&#34;); linkedHashMap.put(&#34;jack&#34;, &#34;chainese&#34;); linkedHashMap.put(&#34;mary&#34;, &#34;japanese&#34;); Set<Entry<String, String>> entrySet = linkedHashMap.entrySet(); Iterator<Entry<String, String>> iterator = entrySet."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"LinkedHashMap源码分析","item":"https://moyuduo.github.io/posts/linkedhashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LinkedHashMap源码分析","name":"LinkedHashMap源码分析","description":"LinkedHashMap源码分析 为什么要有LinkedHashMap？ 在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致 @Test public void test1() { HashMap\u0026lt;String,String\u0026gt; hashMap=new HashMap\u0026lt;String, String\u0026gt;(); hashMap.put(\u0026#34;tom\u0026#34;, \u0026#34;american\u0026#34;); hashMap.put(\u0026#34;jack\u0026#34;, \u0026#34;chainese\u0026#34;); hashMap.put(\u0026#34;mary\u0026#34;, \u0026#34;japanese\u0026#34;); Set\u0026lt;Entry\u0026lt;String, String\u0026gt;\u0026gt; entrySet = hashMap.entrySet(); Iterator\u0026lt;Entry\u0026lt;String, String\u0026gt;\u0026gt; iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry\u0026lt;String, String\u0026gt; entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\u0026#34;:\u0026#34;+value); } } 输出： tom:american mary:japanese jack:chainese LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别 @Test public void test2() { LinkedHashMap\u0026lt;String,String\u0026gt; linkedHashMap=new LinkedHashMap(); linkedHashMap.put(\u0026#34;tom\u0026#34;, \u0026#34;american\u0026#34;); linkedHashMap.put(\u0026#34;jack\u0026#34;, \u0026#34;chainese\u0026#34;); linkedHashMap.put(\u0026#34;mary\u0026#34;, \u0026#34;japanese\u0026#34;); Set\u0026lt;Entry\u0026lt;String, String\u0026gt;\u0026gt; entrySet = linkedHashMap.entrySet(); Iterator\u0026lt;Entry\u0026lt;String, String\u0026gt;\u0026gt; iterator = entrySet.","keywords":[],"articleBody":"LinkedHashMap源码分析 为什么要有LinkedHashMap？ 在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致 @Test public void test1() { HashMap\u003cString,String\u003e hashMap=new HashMap\u003cString, String\u003e(); hashMap.put(\"tom\", \"american\"); hashMap.put(\"jack\", \"chainese\"); hashMap.put(\"mary\", \"japanese\"); Set\u003cEntry\u003cString, String\u003e\u003e entrySet = hashMap.entrySet(); Iterator\u003cEntry\u003cString, String\u003e\u003e iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry\u003cString, String\u003e entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\":\"+value); } } 输出： tom:american mary:japanese jack:chainese LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别 @Test public void test2() { LinkedHashMap\u003cString,String\u003e linkedHashMap=new LinkedHashMap(); linkedHashMap.put(\"tom\", \"american\"); linkedHashMap.put(\"jack\", \"chainese\"); linkedHashMap.put(\"mary\", \"japanese\"); Set\u003cEntry\u003cString, String\u003e\u003e entrySet = linkedHashMap.entrySet(); Iterator\u003cEntry\u003cString, String\u003e\u003e iterator = entrySet.iterator(); while(iterator.hasNext()) { Entry\u003cString, String\u003e entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\":\"+value); } } 输出： tom:american jack:chainese mary:japanese 存储示意图 类结构 public class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e implements Map\u003cK,V\u003e LinkedHashMap是HashMap的子类，它对HashMap做了一些增强\n节点 static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {//LinkedHashMap的Entry节点是HashMap的Node节点的子类 Entry\u003cK,V\u003e before, after;//新增了before、after分别指向前驱和后继 Entry(int hash, K key, V value, Node\u003cK,V\u003e next) { //直接使用HashMap的Node节点构造方法 super(hash, key, value, next); } } 属性 //头指针指向第一个添加节点 transient LinkedHashMap.Entry\u003cK,V\u003e head; //尾指针指向最后一个添加节点 transient LinkedHashMap.Entry\u003cK,V\u003e tail; //排序规则，true的话按照访问顺序排序，最近访问的放到最后，false也是默认按照插入顺序排序 final boolean accessOrder; 构造方法 //指定初始化容量和加载因子 public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } //指定初始化容量 public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } //无参构造方法 public LinkedHashMap() { super(); accessOrder = false; } //使用Map初始化 public LinkedHashMap(Map\u003c? extends K, ? extends V\u003e m) { super(); accessOrder = false; putMapEntries(m, false); } //指定初始化容量、加载因子、排序规则 public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 方法 LinkedHashMap中并没有put方法，所以使用的是父类HashMap的put方法\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) //当根据hash计算的下标位置没放节点，调用LinkedHashMap的newNode方法 tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //如果是指定访问顺序排序，那么替换后，把节点移动到最后 afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } Node\u003cK,V\u003e newNode(int hash, K key, V value, Node\u003cK,V\u003e e) { LinkedHashMap.Entry\u003cK,V\u003e p = new LinkedHashMap.Entry\u003cK,V\u003e(hash, key, value, e); linkNodeLast(p); return p; } private void linkNodeLast(LinkedHashMap.Entry\u003cK,V\u003e p) { //保存LinkedHashMap的为指针 LinkedHashMap.Entry\u003cK,V\u003e last = tail; tail = p; if (last == null)//尾指针为null说明LinkedHashMap中没元素 head = p; else {//有元素 //新节点的前驱指向添加之前的尾指针 p.before = last; //添加之前的尾指针节点的后继指向新节点 last.after = p; } } void afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last LinkedHashMap.Entry\u003cK,V\u003e last; if (accessOrder \u0026\u0026 (last = tail) != e) {//如果指定了按访问顺序排序且替换的节点不是最末尾的节点 LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry\u003cK,V\u003e first; if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {//removeEldestEntry方法返回false所以不会进入if K key = first.key; removeNode(hash(key), key, null, false, true); } } get(Object）根据key获取值\npublic V get(Object key) { Node\u003cK,V\u003e e; if ((e = getNode(hash(key), key)) == null)//调用HashMap的方法拿到值 return null; if (accessOrder)//如果是按照访问顺序排序的话 //访问过后要修改顺序 afterNodeAccess(e); return e.value; } //把访问的节点移动到链表的最末端 void afterNodeAccess(Node\u003cK,V\u003e e) { LinkedHashMap.Entry\u003cK,V\u003e last; if (accessOrder \u0026\u0026 (last = tail) != e) {//按访问顺序排序并且访问节点不是最后一个节点 LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } remove(Object)方法是调用父类HashMap的方法\npublic V remove(Object key) { Node\u003cK,V\u003e e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node\u003cK,V\u003e removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, index; if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (p = tab[index = (n - 1) \u0026 hash]) != null) { Node\u003cK,V\u003e node = null, e; K k; V v; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode\u003cK,V\u003e)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null \u0026\u0026 (!matchValue || (v = node.value) == value || (value != null \u0026\u0026 value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u003cK,V\u003e)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; //调用LinkedHashMap·的方法来实现双链的删除 afterNodeRemoval(node); return node; } } return null; } void afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after; //把要移除节点的前驱后继置为null p.before = p.after = null; if (b == null)//b为null即移除的就是第一个元素 //头指针指向移除元素的后继 head = a; else b.after = a; if (a == null)//a为null即移除的元素是最后一个元素 //尾指针指向移除元素的前驱 tail = b; else a.before = b; } ","wordCount":"923","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/linkedhashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://moyuduo.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://moyuduo.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>LinkedHashMap源码分析</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#为什么要有linkedhashmap>为什么要有LinkedHashMap？</a><ul><li><a href=#在分析hashmap的时候提到了hashmap是无序的即添加节点的顺序和遍历的顺序不一致>在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致</a></li><li><a href=#linkedhashmap保证节点的顺序这也是linkedhashmap和hashmap的主要区别>LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别</a></li></ul></li><li><a href=#存储示意图>存储示意图</a></li><li><a href=#类结构>类结构</a></li><li><a href=#节点>节点</a></li><li><a href=#属性>属性</a></li><li><a href=#构造方法>构造方法</a></li><li><a href=#方法>方法</a></li></ul></nav></div></details></div><div class=post-content><h1 id=linkedhashmap源码分析>LinkedHashMap源码分析<a hidden class=anchor aria-hidden=true href=#linkedhashmap源码分析>#</a></h1><h2 id=为什么要有linkedhashmap>为什么要有LinkedHashMap？<a hidden class=anchor aria-hidden=true href=#为什么要有linkedhashmap>#</a></h2><h3 id=在分析hashmap的时候提到了hashmap是无序的即添加节点的顺序和遍历的顺序不一致>在分析HashMap的时候提到了HashMap是无序的，即添加节点的顺序和遍历的顺序不一致<a hidden class=anchor aria-hidden=true href=#在分析hashmap的时候提到了hashmap是无序的即添加节点的顺序和遍历的顺序不一致>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>hashMap</span><span class=o>=</span><span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl>		<span class=n>hashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;tom&#34;</span><span class=o>,</span> <span class=s>&#34;american&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>hashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;jack&#34;</span><span class=o>,</span> <span class=s>&#34;chainese&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>hashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;mary&#34;</span><span class=o>,</span> <span class=s>&#34;japanese&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>Set</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>entrySet</span> <span class=o>=</span> <span class=n>hashMap</span><span class=o>.</span><span class=na>entrySet</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>iterator</span> <span class=o>=</span> <span class=n>entrySet</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span><span class=o>(</span><span class=n>iterator</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>entry</span> <span class=o>=</span> <span class=n>iterator</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>String</span> <span class=n>key</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=na>getKey</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>key</span><span class=o>+</span><span class=s>&#34;:&#34;</span><span class=o>+</span><span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=nl>tom:</span><span class=n>american</span>
</span></span><span class=line><span class=cl><span class=nl>mary:</span><span class=n>japanese</span>
</span></span><span class=line><span class=cl><span class=nl>jack:</span><span class=n>chainese</span>
</span></span></code></pre></div><h3 id=linkedhashmap保证节点的顺序这也是linkedhashmap和hashmap的主要区别>LinkedHashMap保证节点的顺序，这也是LinkedHashMap和HashMap的主要区别<a hidden class=anchor aria-hidden=true href=#linkedhashmap保证节点的顺序这也是linkedhashmap和hashmap的主要区别>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>linkedHashMap</span><span class=o>=</span><span class=k>new</span> <span class=n>LinkedHashMap</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>linkedHashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;tom&#34;</span><span class=o>,</span> <span class=s>&#34;american&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>linkedHashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;jack&#34;</span><span class=o>,</span> <span class=s>&#34;chainese&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>linkedHashMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;mary&#34;</span><span class=o>,</span> <span class=s>&#34;japanese&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=n>Set</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>entrySet</span> <span class=o>=</span> <span class=n>linkedHashMap</span><span class=o>.</span><span class=na>entrySet</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>iterator</span> <span class=o>=</span> <span class=n>entrySet</span><span class=o>.</span><span class=na>iterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span><span class=o>(</span><span class=n>iterator</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>entry</span> <span class=o>=</span> <span class=n>iterator</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>String</span> <span class=n>key</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=na>getKey</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>key</span><span class=o>+</span><span class=s>&#34;:&#34;</span><span class=o>+</span><span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>输出：</span>
</span></span><span class=line><span class=cl><span class=nl>tom:</span><span class=n>american</span>
</span></span><span class=line><span class=cl><span class=nl>jack:</span><span class=n>chainese</span>
</span></span><span class=line><span class=cl><span class=nl>mary:</span><span class=n>japanese</span>
</span></span></code></pre></div><h2 id=存储示意图>存储示意图<a hidden class=anchor aria-hidden=true href=#存储示意图>#</a></h2><p><img loading=lazy src=images/Snipaste_2020-04-23_10-28-38.jpg alt></p><h2 id=类结构>类结构<a hidden class=anchor aria-hidden=true href=#类结构>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>LinkedHashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>extends</span> <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>implements</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span>
</span></span></code></pre></div><p>LinkedHashMap是HashMap的子类，它对HashMap做了一些增强</p><h2 id=节点>节点<a hidden class=anchor aria-hidden=true href=#节点>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>class</span> <span class=nc>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>HashMap</span><span class=o>.</span><span class=na>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=o>{</span><span class=c1>//LinkedHashMap的Entry节点是HashMap的Node节点的子类
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>before</span><span class=o>,</span> <span class=n>after</span><span class=o>;</span><span class=c1>//新增了before、after分别指向前驱和后继
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Entry</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=c1>//直接使用HashMap的Node节点构造方法
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kd>super</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>next</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><h2 id=属性>属性<a hidden class=anchor aria-hidden=true href=#属性>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//头指针指向第一个添加节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>head</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//尾指针指向最后一个添加节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>transient</span> <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//排序规则，true的话按照访问顺序排序，最近访问的放到最后，false也是默认按照插入顺序排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>final</span> <span class=kt>boolean</span> <span class=n>accessOrder</span><span class=o>;</span>
</span></span></code></pre></div><h2 id=构造方法>构造方法<a hidden class=anchor aria-hidden=true href=#构造方法>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//指定初始化容量和加载因子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedHashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>,</span> <span class=n>loadFactor</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>accessOrder</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//指定初始化容量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedHashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>accessOrder</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//无参构造方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedHashMap</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>accessOrder</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//使用Map初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedHashMap</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>K</span><span class=o>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>accessOrder</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>putMapEntries</span><span class=o>(</span><span class=n>m</span><span class=o>,</span> <span class=kc>false</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//指定初始化容量、加载因子、排序规则
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=nf>LinkedHashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                         <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                         <span class=kt>boolean</span> <span class=n>accessOrder</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>,</span> <span class=n>loadFactor</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>accessOrder</span> <span class=o>=</span> <span class=n>accessOrder</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><h2 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h2><p>LinkedHashMap中并没有put方法，所以使用的是父类HashMap的put方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>put</span><span class=o>(</span><span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>putVal</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>final</span> <span class=n>V</span> <span class=nf>putVal</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>onlyIfAbsent</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>;</span> <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>n</span> <span class=o>=</span> <span class=o>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=o>()).</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=c1>//当根据hash计算的下标位置没放节点，调用LinkedHashMap的newNode方法
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span> <span class=n>K</span> <span class=n>k</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span><span class=line><span class=cl>                <span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>e</span> <span class=o>=</span> <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>p</span><span class=o>).</span><span class=na>putTreeVal</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>binCount</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=o>;</span> <span class=o>++</span><span class=n>binCount</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=o>(</span><span class=n>binCount</span> <span class=o>&gt;=</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=c1>// -1 for 1st
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=n>treeifyBin</span><span class=o>(</span><span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                        <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// existing mapping for key
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>V</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(!</span><span class=n>onlyIfAbsent</span> <span class=o>||</span> <span class=n>oldValue</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=c1>//如果是指定访问顺序排序，那么替换后，把节点移动到最后
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>afterNodeAccess</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(++</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>resize</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>afterNodeInsertion</span><span class=o>(</span><span class=n>evict</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>newNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=k>new</span> <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>linkNodeLast</span><span class=o>(</span><span class=n>p</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>void</span> <span class=nf>linkNodeLast</span><span class=o>(</span><span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//保存LinkedHashMap的为指针
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>last</span> <span class=o>=</span> <span class=n>tail</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tail</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>last</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//尾指针为null说明LinkedHashMap中没元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>head</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=o>{</span><span class=c1>//有元素
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//新节点的前驱指向添加之前的尾指针
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>p</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>          <span class=c1>//添加之前的尾指针节点的后继指向新节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>last</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>afterNodeAccess</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// move node to last
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>accessOrder</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>last</span> <span class=o>=</span> <span class=n>tail</span><span class=o>)</span> <span class=o>!=</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span><span class=c1>//如果指定了按访问顺序排序且替换的节点不是最末尾的节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=o>(</span><span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>e</span><span class=o>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>before</span><span class=o>,</span> <span class=n>a</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>after</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>b</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>a</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>a</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>last</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>last</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>last</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>tail</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>afterNodeInsertion</span><span class=o>(</span><span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// possibly remove eldest
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>first</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>evict</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>first</span> <span class=o>=</span> <span class=n>head</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>removeEldestEntry</span><span class=o>(</span><span class=n>first</span><span class=o>))</span> <span class=o>{</span><span class=c1>//removeEldestEntry方法返回false所以不会进入if
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>K</span> <span class=n>key</span> <span class=o>=</span> <span class=n>first</span><span class=o>.</span><span class=na>key</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>removeNode</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>get(Object）根据key获取值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>get</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>getNode</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>))</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//调用HashMap的方法拿到值
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>accessOrder</span><span class=o>)</span><span class=c1>//如果是按照访问顺序排序的话
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//访问过后要修改顺序
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>afterNodeAccess</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//把访问的节点移动到链表的最末端
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>afterNodeAccess</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>accessOrder</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>last</span> <span class=o>=</span> <span class=n>tail</span><span class=o>)</span> <span class=o>!=</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span><span class=c1>//按访问顺序排序并且访问节点不是最后一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=o>(</span><span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>e</span><span class=o>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>before</span><span class=o>,</span> <span class=n>a</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>after</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>b</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>a</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>a</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>last</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>last</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=n>last</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>tail</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><p>remove(Object)方法是调用父类HashMap的方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>V</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>removeNode</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>))</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>            <span class=kc>null</span> <span class=o>:</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>removeNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>Object</span> <span class=n>key</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                               <span class=kt>boolean</span> <span class=n>matchValue</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>movable</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>;</span> <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>index</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>index</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>node</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>e</span><span class=o>;</span> <span class=n>K</span> <span class=n>k</span><span class=o>;</span> <span class=n>V</span> <span class=n>v</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>node</span> <span class=o>=</span> <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>p</span><span class=o>).</span><span class=na>getTreeNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>do</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                            <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                             <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                            <span class=n>node</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                            <span class=k>break</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                        <span class=o>}</span>
</span></span><span class=line><span class=cl>                        <span class=n>p</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span> <span class=k>while</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>(!</span><span class=n>matchValue</span> <span class=o>||</span> <span class=o>(</span><span class=n>v</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>value</span><span class=o>)</span> <span class=o>==</span> <span class=n>value</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                                 <span class=o>(</span><span class=n>value</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>value</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>v</span><span class=o>))))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>node</span><span class=o>).</span><span class=na>removeTreeNode</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>tab</span><span class=o>,</span> <span class=n>movable</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=n>p</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>tab</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>--</span><span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>              <span class=c1>//调用LinkedHashMap·的方法来实现双链的删除
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>afterNodeRemoval</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>afterNodeRemoval</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// unlink
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>LinkedHashMap</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>e</span><span class=o>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>before</span><span class=o>,</span> <span class=n>a</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>after</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>//把要移除节点的前驱后继置为null
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>p</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>b</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//b为null即移除的就是第一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//头指针指向移除元素的后继
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>head</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=na>after</span> <span class=o>=</span> <span class=n>a</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>a</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span><span class=c1>//a为null即移除的元素是最后一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=c1>//尾指针指向移除元素的前驱
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tail</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>a</span><span class=o>.</span><span class=na>before</span> <span class=o>=</span> <span class=n>b</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>