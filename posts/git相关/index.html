<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>git相关 | Moyuduo's Blog</title><meta name=keywords content><meta name=description content="git相关 linux下安装git yum install -y git clone #克隆指定分支 git clone -b <branchname> xxx.git <DirName> #克隆指定tag git clone -b <tag> --depth=1 xxx.git <DirName> --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢 init git init初始化一个仓库
#1.新建一个文件夹并初始化为一个仓库 mkdir proj1 cd proj1 git init #2.在当前文件夹下新建一个文件夹并初始化为仓库 git init proj2 workspace workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用git add进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的代码有冲突，都会提示:
error: Your local changes to the following files would be overwritten by checkout: file.txt Please commit your changes or stash them before you switch branches. Aborting 工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致"><meta name=author content="Me"><link rel=canonical href=https://moyuduo.github.io/posts/git%E7%9B%B8%E5%85%B3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="git相关"><meta property="og:description" content="git相关 linux下安装git yum install -y git clone #克隆指定分支 git clone -b <branchname> xxx.git <DirName> #克隆指定tag git clone -b <tag> --depth=1 xxx.git <DirName> --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢 init git init初始化一个仓库
#1.新建一个文件夹并初始化为一个仓库 mkdir proj1 cd proj1 git init #2.在当前文件夹下新建一个文件夹并初始化为仓库 git init proj2 workspace workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用git add进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的代码有冲突，都会提示:
error: Your local changes to the following files would be overwritten by checkout: file.txt Please commit your changes or stash them before you switch branches. Aborting 工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致"><meta property="og:type" content="article"><meta property="og:url" content="https://moyuduo.github.io/posts/git%E7%9B%B8%E5%85%B3/"><meta property="og:image" content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-27T16:16:14+08:00"><meta property="article:modified_time" content="2022-11-27T16:16:14+08:00"><meta property="og:site_name" content="Moyuduo's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://moyuduo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="git相关"><meta name=twitter:description content="git相关 linux下安装git yum install -y git clone #克隆指定分支 git clone -b <branchname> xxx.git <DirName> #克隆指定tag git clone -b <tag> --depth=1 xxx.git <DirName> --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢 init git init初始化一个仓库
#1.新建一个文件夹并初始化为一个仓库 mkdir proj1 cd proj1 git init #2.在当前文件夹下新建一个文件夹并初始化为仓库 git init proj2 workspace workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用git add进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的代码有冲突，都会提示:
error: Your local changes to the following files would be overwritten by checkout: file.txt Please commit your changes or stash them before you switch branches. Aborting 工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moyuduo.github.io/posts/"},{"@type":"ListItem","position":2,"name":"git相关","item":"https://moyuduo.github.io/posts/git%E7%9B%B8%E5%85%B3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"git相关","name":"git相关","description":"git相关 linux下安装git yum install -y git clone #克隆指定分支 git clone -b \u0026lt;branchname\u0026gt; xxx.git \u0026lt;DirName\u0026gt; #克隆指定tag git clone -b \u0026lt;tag\u0026gt; --depth=1 xxx.git \u0026lt;DirName\u0026gt; --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢 init git init初始化一个仓库\n#1.新建一个文件夹并初始化为一个仓库 mkdir proj1 cd proj1 git init #2.在当前文件夹下新建一个文件夹并初始化为仓库 git init proj2 workspace workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用git add进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的代码有冲突，都会提示:\nerror: Your local changes to the following files would be overwritten by checkout: file.txt Please commit your changes or stash them before you switch branches. Aborting 工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致","keywords":[],"articleBody":"git相关 linux下安装git yum install -y git clone #克隆指定分支 git clone -b xxx.git #克隆指定tag git clone -b --depth=1 xxx.git --depth 表示克隆深度, 1 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢 init git init初始化一个仓库\n#1.新建一个文件夹并初始化为一个仓库 mkdir proj1 cd proj1 git init #2.在当前文件夹下新建一个文件夹并初始化为仓库 git init proj2 workspace workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用git add进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的代码有冲突，都会提示:\nerror: Your local changes to the following files would be overwritten by checkout: file.txt Please commit your changes or stash them before you switch branches. Aborting 工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致\nstash 在使用git checkout切换分支的时候，如果有未commit的内容,那么会报错Please commit your changes or stash them before you switch branches,此时就可以先使用git stash把工作区和暂存区的内容保存起来 ，再切换分支，当回到该分支上时，使用git stash pop把存储的内容恢复到工作区和暂存区\ngit stash 并不会保存未被追踪的文件\n如果使用stash在分支上存储了内容，使用git checkout -b新开分支并不会包stash的内容保存到新开的分支\ngit stash保存的stash在任何分支上都可见，并且也可恢复到任何分支，值得注意的是stash恢复后可能与工作区产生冲突\n#存储工作区和暂存区的内容,保存的stash始终是最顶上的一个，即stash@{0} git stash git stash save \"mystash1\" #git stash push默认只会stash已追踪的文件，-u参数能stash未被追踪的文件 -m参数可以添加stash信息 git stash push -u -m \"mystash1\" #查看stash git stash list #恢复指定的stash,apply恢复stash后并不会从stash list中移除 git stash apply stash@{0} git stash apply 0 #恢复指定的stash git stash stash@{0} git stash pop 1 git stash pop stash@{1} #删除指定的stash git stash drop stash@{0} git stash drop 0 #恢复最近一次保存的stash并删除stash,即stash@{0} git stash pop #git stash pop 如果指定stash id那么不会把stash从stash list中移除 git stash pop 0 index index即为暂存区，当使用git add即把文件添加到暂存区\nworkspace和index中的代码对所有的分支都是可见的，并且都可以修改，但是一旦一个分支把index中代码提交了，其他分支就不可见了\nhead head指示某一个分支上的commit，它可以看成是一个游标，可以指向任何地方，不一定是最新的提交\ngit中~和^的区别 ~和^的区别\nbranch #查看本地分支 git branch #查看远程分支 git branch -r #查看本地和远程分支 git branch -a #新建分支 git branch #删除分支 git branch -d #在删除分支是可能报：error: The branch 's1' is not fully merged. 这是由于要删除的分支内容并没有合并到当前分支，如果确实需要删除，使用-D #另外不能删除当前checkout的分支 git branch -D #删除远程分支 git push origin -d #重命名本地分支 git branch -m checkout #切换分支 git checkout #创建并切换分支 git checkout -b #把工作区恢复成和暂存区一样的内容 git checkout -- readme.md add git add用于将文件(未追踪/已修改的追踪文件)保存到暂存区\ngit add . #把所有文件添加到暂存区(未追踪和已修改的追踪文件) git add -u #把已追踪修改了的文件添加到暂存区 git add pkg/ #把指定的文件/文件夹添加到暂存区 commit git commit用来将index中的内容提交到分支\ngit commit -m \"user commit message\" #--amend参数可以将最新index追加到上一次提交并可以修改上一次的提交信息，但是值得注意的是会修改上一次提交的commit id git commit --amend mv git mv用于重命名被git跟踪的文件\n#1.如果使用传统的 mv命令进行重命名 mv aaa.txt AAA #git不区别文件名的大小写，也就是说aaa.txt和AAA.txt会被git认为是同一个文件名 $ git status On branch master Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git restore ...\" to discard changes in working directory) deleted: aaa.txt Untracked files: (use \"git add ...\" to include in what will be committed) AAA no changes added to commit (use \"git add\" and/or \"git commit -a\") git add aaa.txt git add AAA $ git status On branch master Changes to be committed: (use \"git restore --staged ...\" to unstage) renamed: aaa.txt -\u003e AAA #git会识别aaa.txt 重命名为了 AAA #2.直接通过git mv重命名 git mv AAA aaa.txt $ git status On branch master Changes to be committed: (use \"git restore --staged ...\" to unstage) renamed: AAA -\u003e aaa.txt rm git rm用于删除已经被git追踪的文件\n#1.使用rm删除后需要使用git add命令添加指定的删除文件才能被git staged rm test git add test #2.使用git rm删除文件，直接被git staged git rm test log #查看 commit 树 --all 查看所有分支，默认只查看当前分支 --graph以图形化的方式显示分支的关系 --oneline值显示commit的id和message忽略作者和时间 git log --all --graph --oneline gitk fetch 把远程分支的代码拉到本地\n#拉取到本地后，会创建一个FETCH_HEAD的log git fetch git fetch #拉取远程分支到本地并重命名为local_branchname git fetch : #拉取github的pr到本地进行测试 git fetch origin pull//head: git log -p FETCH_HEAD git checkout -b / #or git checkout -b FETCH_HEAD pull pull相当于fetch+merge\n#将当前分支和远程分支关联，关联后可以直接使用git push/pull 推送/拉取代码 git pull --set-upstream #拉取远程分支到本地创建分支，并把该分支同当前分支合并 git pull : #拉取远程分支与当前分支合并 git pull #如果未设置本地分支和远程分支的绑定关系，使用git pull会把所有的远程分支fetch到本地，可以通过git branch -av 查看，需要再和本地合并 git pull git branch -av git merge origin/dev #git pull不管有没有设置本地分支与远程分支相关联，都会把所有的远程分支拉取到本地，如果设置了--set-upstream那个会把当前分支和对应远程分支合并，否则都不会merge，可以通过git brach -vv查看 git pull merge git checkout master git pull git checkout -b feat/xxx #edit on breanch feat/xxx git checkout master #无冲突情况 git merge feat/xxx Updating 92a1fa3..287df05 Fast-forward featb.txt | 1 + file.txt | 1 + 2 files changed, 2 insertions(+) create mode 100644 featb.txt #有冲突情况 git merge feat/xxx Auto-merging featb.txt CONFLICT (content): Merge conflict in featb.txt Automatic merge failed; fix conflicts and then commit the result. 需要手动解决冲突 git add . git commit -m \"resolve confilict\" rebase 使用git rebase xxx合并分支\n#无冲突 git rebase master Successfully rebased and updated refs/heads/feat/b. #有冲突 git rebase master First, rewinding head to replay your work on top of it... Applying: feat/b Using index info to reconstruct a base tree... M featb.txt Falling back to patching base and 3-way merge... Auto-merging featb.txt CONFLICT (content): Merge conflict in featb.txt error: Failed to merge in the changes. hint: Use 'git am --show-current-patch' to see the failed patch Patch failed at 0001 feat/b Resolve all conflicts manually, mark them as resolved with \"git add/rm \", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". 手动解决冲突 git add . git rebase --continue #放弃合并，回滚到合并之前的状态 git rebase --abort 使用git rebase重新编辑commit message\n#基于拿个 commitid 做rebase，会依次从该commitid之后的第一个commit到HEAD直接把所有commit基于前一个commit rebase git rebase git rebase -i HEAD~3 pick 70a0b1a init branch feat/a s 4d948a4 init branch feat/a pick 3ad857e feat pick c45f31d ffff Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop = remove commit # l, label = label current HEAD with a name # t, reset = reset HEAD to a label # m, merge [-C | -c ] [# ] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c to reword the commit message. :wq 使用git rebase可以把多次commit合并为一次commit,避免在进行git push时推送过多的commit,rebase会改变commit id\n#查看提交的commit信息 git log #使用rebase合并commit #HEAD~3表示合并最近的三次commit #打开文件后修改pick为Commands锁提示的指令 #git rebase -i a91e660d #a91e660d为git log记录的commit号，当前最新提交到该commit号之间的commit进行rebase git rebase -i HEAD~3 pick 70a0b1a init branch feat/a pick 4d948a4 init branch feat/a s 3ad857e feat s c45f31d ffff Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop = remove commit # l, label = label current HEAD with a name # t, reset = reset HEAD to a label # m, merge [-C | -c ] [# ] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c to reword the commit message. :wq 使用git rebase把几个不连续的commit合成一个commit\ngit rebase -i HEAD~3 #本来的结构如下，commit自上而下依次为从旧到新 #pick 70a0b1a init branch feat/a #pick 4d948a4 init branch feat/a #pick 3ad857e feat #pick c45f31d ffff #改变commit排列的顺序，把两个不相连的要合并为一个commit的两个commit放一起 pick 70a0b1a init branch feat/a pick 4d948a4 init branch feat/a s c45f31d ffff pick 3ad857e feat Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop = remove commit # l, label = label current HEAD with a name # t, reset = reset HEAD to a label # m, merge [-C | -c ] [# ] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c to reword the commit message. push push把本地分支的代码推送到远程指定分支\n#将当前分支和远程分支关联，关联后可以直接使用git push/pull 推送/拉取代码 git push --set-upstream git push : #如果要推送的本地分支名和远程分支名同名 git push #也可以使用更加精简的写法,该种写法必须要已经设置了--set-upstream，可以通过git branch -vv查看有没有设置本地分支和远端分支的绑定关系 git push #但是有可能会提示 fatal:The current branch has no upstream branch 即当前本地分支没有和远程分支绑定，本地没有对应关系 git push --set-upstream orgin #下次再直接git push就不再提示 #或者修改.git文件夹下面的config文件，.git文件夹针对一个项目的所有分支都是一致的，保存了整个项目的相关信息 [branch \"main\"] remote = origin merge = refs/heads/main reset重置 #回退到指定版本,默认保留暂存区和工作区内容 git reset HEAD^ #保留工作区和暂存区的内容，回退到指定版本 git reset --soft HEAD^ #不保留工作区和暂存区的内容，回退到指定版本 git reset --hard HEAD^ #回退到前3次提交之前，以此类推，回退到n次提交之前 git reset --soft HEAD~3 #退到/进到 指定commit的sha码 git reset --soft commit_id #把暂存区恢复成HEAD的内容 git reset HEAD git reset HEAD -- readme.md aaa.txt #版本穿梭 git reflog #查看历史，该指令会也会记录版本穿梭的记录 git log --all --graph --oneline #查看所有的commitid也可用于版本穿梭 git reset --hard #回退历史或前进历史，使用git rest之后head指针指向重置的commitid，先于commitid的记录不可见 revert恢复 git log #git revert用于恢复某一次操作的，如某一次commit提交了修改，那个git revert就去除这些修改，但是与git reset不同的是，git reset会消除reset commitid之后的记录，而git revert不会 #它会生成一个新的commit记录revert操作 git revert #有冲突 #修改 git add . git revert --continue #放弃回滚 git revert --abort diff查看变动 git diff 显示工作目录已追踪文件与暂存区的差异 git diff –-cached/--staged 显示暂存区文件与本地库之间的差异 git diff commit_id1 commit_id2 比较在 commit_id1 的基础上 commit_id2 做了哪些修改 git diff commit_id 等价于 git diff commit_id HEAD git diff HEAD 显示工作目录与本地库之间的差异 git diff HEAD^ 显示工作目录与上上次提交之间的差异，一般用于在git pull之后查看他人对文件修改情况 $ git diff --name-status #查看表更的文件夹列表 M readme.md git diff -- readme.md aaa.txt #查看指定文件的变更 git diff master dev #比较dev分支的HEAD和master分支HEAD的差异，本质master/dev都是指向一个commitid config 当push项目的时候我们配置的用户信息会上传到库，方便其他开发人员看是谁做了变更\n所以需要我们修改为自己的有效信息，方便别人识别\ngit中有两种配置，一种是local，只针对当前的这个项目，一种是global，针对所有的库，如果local中进行了相关配合，那么优先使用local中的配置\n#查看local、global配置 git config --local --list git config --global --list #更新提交的用户的信息 git config --global user.name litao git config --global user.email taoli@yunify.com #或 git config --local user.name litao git config --local user.email taoli@yunify.com #设置 pull 合并冲突策略为 rebase #仅针对分支有效 git config branch.{branch_name}.rebase true #全局有效 git config --global branch.autosetuprebase always 拉取远程分支到本地 git fetch origin dev git checkout -b dev origin/dev 查看本地分支和远程分支的追踪关系 git branch -vv 设置git不追踪配置文件 git update-index --assume-unchanged /path/file #设置忽略跟踪 git update-index --no-assume-unchanged /path/to/file #恢复跟踪 https://www.cnblogs.com/fengxiaopanblog/p/10503346.html\n","wordCount":"1529","inLanguage":"en","datePublished":"2022-11-27T16:16:14+08:00","dateModified":"2022-11-27T16:16:14+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moyuduo.github.io/posts/git%E7%9B%B8%E5%85%B3/"},"publisher":{"@type":"Organization","name":"Moyuduo's Blog","logo":{"@type":"ImageObject","url":"https://moyuduo.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moyuduo.github.io/ accesskey=h title="Moyuduo's Blog (Alt + H)"><img src=https://moyuduo.github.io/apple-touch-icon.png alt aria-label=logo height=35>Moyuduo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://moyuduo.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://moyuduo.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://moyuduo.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://moyuduo.github.io/posts/>Posts</a></div><h1 class=post-title>git相关</h1><div class=post-meta><span title='2022-11-27 16:16:14 +0800 +0800'>November 27, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1529 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/git%e7%9b%b8%e5%85%b3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=git相关>git相关<a hidden class=anchor aria-hidden=true href=#git相关>#</a></h1><h2 id=linux下安装git>linux下安装git<a hidden class=anchor aria-hidden=true href=#linux下安装git>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>yum install -y git
</span></span></code></pre></div><h2 id=clone>clone<a hidden class=anchor aria-hidden=true href=#clone>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#克隆指定分支</span>
</span></span><span class=line><span class=cl>git clone -b &lt;branchname&gt; xxx.git &lt;DirName&gt;
</span></span><span class=line><span class=cl><span class=c1>#克隆指定tag</span>
</span></span><span class=line><span class=cl>git clone -b &lt;tag&gt; --depth<span class=o>=</span><span class=m>1</span> xxx.git &lt;DirName&gt;
</span></span><span class=line><span class=cl>--depth 表示克隆深度, <span class=m>1</span> 表示只克隆最新的版本. 因为如果项目迭代的版本很多, 克隆会很慢
</span></span></code></pre></div><h2 id=init>init<a hidden class=anchor aria-hidden=true href=#init>#</a></h2><p><code>git init</code>初始化一个仓库</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#1.新建一个文件夹并初始化为一个仓库</span>
</span></span><span class=line><span class=cl>mkdir proj1
</span></span><span class=line><span class=cl><span class=nb>cd</span> proj1
</span></span><span class=line><span class=cl>git init
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#2.在当前文件夹下新建一个文件夹并初始化为仓库</span>
</span></span><span class=line><span class=cl>git init proj2
</span></span></code></pre></div><h2 id=workspace>workspace<a hidden class=anchor aria-hidden=true href=#workspace>#</a></h2><p>workspace即为工作区，当在任何分支下进行代码操作都是在工作区下进行的，如果没有使用<code>git add</code>进行缓存，或进行了缓存，但是工作区或暂存区内的代码和要切换的分支的<strong>代码有冲突</strong>，都会提示:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>error: Your <span class=nb>local</span> changes to the following files would be overwritten by checkout:
</span></span><span class=line><span class=cl>        file.txt
</span></span><span class=line><span class=cl>Please commit your changes or stash them before you switch branches.
</span></span><span class=line><span class=cl>Aborting
</span></span></code></pre></div><p><strong>工作区和暂存区对所有分支是可见的，也就是说在切换分支之前应该保持工作区、暂存区、HEAD一致</strong></p><h2 id=stash>stash<a hidden class=anchor aria-hidden=true href=#stash>#</a></h2><p>在使用<code>git checkout</code>切换分支的时候，如果有未<code>commit</code>的内容,那么会报错<code>Please commit your changes or stash them before you switch branches</code>,此时就可以先使用<code>git stash</code>把工作区和暂存区的内容保存起来
，再切换分支，当回到该分支上时，使用<code>git stash pop</code>把存储的内容恢复到工作区和暂存区</p><p><code>git stash</code> 并不会保存未被追踪的文件</p><p>如果使用<code>stash</code>在分支上存储了内容，使用<code>git checkout -b</code>新开分支并不会包<code>stash</code>的内容保存到新开的分支</p><p><code>git stash</code>保存的<code>stash</code>在任何分支上都可见，并且也可恢复到任何分支，值得注意的是<code>stash</code>恢复后可能与工作区产生冲突</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#存储工作区和暂存区的内容,保存的stash始终是最顶上的一个，即stash@{0}</span>
</span></span><span class=line><span class=cl>git stash
</span></span><span class=line><span class=cl>git stash save <span class=s2>&#34;mystash1&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>#git stash push默认只会stash已追踪的文件，-u参数能stash未被追踪的文件 -m参数可以添加stash信息</span>
</span></span><span class=line><span class=cl>git stash push -u -m <span class=s2>&#34;mystash1&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看stash</span>
</span></span><span class=line><span class=cl>git stash list
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#恢复指定的stash,apply恢复stash后并不会从stash list中移除</span>
</span></span><span class=line><span class=cl>git stash apply stash@<span class=o>{</span>0<span class=o>}</span>
</span></span><span class=line><span class=cl>git stash apply <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#恢复指定的stash</span>
</span></span><span class=line><span class=cl>git stash stash@<span class=o>{</span>0<span class=o>}</span>
</span></span><span class=line><span class=cl>git stash pop <span class=m>1</span>
</span></span><span class=line><span class=cl>git stash pop stash@<span class=o>{</span>1<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除指定的stash</span>
</span></span><span class=line><span class=cl>git stash drop stash@<span class=o>{</span>0<span class=o>}</span>
</span></span><span class=line><span class=cl>git stash drop <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#恢复最近一次保存的stash并删除stash,即stash@{0}</span>
</span></span><span class=line><span class=cl>git stash pop
</span></span><span class=line><span class=cl><span class=c1>#git stash pop 如果指定stash id那么不会把stash从stash list中移除</span>
</span></span><span class=line><span class=cl>git stash pop <span class=m>0</span>
</span></span></code></pre></div><h2 id=index>index<a hidden class=anchor aria-hidden=true href=#index>#</a></h2><p>index即为暂存区，当使用<code>git add</code>即把文件添加到暂存区</p><p>workspace和index中的代码对所有的分支都是可见的，并且都可以修改，但是一旦一个分支把index中代码提交了，其他分支就不可见了</p><h2 id=head>head<a hidden class=anchor aria-hidden=true href=#head>#</a></h2><p>head指示某一个分支上的commit，它可以看成是一个游标，可以指向任何地方，不一定是最新的提交</p><h2 id=git中和的区别>git中<code>~</code>和<code>^</code>的区别<a hidden class=anchor aria-hidden=true href=#git中和的区别>#</a></h2><p><a href=https://www.jianshu.com/p/6ce13ce46d8b>~和^的区别</a></p><h2 id=branch>branch<a hidden class=anchor aria-hidden=true href=#branch>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看本地分支</span>
</span></span><span class=line><span class=cl>git branch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看远程分支</span>
</span></span><span class=line><span class=cl>git branch -r 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#查看本地和远程分支</span>
</span></span><span class=line><span class=cl>git branch -a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#新建分支</span>
</span></span><span class=line><span class=cl>git branch &lt;branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除分支</span>
</span></span><span class=line><span class=cl>git branch -d &lt;branchname&gt;
</span></span><span class=line><span class=cl><span class=c1>#在删除分支是可能报：error: The branch &#39;s1&#39; is not fully merged. 这是由于要删除的分支内容并没有合并到当前分支，如果确实需要删除，使用-D</span>
</span></span><span class=line><span class=cl><span class=c1>#另外不能删除当前checkout的分支</span>
</span></span><span class=line><span class=cl>git branch -D &lt;branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#删除远程分支</span>
</span></span><span class=line><span class=cl> git push origin -d &lt;branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#重命名本地分支</span>
</span></span><span class=line><span class=cl>git branch -m &lt;old_branchname&gt; &lt;new_branchname&gt;
</span></span></code></pre></div><h2 id=checkout>checkout<a hidden class=anchor aria-hidden=true href=#checkout>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#切换分支</span>
</span></span><span class=line><span class=cl>git checkout &lt;branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#创建并切换分支</span>
</span></span><span class=line><span class=cl>git checkout -b &lt;branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#把工作区恢复成和暂存区一样的内容</span>
</span></span><span class=line><span class=cl>git checkout -- readme.md
</span></span></code></pre></div><h2 id=add>add<a hidden class=anchor aria-hidden=true href=#add>#</a></h2><p><code>git add</code>用于将文件(未追踪/已修改的追踪文件)保存到暂存区</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git add .   <span class=c1>#把所有文件添加到暂存区(未追踪和已修改的追踪文件)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git add -u  <span class=c1>#把已追踪修改了的文件添加到暂存区</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git add pkg/    <span class=c1>#把指定的文件/文件夹添加到暂存区</span>
</span></span></code></pre></div><h2 id=commit>commit<a hidden class=anchor aria-hidden=true href=#commit>#</a></h2><p><code>git commit</code>用来将index中的内容提交到分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git commit -m <span class=s2>&#34;user commit message&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#--amend参数可以将最新index追加到上一次提交并可以修改上一次的提交信息，但是值得注意的是会修改上一次提交的commit id</span>
</span></span><span class=line><span class=cl>git commit --amend
</span></span></code></pre></div><h2 id=mv>mv<a hidden class=anchor aria-hidden=true href=#mv>#</a></h2><p><code>git mv</code>用于重命名被git跟踪的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#1.如果使用传统的 mv命令进行重命名</span>
</span></span><span class=line><span class=cl>mv aaa.txt AAA  <span class=c1>#git不区别文件名的大小写，也就是说aaa.txt和AAA.txt会被git认为是同一个文件名</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes not staged <span class=k>for</span> commit:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git add/rm &lt;file&gt;...&#34;</span> to update what will be committed<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span class=o>)</span>
</span></span><span class=line><span class=cl>        deleted:    aaa.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Untracked files:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class=o>)</span>
</span></span><span class=line><span class=cl>        AAA
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>no changes added to commit <span class=o>(</span>use <span class=s2>&#34;git add&#34;</span> and/or <span class=s2>&#34;git commit -a&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git add aaa.txt
</span></span><span class=line><span class=cl>git add AAA
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes to be committed:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span class=o>)</span>
</span></span><span class=line><span class=cl>        renamed:    aaa.txt -&gt; AAA  <span class=c1>#git会识别aaa.txt 重命名为了 AAA</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#2.直接通过git mv重命名</span>
</span></span><span class=line><span class=cl> git mv AAA aaa.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> $ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes to be committed:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span class=o>)</span>
</span></span><span class=line><span class=cl>        renamed:    AAA -&gt; aaa.txt
</span></span></code></pre></div><h2 id=rm>rm<a hidden class=anchor aria-hidden=true href=#rm>#</a></h2><p><code>git rm</code>用于删除已经被git追踪的文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#1.使用rm删除后需要使用git add命令添加指定的删除文件才能被git staged</span>
</span></span><span class=line><span class=cl>rm <span class=nb>test</span>
</span></span><span class=line><span class=cl>git add <span class=nb>test</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#2.使用git rm删除文件，直接被git staged</span>
</span></span><span class=line><span class=cl>git rm <span class=nb>test</span>
</span></span></code></pre></div><h2 id=log>log<a hidden class=anchor aria-hidden=true href=#log>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看 commit 树 --all 查看所有分支，默认只查看当前分支 --graph以图形化的方式显示分支的关系  --oneline值显示commit的id和message忽略作者和时间</span>
</span></span><span class=line><span class=cl>git log --all --graph --oneline
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gitk
</span></span></code></pre></div><h2 id=fetch>fetch<a hidden class=anchor aria-hidden=true href=#fetch>#</a></h2><p>把远程分支的代码拉到本地</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#拉取到本地后，会创建一个FETCH_HEAD的log</span>
</span></span><span class=line><span class=cl>git fetch &lt;remote_host&gt;
</span></span><span class=line><span class=cl>git fetch &lt;remote_host&gt; &lt;remote_branchname&gt;
</span></span><span class=line><span class=cl><span class=c1>#拉取远程分支到本地并重命名为local_branchname</span>
</span></span><span class=line><span class=cl>git fetch &lt;remote_host&gt; &lt;remote_branchname&gt;:&lt;local_branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#拉取github的pr到本地进行测试</span>
</span></span><span class=line><span class=cl>git fetch origin pull/&lt;ID&gt;/head:&lt;local_branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git log -p FETCH_HEAD
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git checkout -b &lt;local_branch&gt; &lt;remote_host&gt;/&lt;remote_branchname&gt;
</span></span><span class=line><span class=cl><span class=c1>#or</span>
</span></span><span class=line><span class=cl>git checkout -b &lt;local_branch&gt; FETCH_HEAD
</span></span></code></pre></div><h2 id=pull>pull<a hidden class=anchor aria-hidden=true href=#pull>#</a></h2><p>pull相当于fetch+merge</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#将当前分支和远程分支关联，关联后可以直接使用git push/pull 推送/拉取代码</span>
</span></span><span class=line><span class=cl>git pull --set-upstream &lt;remote_host&gt; &lt;local_branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#拉取远程分支到本地创建&lt;local_branch&gt;分支，并把该分支同当前分支合并</span>
</span></span><span class=line><span class=cl>git pull &lt;remote_host&gt; &lt;remote_branch&gt;:&lt;local_branch&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#拉取远程分支与当前分支合并</span>
</span></span><span class=line><span class=cl>git pull &lt;remote_host&gt; &lt;remote_branch&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#如果未设置本地分支和远程分支的绑定关系，使用git pull会把所有的远程分支fetch到本地，可以通过git branch -av 查看，需要再和本地合并</span>
</span></span><span class=line><span class=cl>git pull
</span></span><span class=line><span class=cl>git branch -av
</span></span><span class=line><span class=cl>git merge origin/dev
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#git pull不管有没有设置本地分支与远程分支相关联，都会把所有的远程分支拉取到本地，如果设置了--set-upstream那个会把当前分支和对应远程分支合并，否则都不会merge，可以通过git brach -vv查看</span>
</span></span><span class=line><span class=cl>git pull
</span></span></code></pre></div><h2 id=merge>merge<a hidden class=anchor aria-hidden=true href=#merge>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout master
</span></span><span class=line><span class=cl>git pull
</span></span><span class=line><span class=cl>git checkout -b feat/xxx
</span></span><span class=line><span class=cl><span class=c1>#edit on breanch feat/xxx</span>
</span></span><span class=line><span class=cl>git checkout master
</span></span><span class=line><span class=cl><span class=c1>#无冲突情况</span>
</span></span><span class=line><span class=cl>git merge feat/xxx
</span></span><span class=line><span class=cl>Updating 92a1fa3..287df05
</span></span><span class=line><span class=cl>Fast-forward
</span></span><span class=line><span class=cl> featb.txt <span class=p>|</span> <span class=m>1</span> +
</span></span><span class=line><span class=cl> file.txt  <span class=p>|</span> <span class=m>1</span> +
</span></span><span class=line><span class=cl> <span class=m>2</span> files changed, <span class=m>2</span> insertions<span class=o>(</span>+<span class=o>)</span>
</span></span><span class=line><span class=cl> create mode <span class=m>100644</span> featb.txt
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> <span class=c1>#有冲突情况</span>
</span></span><span class=line><span class=cl> git merge feat/xxx
</span></span><span class=line><span class=cl> Auto-merging featb.txt
</span></span><span class=line><span class=cl>CONFLICT <span class=o>(</span>content<span class=o>)</span>: Merge conflict in featb.txt
</span></span><span class=line><span class=cl>Automatic merge failed<span class=p>;</span> fix conflicts and <span class=k>then</span> commit the result.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>需要手动解决冲突
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;resolve confilict&#34;</span>
</span></span></code></pre></div><h2 id=rebase>rebase<a hidden class=anchor aria-hidden=true href=#rebase>#</a></h2><p>使用<code>git rebase xxx</code>合并分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#无冲突</span>
</span></span><span class=line><span class=cl>git rebase master
</span></span><span class=line><span class=cl>Successfully rebased and updated refs/heads/feat/b.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#有冲突</span>
</span></span><span class=line><span class=cl>git rebase master
</span></span><span class=line><span class=cl>First, rewinding head to replay your work on top of it...
</span></span><span class=line><span class=cl>Applying: feat/b
</span></span><span class=line><span class=cl>Using index info to reconstruct a base tree...
</span></span><span class=line><span class=cl>M       featb.txt
</span></span><span class=line><span class=cl>Falling back to patching base and 3-way merge...
</span></span><span class=line><span class=cl>Auto-merging featb.txt
</span></span><span class=line><span class=cl>CONFLICT <span class=o>(</span>content<span class=o>)</span>: Merge conflict in featb.txt
</span></span><span class=line><span class=cl>error: Failed to merge in the changes.
</span></span><span class=line><span class=cl>hint: Use <span class=s1>&#39;git am --show-current-patch&#39;</span> to see the failed patch
</span></span><span class=line><span class=cl>Patch failed at <span class=m>0001</span> feat/b
</span></span><span class=line><span class=cl>Resolve all conflicts manually, mark them as resolved with
</span></span><span class=line><span class=cl><span class=s2>&#34;git add/rm &lt;conflicted_files&gt;&#34;</span>, <span class=k>then</span> run <span class=s2>&#34;git rebase --continue&#34;</span>.
</span></span><span class=line><span class=cl>You can instead skip this commit: run <span class=s2>&#34;git rebase --skip&#34;</span>.
</span></span><span class=line><span class=cl>To abort and get back to the state before <span class=s2>&#34;git rebase&#34;</span>, run <span class=s2>&#34;git rebase --abort&#34;</span>.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>手动解决冲突
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git rebase --continue
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#放弃合并，回滚到合并之前的状态</span>
</span></span><span class=line><span class=cl>git rebase --abort
</span></span></code></pre></div><p>使用<code>git rebase</code>重新编辑commit message</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#基于拿个 commitid 做rebase，会依次从该commitid之后的第一个commit到HEAD直接把所有commit基于前一个commit rebase</span>
</span></span><span class=line><span class=cl>git rebase &lt;commitid&gt;
</span></span><span class=line><span class=cl>git rebase -i HEAD~3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pick 70a0b1a init branch feat/a
</span></span><span class=line><span class=cl>s 4d948a4 init branch feat/a
</span></span><span class=line><span class=cl>pick 3ad857e feat
</span></span><span class=line><span class=cl>pick c45f31d ffff
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> Commands:
</span></span><span class=line><span class=cl><span class=c1># p, pick &lt;commit&gt; = use commit</span>
</span></span><span class=line><span class=cl><span class=c1># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span class=line><span class=cl><span class=c1># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span class=line><span class=cl><span class=c1># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span class=line><span class=cl><span class=c1># f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message</span>
</span></span><span class=line><span class=cl><span class=c1># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span class=line><span class=cl><span class=c1># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span class=line><span class=cl><span class=c1># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span class=line><span class=cl><span class=c1># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span class=line><span class=cl><span class=c1># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span class=line><span class=cl><span class=c1># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span class=line><span class=cl><span class=c1># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span class=line><span class=cl><span class=c1># .       message (or the oneline, if no original merge commit was</span>
</span></span><span class=line><span class=cl><span class=c1># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>:wq
</span></span></code></pre></div><p>使用<code>git rebase</code>可以把多次commit合并为一次commit,避免在进行<code>git push</code>时推送过多的commit,rebase会改变commit id</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看提交的commit信息</span>
</span></span><span class=line><span class=cl>git log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#使用rebase合并commit</span>
</span></span><span class=line><span class=cl><span class=c1>#HEAD~3表示合并最近的三次commit</span>
</span></span><span class=line><span class=cl><span class=c1>#打开文件后修改pick为Commands锁提示的指令</span>
</span></span><span class=line><span class=cl><span class=c1>#git rebase -i a91e660d</span>
</span></span><span class=line><span class=cl><span class=c1>#a91e660d为git log记录的commit号，当前最新提交到该commit号之间的commit进行rebase</span>
</span></span><span class=line><span class=cl>git rebase -i HEAD~3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pick 70a0b1a init branch feat/a
</span></span><span class=line><span class=cl>pick 4d948a4 init branch feat/a
</span></span><span class=line><span class=cl>s 3ad857e feat
</span></span><span class=line><span class=cl>s c45f31d ffff
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> Commands:
</span></span><span class=line><span class=cl><span class=c1># p, pick &lt;commit&gt; = use commit</span>
</span></span><span class=line><span class=cl><span class=c1># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span class=line><span class=cl><span class=c1># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span class=line><span class=cl><span class=c1># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span class=line><span class=cl><span class=c1># f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message</span>
</span></span><span class=line><span class=cl><span class=c1># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span class=line><span class=cl><span class=c1># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span class=line><span class=cl><span class=c1># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span class=line><span class=cl><span class=c1># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span class=line><span class=cl><span class=c1># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span class=line><span class=cl><span class=c1># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span class=line><span class=cl><span class=c1># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span class=line><span class=cl><span class=c1># .       message (or the oneline, if no original merge commit was</span>
</span></span><span class=line><span class=cl><span class=c1># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>:wq
</span></span></code></pre></div><p>使用<code>git rebase</code>把几个不连续的commit合成一个commit</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git rebase -i HEAD~3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#本来的结构如下，commit自上而下依次为从旧到新</span>
</span></span><span class=line><span class=cl><span class=c1>#pick 70a0b1a init branch feat/a</span>
</span></span><span class=line><span class=cl><span class=c1>#pick 4d948a4 init branch feat/a</span>
</span></span><span class=line><span class=cl><span class=c1>#pick 3ad857e feat</span>
</span></span><span class=line><span class=cl><span class=c1>#pick c45f31d ffff</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#改变commit排列的顺序，把两个不相连的要合并为一个commit的两个commit放一起</span>
</span></span><span class=line><span class=cl>pick 70a0b1a init branch feat/a
</span></span><span class=line><span class=cl>pick 4d948a4 init branch feat/a
</span></span><span class=line><span class=cl>s c45f31d ffff
</span></span><span class=line><span class=cl>pick 3ad857e feat
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> Commands:
</span></span><span class=line><span class=cl><span class=c1># p, pick &lt;commit&gt; = use commit</span>
</span></span><span class=line><span class=cl><span class=c1># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span class=line><span class=cl><span class=c1># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span class=line><span class=cl><span class=c1># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span class=line><span class=cl><span class=c1># f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message</span>
</span></span><span class=line><span class=cl><span class=c1># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span class=line><span class=cl><span class=c1># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span class=line><span class=cl><span class=c1># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span class=line><span class=cl><span class=c1># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span class=line><span class=cl><span class=c1># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span class=line><span class=cl><span class=c1># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span class=line><span class=cl><span class=c1># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span class=line><span class=cl><span class=c1># .       message (or the oneline, if no original merge commit was</span>
</span></span><span class=line><span class=cl><span class=c1># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</span></span></code></pre></div><h2 id=push>push<a hidden class=anchor aria-hidden=true href=#push>#</a></h2><p>push把本地分支的代码推送到远程指定分支</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#将当前分支和远程分支关联，关联后可以直接使用git push/pull 推送/拉取代码</span>
</span></span><span class=line><span class=cl>git push --set-upstream &lt;remote_host&gt; &lt;local_branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git push &lt;remote_host&gt; &lt;local_branchname&gt;:&lt;remote_branchname&gt;
</span></span><span class=line><span class=cl><span class=c1>#如果要推送的本地分支名和远程分支名同名</span>
</span></span><span class=line><span class=cl>git push &lt;remote_host&gt; &lt;local_branchname&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#也可以使用更加精简的写法,该种写法必须要已经设置了--set-upstream，可以通过git branch -vv查看有没有设置本地分支和远端分支的绑定关系</span>
</span></span><span class=line><span class=cl>git push
</span></span><span class=line><span class=cl><span class=c1>#但是有可能会提示 fatal:The current branch &lt;local_branchname&gt; has no upstream branch 即当前本地分支没有和远程分支绑定，本地没有对应关系</span>
</span></span><span class=line><span class=cl>git push --set-upstream orgin &lt;remote_branchname&gt;	<span class=c1>#下次再直接git push就不再提示</span>
</span></span><span class=line><span class=cl><span class=c1>#或者修改.git文件夹下面的config文件，.git文件夹针对一个项目的所有分支都是一致的，保存了整个项目的相关信息</span>
</span></span><span class=line><span class=cl><span class=o>[</span>branch <span class=s2>&#34;main&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>	<span class=nv>remote</span> <span class=o>=</span> origin
</span></span><span class=line><span class=cl>	<span class=nv>merge</span> <span class=o>=</span> refs/heads/main
</span></span></code></pre></div><h2 id=reset重置>reset重置<a hidden class=anchor aria-hidden=true href=#reset重置>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#回退到指定版本,默认保留暂存区和工作区内容</span>
</span></span><span class=line><span class=cl>git reset HEAD^ 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#保留工作区和暂存区的内容，回退到指定版本</span>
</span></span><span class=line><span class=cl>git reset --soft HEAD^ 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#不保留工作区和暂存区的内容，回退到指定版本</span>
</span></span><span class=line><span class=cl>git reset --hard HEAD^
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#回退到前3次提交之前，以此类推，回退到n次提交之前</span>
</span></span><span class=line><span class=cl>git reset --soft HEAD~3 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#退到/进到 指定commit的sha码</span>
</span></span><span class=line><span class=cl>git reset --soft commit_id 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#把暂存区恢复成HEAD的内容</span>
</span></span><span class=line><span class=cl>git reset HEAD
</span></span><span class=line><span class=cl>git reset HEAD -- readme.md aaa.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#版本穿梭</span>
</span></span><span class=line><span class=cl>git reflog <span class=c1>#查看历史，该指令会也会记录版本穿梭的记录</span>
</span></span><span class=line><span class=cl>git log --all --graph --oneline <span class=c1>#查看所有的commitid也可用于版本穿梭</span>
</span></span><span class=line><span class=cl>git reset --hard &lt;reflog id&gt;    <span class=c1>#回退历史或前进历史，使用git rest之后head指针指向重置的commitid，先于commitid的记录不可见</span>
</span></span></code></pre></div><h2 id=revert恢复>revert恢复<a hidden class=anchor aria-hidden=true href=#revert恢复>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#git revert用于恢复某一次操作的，如某一次commit提交了修改，那个git revert就去除这些修改，但是与git reset不同的是，git reset会消除reset commitid之后的记录，而git revert不会</span>
</span></span><span class=line><span class=cl><span class=c1>#它会生成一个新的commit记录revert操作</span>
</span></span><span class=line><span class=cl>git revert &lt;commit id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#有冲突</span>
</span></span><span class=line><span class=cl><span class=c1>#修改</span>
</span></span><span class=line><span class=cl>git add .
</span></span><span class=line><span class=cl>git revert --continue 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#放弃回滚</span>
</span></span><span class=line><span class=cl>git revert --abort
</span></span></code></pre></div><h2 id=diff查看变动>diff查看变动<a hidden class=anchor aria-hidden=true href=#diff查看变动>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git diff 显示工作目录已追踪文件与暂存区的差异
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff –-cached/--staged 显示暂存区文件与本地库之间的差异
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff commit_id1 commit_id2 比较在 commit_id1 的基础上 commit_id2 做了哪些修改
</span></span><span class=line><span class=cl>git diff commit_id 等价于 git diff commit_id HEAD
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff HEAD 显示工作目录与本地库之间的差异
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff HEAD^ 显示工作目录与上上次提交之间的差异，一般用于在git pull之后查看他人对文件修改情况
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git diff --name-status <span class=c1>#查看表更的文件夹列表</span>
</span></span><span class=line><span class=cl>M       readme.md
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff -- readme.md aaa.txt <span class=c1>#查看指定文件的变更</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>git diff master dev <span class=c1>#比较dev分支的HEAD和master分支HEAD的差异，本质master/dev都是指向一个commitid</span>
</span></span></code></pre></div><h2 id=config>config<a hidden class=anchor aria-hidden=true href=#config>#</a></h2><p>当push项目的时候我们配置的用户信息会上传到库，方便其他开发人员看是谁做了变更</p><p><img loading=lazy src=./images/Snipaste_2021-09-24_14-25-42.jpg alt></p><p>所以需要我们修改为自己的有效信息，方便别人识别</p><p>git中有两种配置，一种是local，只针对当前的这个项目，一种是global，针对所有的库，如果local中进行了相关配合，那么优先使用local中的配置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#查看local、global配置</span>
</span></span><span class=line><span class=cl>git config --local --list
</span></span><span class=line><span class=cl>git config --global --list
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#更新提交的用户的信息</span>
</span></span><span class=line><span class=cl>git config --global user.name litao
</span></span><span class=line><span class=cl>git config --global user.email taoli@yunify.com
</span></span><span class=line><span class=cl><span class=c1>#或</span>
</span></span><span class=line><span class=cl>git config --local user.name litao
</span></span><span class=line><span class=cl>git config --local user.email taoli@yunify.com
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#设置 pull 合并冲突策略为 rebase</span>
</span></span><span class=line><span class=cl><span class=c1>#仅针对分支有效</span>
</span></span><span class=line><span class=cl>git config branch.<span class=o>{</span>branch_name<span class=o>}</span>.rebase <span class=nb>true</span>
</span></span><span class=line><span class=cl><span class=c1>#全局有效</span>
</span></span><span class=line><span class=cl>git config --global branch.autosetuprebase always
</span></span></code></pre></div><h2 id=拉取远程分支到本地>拉取远程分支到本地<a hidden class=anchor aria-hidden=true href=#拉取远程分支到本地>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git fetch origin dev
</span></span><span class=line><span class=cl>git checkout -b dev origin/dev
</span></span></code></pre></div><h2 id=查看本地分支和远程分支的追踪关系>查看本地分支和远程分支的追踪关系<a hidden class=anchor aria-hidden=true href=#查看本地分支和远程分支的追踪关系>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git branch -vv
</span></span></code></pre></div><h2 id=设置git不追踪配置文件>设置git不追踪配置文件<a hidden class=anchor aria-hidden=true href=#设置git不追踪配置文件>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git update-index --assume-unchanged /path/file  <span class=c1>#设置忽略跟踪</span>
</span></span><span class=line><span class=cl>git update-index --no-assume-unchanged /path/to/file  <span class=c1>#恢复跟踪</span>
</span></span></code></pre></div><p><a href=https://www.cnblogs.com/fengxiaopanblog/p/10503346.html>https://www.cnblogs.com/fengxiaopanblog/p/10503346.html</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://moyuduo.github.io/posts/fabedge%E4%BA%91%E8%BE%B9%E9%80%9A%E4%BF%A1%E8%BE%B9%E8%BE%B9%E9%80%9A%E4%BF%A1/><span class=title>« Prev</span><br><span>fabedge云边通信、边边通信</span></a>
<a class=next href=https://moyuduo.github.io/posts/go-mod%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/><span class=title>Next »</span><br><span>go mod依赖管理</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on twitter" href="https://twitter.com/intent/tweet/?text=git%e7%9b%b8%e5%85%b3&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f&title=git%e7%9b%b8%e5%85%b3&summary=git%e7%9b%b8%e5%85%b3&source=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f&title=git%e7%9b%b8%e5%85%b3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on whatsapp" href="https://api.whatsapp.com/send?text=git%e7%9b%b8%e5%85%b3%20-%20https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share git相关 on telegram" href="https://telegram.me/share/url?text=git%e7%9b%b8%e5%85%b3&url=https%3a%2f%2fmoyuduo.github.io%2fposts%2fgit%25E7%259B%25B8%25E5%2585%25B3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://moyuduo.github.io/>Moyuduo's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>